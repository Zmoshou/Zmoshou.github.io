<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moshou</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-03T04:09:06.118Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Moshou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue中生成二维码</title>
    <link href="http://yoursite.com/2019/04/26/vue%E4%B8%AD%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>http://yoursite.com/2019/04/26/vue中生成二维码/</id>
    <published>2019-04-26T13:18:32.000Z</published>
    <updated>2020-02-03T04:09:06.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态创建二维码相关问题"><a href="#动态创建二维码相关问题" class="headerlink" title="动态创建二维码相关问题"></a>动态创建二维码相关问题</h2><h3 id="1-动态生成二维码"><a href="#1-动态生成二维码" class="headerlink" title="1. 动态生成二维码"></a>1. 动态生成二维码</h3><p>先在终端中安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install qrcodejs2</span><br></pre></td></tr></table></figure><p>然后在要生成二维码的页面中调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import QRCode from &apos;qrcodejs2&apos;</span><br></pre></td></tr></table></figure><p>然后在要展示二维码的结构处，为结构添加class属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;qrcode&quot; ref=&quot;qrCodeUrl&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>然后在<code>script</code>标签中添加方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">creatQrCode() &#123; // 创建一个实例对象</span><br><span class="line">var  qrcode = new QRCode(this.$refs.qrCodeUrl, &#123;</span><br><span class="line">text: &apos;https://www.qtshe.com&apos;,</span><br><span class="line">width: 100,height: 100,colorDark: &apos;#000000&apos;,colorLight: &apos;#ffffff&apos;,     </span><br><span class="line">correctLevel: QRCode.CorrectLevel.H </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>到此为止，二维码的功能代码已经写完，但是最后一个方法是需要调用的，否则就没有效果。</p><p>如果是在页面点击进来就要显示的话，就去<code>mounted(){}</code>钩子里面调用一下<code>this.creatQrCode();</code>，</p><p>如果是点击某个按钮等触发事件出现二维码的，只要在触发事件中绑定该方法即可。</p><h3 id="2-在二级弹窗中显示二维码"><a href="#2-在二级弹窗中显示二维码" class="headerlink" title="2.在二级弹窗中显示二维码"></a>2.在二级弹窗中显示二维码</h3><p>①如果使用对话框显示二维码，有时会由于<code>html</code>元素还没有创建，导致生成二维码时报对象不存在或者<code>appenchild</code>方法未定义的错误。这时可以<strong>使用nextTick来处理</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">showQRCode()&#123;      </span><br><span class="line">    this.$nextTick(()=&gt;&#123;/* 使用了nextTick之后，会在生成DOM元素之后绑定*/  </span><br><span class="line">        var qrcode = new QRCode(this.$refs.qrcodeContainer, &#123;              </span><br><span class="line">            text: &apos;https://wallimn.iteye.com&apos;,              </span><br><span class="line">            width: 100,              </span><br><span class="line">            height: 100,              </span><br><span class="line">            colorDark: &apos;#000000&apos;,              </span><br><span class="line">            colorLight: &apos;#ffffff&apos;,              </span><br><span class="line">            correctLevel: QRCode.CorrectLevel.H          </span><br><span class="line">        &#125;)      &#125;  &#125;</span><br></pre></td></tr></table></figure><p>②定义完方法后，<strong>只在点击出现对话框的时候，调用showQRCode的方法</strong>即可；可以不用在mounted里面进行调用。</p><p>③多次<strong>点击会出现多个二维码</strong>，这个时候要设置<code>this.$refs.qrCodeUrl.innerHTML=&#39;&#39;;</code>，保证每一次点击重新生成二维码之前，都已经将之前的清除了；</p><p>④在跳转前的页面 设置的地址如下<code>text:&quot;&#39;/qrcode/&#39; + id &quot;</code>, 到了跳转到的页面，可以通过<strong>this.$route.params.id 获取到url中的id值</strong></p>]]></content>
    
    <summary type="html">
    
      二维码
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
      <category term="二维码" scheme="http://yoursite.com/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Vue学习</title>
    <link href="http://yoursite.com/2019/04/07/Vue%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/04/07/Vue学习/</id>
    <published>2019-04-07T13:48:13.000Z</published>
    <updated>2020-01-30T14:35:16.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue学习"><a href="#Vue学习" class="headerlink" title="Vue学习"></a>Vue学习</h2><h3 id="1基本介绍"><a href="#1基本介绍" class="headerlink" title="1基本介绍"></a>1基本介绍</h3><h4 id="1-1为什么要学习流行框架"><a href="#1-1为什么要学习流行框架" class="headerlink" title="1.1为什么要学习流行框架"></a>1.1为什么要学习流行框架</h4><ul><li>企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱；</li></ul><ul><li>企业中，使用框架，能够提高开发的效率；</li></ul><ul><li><p>提高开发效率的发展历程：</p><p>原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率）</p></li></ul><h4 id="1-2什么是Vue-js"><a href="#1-2什么是Vue-js" class="headerlink" title="1.2什么是Vue.js"></a>1.2什么是Vue.js</h4><p><a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/api/</a></p><ul><li>ue.js是是一套用于构建用户界面的<strong>渐进式框架</strong>，是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex）</li><li>Vue.js 是前端的<strong>主流框架之一</strong>，和Angular.js、React.js 一起，并成为前端三大主流框架！</li><li>Vue.js 是一套构建用户界面的框架，<strong>只关注视图层</strong>，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）</li></ul><h4 id="1-3-MVC和MVVM"><a href="#1-3-MVC和MVVM" class="headerlink" title="1.3.MVC和MVVM"></a>1.3.MVC和MVVM</h4><ul><li><strong>MVC</strong><ul><li>M - Model ：数据保存</li><li>V - View : 用户界面</li><li>C - Controller ： 业务逻辑</li></ul></li></ul><p>用户操作–&gt; View (负责接受用户的输入操作)–&gt;Controller（业务逻辑处理）–&gt;Model（数据持久化）–&gt;View（将结果通过View反馈给用户）</p><p><img src="https://s2.ax1x.com/2020/01/30/11lYyn.png" alt></p><p><strong>MVC有两个很明显的问题：</strong></p><ol><li>m层和v层直接打交道，导致这两层耦合度高</li><li>因为所有逻辑都写在c层，导致c层特别臃肿</li></ol><ul><li><strong>MVC</strong></li></ul><p>前端应用的复杂程度已不同往日，暴露出了三个痛点问题：</p><ol><li>开发者在代码中大量调用相同的DOM API, 处理繁琐，操作冗余，使得代码难以维护。</li><li>大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</li><li>当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致Model发生变化，开发者同样需要将变化的数据同步到Model中， 这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。</li></ol><p><strong>MVVM 的出现，完美解决了以上三个问题，MVVM 包含的三部分：</strong></p><ul><li>Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；</li><li>View 代表UI 组件，它负责将数据模型转化成UI 展现出来</li><li>ViewModel 是一个同步View 和 Model的对象。View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互。ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图：</li></ul><h3 id="2-Vue使用"><a href="#2-Vue使用" class="headerlink" title="2.Vue使用"></a>2.Vue使用</h3><h4 id="2-1基本使用"><a href="#2-1基本使用" class="headerlink" title="2.1基本使用"></a>2.1基本使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;!-- 1. 导入Vue的包 --&gt;</span><br><span class="line">  &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- id=&quot;app&quot; : app指的是将来 new 的Vue实例，会控制这个元素中的所有内容 --&gt;</span><br><span class="line">  &lt;!-- Vue 实例所控制的这个元素区域，就是我们的 View  --&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    // 2. 创建一个Vue的实例，就是我们 MVVM中的 ViewModel</span><br><span class="line">    //  当我们导入包之后，在浏览器的内存中，就多了一个 Vue 构造函数</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">  // 表示当前我们 new 的这个 Vue 实例，要控制页面上的哪个区域</span><br><span class="line">      el: &apos;#app&apos;,  </span><br><span class="line">      // 这里的 data 就是 MVVM中的 Model，专门用来保存每个页面的数据的</span><br><span class="line">      data: &#123; </span><br><span class="line">// data 属性中，存放的是el中要用到的数据</span><br><span class="line">        msg: &apos;欢迎学习Vue&apos; // 通过 Vue 提供的指令，很方便的就能把数据渲染到页面上，</span><br><span class="line">        程序员不再手动操作DOM元素了【前端的Vue之类的框架，不提倡我们去手动操作DOM元素了】</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="2-2-常用指令"><a href="#2-2-常用指令" class="headerlink" title="2.2 常用指令"></a>2.2 常用指令</h4><ul><li>v-cloak</li><li>v-text</li><li>v-html</li><li>v-bind</li><li>v-on</li><li>v-model</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    [v-cloak] &#123;</span><br><span class="line">      display: none;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- 使用 v-cloak 能够解决 插值表达式闪烁的问题  </span><br><span class="line">    vue-2.4.0.js的加载需要时间，在vue-2.4.0.js没有成功加载之前，</span><br><span class="line">    页面会显示&#123; &#123;msg&#125;&#125;文本信息 --&gt;</span><br><span class="line">    &lt;p v-cloak&gt;++++++++ &#123;&#123; msg &#125;&#125; ----------&lt;/p&gt;</span><br><span class="line">    &lt;h4 v-text=&quot;msg&quot;&gt;==================&lt;/h4&gt;</span><br><span class="line">    &lt;!-- 默认 v-text 是没有闪烁问题的 --&gt;</span><br><span class="line">    &lt;!-- v-text会覆盖元素中原本的内容，但是插值表达式只会替换自己的这个占位符，</span><br><span class="line">    不会把整个元素的内容清空 --&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;msg2&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div v-text=&quot;msg2&quot;&gt;&lt;/div&gt;</span><br><span class="line"> &lt;!-- v-html会覆盖元素中原本的内容，只不过会将msg2当做html文本进行解析 --&gt;</span><br><span class="line">    &lt;div v-html=&quot;msg2&quot;&gt;1212112&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- v-bind: 是Vue中提供的用于绑定属性的指令，v-bind 中，可以写合法的JS表达式 --&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;按钮1&quot; v-bind:title=&quot;mytitle + &apos;123&apos;&quot;&gt; </span><br><span class="line">    &lt;!-- 注意： v-bind: 指令可以被简写为 :要绑定的属性 --&gt;</span><br><span class="line"> &lt;input type=&quot;button&quot; value=&quot;按钮2&quot; :title=&quot;mytitle + &apos;3455&apos;&quot;&gt; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- Vue 中提供了 v-on: 事件绑定机制</span><br><span class="line">          下面代码错误：因为vue会将alert理解为一个变量，而在Vue中我们并没有定义alert变量，</span><br><span class="line">          所以找不到--&gt;</span><br><span class="line">    &lt;!-- &lt;input type=&quot;button&quot; value=&quot;按钮3&quot; :title=&quot;mytitle + &apos;888&apos;&quot; v-on:click=&quot;alert(&apos;hello&apos;)&quot;&gt;--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--v-on:click可以简写成@click--&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;按钮4&quot; @click=&quot;show&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        msg: &apos;123&apos;,</span><br><span class="line">        msg2: &apos;&lt;h1&gt;哈哈，我是一个大大的H1， 我大，我骄傲&lt;/h1&gt;&apos;,</span><br><span class="line">        mytitle: &apos;这是一个自己定义的title&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123; </span><br><span class="line">        // 这个 methods属性中定义了当前Vue实例所有可用的方法</span><br><span class="line">        show: function () &#123;</span><br><span class="line">          alert(&apos;Hello&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">//在vue中不推荐我们再去使用dom操作的方法</span><br><span class="line">document.getElementById(&apos;btn&apos;).onclick = function()&#123;</span><br><span class="line">      alert(&apos;Hello&apos;)</span><br><span class="line">    &#125; */</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="2-3事件修饰符"><a href="#2-3事件修饰符" class="headerlink" title="2.3事件修饰符"></a>2.3事件修饰符</h4><ul><li>.stop       阻止冒泡</li><li>.prevent    阻止默认事件</li><li>.capture    添加事件侦听器时使用事件捕获模式</li><li>.self       只当事件在该元素本身（比如不是子元素）触发时触发回调</li><li>.once       事件只触发一次</li></ul><h4 id="2-4-v-model和双向绑定"><a href="#2-4-v-model和双向绑定" class="headerlink" title="2.4 v-model和双向绑定"></a>2.4 v-model和双向绑定</h4><ul><li>只有v-model指令实现了双向绑定， v-model 只能运用在表单元素中。如： input(radio, text, address, email….)   select    checkbox   textarea</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form id=&quot;app&quot; action=&quot;#&quot;&gt;</span><br><span class="line">    &lt;p&gt;&lt;input  v-model=&quot;email&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;input v-model=&quot;name&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;modify&quot;&gt;点我修改数据源&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;show&quot;&gt;改完表单再点我&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script src=&quot;lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        email: &apos;zhangsan@qq.com&apos;,</span><br><span class="line">        name: &apos;zhangsan&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods:&#123;</span><br><span class="line">      modify:function()&#123;</span><br><span class="line">      this.email = &apos;lisi@.qq.com&apos;;</span><br><span class="line">      &#125;,</span><br><span class="line">      show:function()&#123;</span><br><span class="line">      alert(this.email);</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="2-5-双向绑定的原理"><a href="#2-5-双向绑定的原理" class="headerlink" title="2.5 双向绑定的原理"></a>2.5 双向绑定的原理</h4><h5 id="2-5-1页面–-gt-数据"><a href="#2-5-1页面–-gt-数据" class="headerlink" title="2.5.1页面–&gt;数据"></a>2.5.1页面–&gt;数据</h5><p>view更新data只需要添加DOM事件监听即可，比如input标签监听 ‘input’ 事件就可以实现</p><h5 id="2-5-2数据–-gt-页面"><a href="#2-5-2数据–-gt-页面" class="headerlink" title="2.5.2数据–&gt;页面"></a>2.5.2数据–&gt;页面</h5><p>是通过数据劫持 + 发布者-订阅者模式的方式来实现的</p><h5 id="2-5-3数据劫持"><a href="#2-5-3数据劫持" class="headerlink" title="2.5.3数据劫持"></a>2.5.3数据劫持</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue是通过Object.defineProperty()来实现数据劫持的</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;&#125;</span><br><span class="line">Object.defineProperty(book, &apos;name&apos;, &#123;</span><br><span class="line">    set: function (value) &#123;</span><br><span class="line">        name = value;</span><br><span class="line">        console.log(&apos;你取了一个书名叫做&apos; + value);</span><br><span class="line">    &#125;,</span><br><span class="line">    get: function () &#123;</span><br><span class="line">        return &apos;《&apos; + name + &apos;》&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">book.name = &apos;vue权威指南&apos;;  // 你取了一个书名叫做vue权威指南</span><br><span class="line">book.name = &apos;vue权威指南2&apos;;  // 你取了一个书名叫做vue权威指南</span><br><span class="line">console.log(book.name);  // 《vue权威指南》</span><br></pre></td></tr></table></figure><h5 id="2-5-4发布订阅模式"><a href="#2-5-4发布订阅模式" class="headerlink" title="2.5.4发布订阅模式"></a>2.5.4发布订阅模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//1.消息订阅器，内部维护了所有订阅者的列表</span><br><span class="line">function Dep () &#123;</span><br><span class="line">    this.subs = [];</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">    addSub: function(sub) &#123;</span><br><span class="line">        this.subs.push(sub);</span><br><span class="line">    &#125;,</span><br><span class="line">    notify: function(value) &#123;</span><br><span class="line">        this.subs.forEach(function(sub) &#123;</span><br><span class="line">            sub.update(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var dep = new Dep();</span><br><span class="line"></span><br><span class="line">//2.订阅者</span><br><span class="line">function Watcher() &#123;</span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">    update: function(value)&#123;</span><br><span class="line">        console.log(&quot;数据源已经变动，新的数据是&quot;+value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var w1 = new Watcher();</span><br><span class="line">var w2 = new Watcher();</span><br><span class="line">dep.addSub(w1);</span><br><span class="line">dep.addSub(w2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//3.数据源，通过defineProperty监听数据源的变化</span><br><span class="line">var book = &#123;&#125;</span><br><span class="line">Object.defineProperty(book, &apos;name&apos;, &#123;</span><br><span class="line">    set: function (value) &#123;</span><br><span class="line">        name = value;</span><br><span class="line">        //一旦数据源发生变化了，通知所有的订阅者更新数据</span><br><span class="line">        dep.notify(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    get: function () &#123;</span><br><span class="line">        return &apos;《&apos; + name + &apos;》&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">book.name = &apos;vue权威指南&apos;;  // 你取了一个书名叫做vue权威指南</span><br><span class="line">book.name = &apos;vue权威指南2&apos;;  // 你取了一个书名叫做vue权威指南</span><br><span class="line">console.log(book.name);  // 《vue权威指南》</span><br></pre></td></tr></table></figure><h5 id="2-5-5数据绑定的实现流程"><a href="#2-5-5数据绑定的实现流程" class="headerlink" title="2.5.5数据绑定的实现流程"></a>2.5.5数据绑定的实现流程</h5><ol><li>首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。</li><li>因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。</li><li>接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。</li></ol><blockquote><p>1.监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知所有订阅者。</p><p>2.订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。</p><p>3.解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅者</p></blockquote><p><img src="https://s2.ax1x.com/2020/01/30/11UMTA.png" alt></p><h4 id="2-6vue样式操作"><a href="#2-6vue样式操作" class="headerlink" title="2.6vue样式操作"></a>2.6vue样式操作</h4><h5 id="2-6-1-class操作"><a href="#2-6-1-class操作" class="headerlink" title="2.6.1 class操作"></a>2.6.1 class操作</h5><ul><li><p>普通css</p><p><code>&lt;h1 class=&quot;red thin&quot;&gt;这是一个很大很大的H1&lt;/h1&gt;</code></p></li><li><p>vue第一种使用方式，直接传递一个数组,class需要使用  v-bind 做数据绑定</p><p><code>&lt;h1 :class=&quot;[&#39;thin&#39;, &#39;italic&#39;]&quot;&gt;这是一个很大很大的H1，&lt;/h1&gt;</code></p></li><li><p>在数组中使用三元表达式</p><p><code>&lt;h1 :class=&quot;[&#39;thin&#39;, &#39;italic&#39;, flag?&#39;active&#39;:&#39;&#39;]&quot;&gt;这是一个很大很大的H1&lt;/h1&gt;</code></p></li><li><p>在数组中使用对象来代替三元表达式，提高代码的可读性</p><p><code>&lt;h1 :class=&quot;[&#39;thin&#39;, &#39;italic&#39;, {&#39;active&#39;:flag} ]&quot;&gt;这是一个很大很大的H1&lt;/h1&gt;</code></p></li></ul><h5 id="2-6-2-style操作"><a href="#2-6-2-style操作" class="headerlink" title="2.6.2 style操作"></a>2.6.2 style操作</h5><p>​    <code>&lt;h1 :style=&quot;styleObj1&quot;&gt;标题1&lt;/h1&gt;</code></p><p>​    <code>&lt;h1 :style=&quot;[styleObj1,styleObj2]&quot;&gt;标题2&lt;/h1&gt;</code></p>]]></content>
    
    <summary type="html">
    
      Vue
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue结合webpack的使用</title>
    <link href="http://yoursite.com/2019/03/19/Vue%E7%BB%93%E5%90%88webpack%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/03/19/Vue结合webpack的使用/</id>
    <published>2019-03-19T11:18:44.000Z</published>
    <updated>2020-01-28T14:45:09.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue结合webpack的使用"><a href="#Vue结合webpack的使用" class="headerlink" title="Vue结合webpack的使用"></a>Vue结合webpack的使用</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#1.安装vue</span><br><span class="line">   运行npm i vue@2.3.4将vue安装为运行依赖</span><br><span class="line">   </span><br><span class="line">#2.main.js</span><br><span class="line">/*</span><br><span class="line"> 注意：在webpack中使用 import Vue from &apos;vue&apos;导入的Vue构造函数功能不完整，只提供了runtime-only的方式，并没有提供像网页中那样的使用方式；</span><br><span class="line"> import Vue from &apos;vue&apos; 导入包的规则：</span><br><span class="line">   1. 找项目根目录中有没有 node_modules 的文件夹</span><br><span class="line">   2. 在node_modules中根据包名，找对应的vue文件夹</span><br><span class="line">   3. 在vue文件夹中，找一个叫做 package.json 的包配置文件</span><br><span class="line">   4. 在package.json文件中，查找一个 main 属性【main属性指定了这个包在被加载时候的入口文件】，这里我们发现入口文件为vue.runtime.common.js，并不是vue.js文件</span><br><span class="line"></span><br><span class="line"> 解决方案有两种：</span><br><span class="line">   1.在webpack.config.js下新增配置：</span><br><span class="line">       resolve: &#123;</span><br><span class="line">            alias: &#123;</span><br><span class="line">                &apos;vue$&apos;: &apos;vue/dist/vue.js&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        然后使用 import Vue from &apos;vue&apos;  就可以了</span><br><span class="line">        </span><br><span class="line">   2.手动修改导包的路径为：import Vue from &apos;vue/dist/vue&apos;&apos;，此时无需修改配置文件</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">var login = &#123;</span><br><span class="line">   template: &apos;&lt;h1&gt;这是login组件，是使用网页中形式创建出来的组件&lt;/h1&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        msg: &apos;123&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        login</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">#3.index.html</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;login&gt;&lt;/login&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">#4.webpack.config.js</span><br><span class="line">resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">        &apos;vue$&apos;: &apos;vue/dist/vue.js&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#5.package.json、.babelrc还有webpack的所需要安装的内容和之前一致</span><br></pre></td></tr></table></figure><h3 id="2-使用-vue的方式生成组件"><a href="#2-使用-vue的方式生成组件" class="headerlink" title="2.使用.vue的方式生成组件"></a>2.使用.vue的方式生成组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vscode中安装vetur插件，可以格式化html、标准css（有分号 、大括号的那种）、标准js（有分号 、双引号的那种）、vue文件webstorm中支持vue文件的提示，需要安装插件</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#1. 新建login.vue文件</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;这是登录组件，使用 .vue 文件定义出来的 &lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2.main.js引入.vue文件，并使用</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">import login from &apos;./login.vue&apos;</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        msg: &apos;123&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        login</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">#3. index.html</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;login&gt;&lt;/login&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">#4.安装vue-loader和 vue-template-compiler(默认情况下不支持import方式引入.vue文件，需要安装下面两个文件)</span><br><span class="line">npm i vue-loader@15.4.2 vue-template-compiler@2.3.4</span><br><span class="line">//注意：这里vue-template-compiler版本需要和当前使用的vue版本一致</span><br><span class="line"></span><br><span class="line">#5.webpack.config.js</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">//1.引入VueLoaderPlugin插件(在vue-loader15版本以后需要配置这个)</span><br><span class="line">const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: path.join(__dirname, &apos;./src/main.js&apos;),</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, &apos;./dist&apos;),</span><br><span class="line">        filename: &apos;bundle.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new htmlWebpackPlugin(&#123;</span><br><span class="line">            template:path.resolve(__dirname, &apos;src/index.html&apos;),//模板路径</span><br><span class="line">            filename:&apos;index.html&apos;//自动生成的HTML文件的名称</span><br><span class="line">        &#125;),</span><br><span class="line">        // 2.配置VueLoaderPlugin插件</span><br><span class="line">        new VueLoaderPlugin()</span><br><span class="line">    ],</span><br><span class="line">    module: &#123; </span><br><span class="line">        rules: [ </span><br><span class="line">            &#123; test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;,</span><br><span class="line">            &#123; test: /\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125;,</span><br><span class="line">            &#123; test: /\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125;,</span><br><span class="line">            &#123; test: /\.(png|jpg|gif|bmp|jpeg)$/, use: &apos;url-loader?limit=1024&amp;name=[hash:8]-[name].[ext]&apos; &#125;,</span><br><span class="line">            &#123; test: /\.(ttf|eot|svg|woff|woff2)$/, use: &apos;url-loader&apos; &#125;, </span><br><span class="line">            &#123; test: /\.js$/, use: &apos;babel-loader&apos;, exclude: /node_modules/ &#125;,</span><br><span class="line">            //3.处理 .vue 文件的 loader</span><br><span class="line">            &#123; test: /\.vue$/, use: &apos;vue-loader&apos; &#125; </span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">           &apos;vue$&apos;: &apos;vue/dist/vue.js&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-render渲染组件"><a href="#3-render渲染组件" class="headerlink" title="3.render渲染组件"></a>3.render渲染组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#main.js</span><br><span class="line"></span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">import login from &apos;./login.vue&apos;</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        msg: &apos;123&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    render: c =&gt; c(login)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//注意：此种方式会替换页面内容</span><br></pre></td></tr></table></figure><h3 id="4-vue组件中的数据"><a href="#4-vue组件中的数据" class="headerlink" title="4.vue组件中的数据"></a>4.vue组件中的数据</h3><h4 id="2-4-1-模块的导出"><a href="#2-4-1-模块的导出" class="headerlink" title="2.4.1 模块的导出"></a>2.4.1 模块的导出</h4><p>   ES6语法：</p><blockquote><ol><li><p>在ES6中使用 export default 和 export 导出模块中的成员;</p><p>(Node中使用 module.exports 和 export导出成员)</p></li><li><p>使用 import ** from ** 和 import ‘路径’ 还有 import {a, b} from ‘模块标识’ 导入其他模块</p></li></ol></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#1. 新建test.js</span><br><span class="line"><span class="comment">// 在 ES6 中，使用 export default 和 export 向外暴露成员：</span></span><br><span class="line"><span class="keyword">var</span> info = &#123;</span><br><span class="line">  name: <span class="string">'zs'</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> info</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注意：</span></span><br><span class="line"><span class="comment">   export default 向外暴露的成员，可以使用任意的变量来接收</span></span><br><span class="line"><span class="comment">   在一个模块中，export default 只允许向外暴露1次</span></span><br><span class="line"><span class="comment">   在一个模块中，可以同时使用 export default 和 export 向外暴露成员</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> title = <span class="string">'小星星'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> content = <span class="string">'哈哈哈'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*注意：</span></span><br><span class="line"><span class="comment">     使用 export 向外暴露的成员，只能使用 &#123; &#125; 的形式来接收，这种形式叫做 【按需导出】</span></span><br><span class="line"><span class="comment">     export 可以向外暴露多个成员， 同时如果某些成员在我们import 的时候不需要，则可以不在 &#123;&#125;  中定义</span></span><br><span class="line"><span class="comment">     使用 export 导出的成员，必须严格按照导出时候的名称来使用  &#123;&#125;  按需接收；</span></span><br><span class="line"><span class="comment">     使用 export 导出的成员，如果想换个名称来接收，可以使用 as 来起别名；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#2. main.js</span><br><span class="line"><span class="keyword">import</span> minfo3, &#123; title <span class="keyword">as</span> title123, content &#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"><span class="built_in">console</span>.log(minfo3)    <span class="comment">//这里的minfo3就是test.js中所暴露出来的default info</span></span><br><span class="line"><span class="built_in">console</span>.log(title123 + <span class="string">' --- '</span> + content)</span><br></pre></td></tr></table></figure><h4 id="2-4-2-vue中的数据导出"><a href="#2-4-2-vue中的数据导出" class="headerlink" title="2.4.2 .vue中的数据导出"></a>2.4.2 .vue中的数据导出</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#login.vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;这是登录组件，使用 .vue 文件定义出来的 --- &#123;&#123;msg&#125;&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button @click="show"&gt;点我&lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="comment">// 注意：组件中的 data 必须是 function</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        msg: <span class="string">"123321"</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      show() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"调用了 login.vue 中的 show 方法"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      webpack
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>ES6基础知识</title>
    <link href="http://yoursite.com/2019/03/19/ES6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/03/19/ES6基础知识/</id>
    <published>2019-03-19T11:18:44.000Z</published>
    <updated>2020-01-29T06:23:44.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES6基础知识"><a href="#ES6基础知识" class="headerlink" title="ES6基础知识"></a>ES6基础知识</h2><h3 id="1-let-和-const"><a href="#1-let-和-const" class="headerlink" title="1.let 和 const"></a>1.let 和 const</h3><p>在ES6之前，js只有全局作用域和函数作用域，ES6中let关键字为其引入了块级作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//&#123;&#125;代码块</span><br><span class="line">&#123;</span><br><span class="line">var a = 5;</span><br><span class="line">let b = 6;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);     //5</span><br><span class="line">console.log(b);     //b is undefined</span><br></pre></td></tr></table></figure><ul><li><p>let声明的变量只能在其所在的代码块内才能访问，var声明的变量由于是全局变量，因此可以在代码块外访问</p></li><li><p>const用来定义常量，相当于java中的<code>final</code>关键字。并且const声明常量之后就必须立即初始化！</p></li><li><p>et声明的变量一旦用let声明，那么在声明之前，此变量都是不可用的，术语称为“暂时性死区”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(a);                     //undefined</span><br><span class="line">var a=8;</span><br><span class="line">console.log(&quot;----------&quot;);</span><br><span class="line">console.log(b);                     //控制台报错</span><br><span class="line">let b=9;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-解构赋值"><a href="#2-解构赋值" class="headerlink" title="2.解构赋值"></a>2.解构赋值</h3><blockquote><p>ES6允许按照一定的模式从数组和对象中提取值，对变量进行赋值，这被称为解构。</p></blockquote><p>(1)、基本用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//新的定义方法</span><br><span class="line">let  [name,age,sex] = [&quot;李四&quot;,20,&quot;女&quot;];</span><br><span class="line"></span><br><span class="line">//以前的定义方法</span><br><span class="line">let name = &quot;李四&quot;;</span><br><span class="line">let age = 20;</span><br><span class="line">let sex = &quot;女&quot;</span><br></pre></td></tr></table></figure><p>(2)、对象的解构赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//前面的key值和后面的key值相对应的</span><br><span class="line">let &#123;name,age,friends&#125; = &#123;name:&quot;zhangsan&quot;,age:12,friends:[&quot;lulu&quot;,&quot;女&quot;]&#125;;</span><br><span class="line">console.log(name); //zhangsan</span><br></pre></td></tr></table></figure><p>(3)、嵌套数组的解构赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//只要一一对应就可以</span><br><span class="line">let [a1,[a2,a3,[a4,a5]]] = [1,[2,3,[4,5]]];</span><br><span class="line">console.log(a1,a2,a3,a4,a5);  //1，2，3，4，5</span><br></pre></td></tr></table></figure><p>(4)、字符串的解构赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let [a,b,c,d,e] = &quot;我是中国人&quot;;</span><br><span class="line">console.log(a);   //我</span><br><span class="line">console.log(b);   //是</span><br><span class="line">console.log(c);   //中</span><br><span class="line">console.log(d);   //国</span><br><span class="line">console.log(e);   //人</span><br></pre></td></tr></table></figure><p>(5)、空缺变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [a,b,,e]=[&apos;a&apos;,&apos;b&apos;,[1,2],4]</span><br></pre></td></tr></table></figure><p>(6)、多余变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [a,b,,e,f]=[&apos;a&apos;,&apos;b&apos;,[3,4],5]</span><br></pre></td></tr></table></figure><blockquote><p>注意：因为字符串有构造器，所以可以解析出来。</p></blockquote><h3 id="3-字符串的扩展"><a href="#3-字符串的扩展" class="headerlink" title="3.字符串的扩展"></a>3.字符串的扩展</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Unicode表示法</span><br><span class="line">&quot;\u&#123;码点&#125;&quot;</span><br><span class="line">&quot;\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;&quot;                 //&quot;ABC&quot;</span><br><span class="line"></span><br><span class="line">let str = &quot;書剑恩仇录&quot;;</span><br><span class="line">str.codePointAt(0).toString(16);    //返回字符的码点并由十进制转到16进制---66f8</span><br><span class="line">String.fromCodePoint(0x66f8);       //返回码点对应的字符---書</span><br><span class="line">for (let a of str)&#123;</span><br><span class="line">   console.log(a);</span><br><span class="line">&#125;                                   //for...of循环遍历字符串中每个字符挨个输出字符</span><br><span class="line">str.at(0);                          //返回指定位置的字符，目前只是提案</span><br><span class="line">str.startsWith(&apos;書&apos;,0);             //从指定位置往后开始检查，是否以“書”开始，位置参数可省略，默认为0</span><br><span class="line">str.endsWith(&apos;剑&apos;,1);               //从指定位置向前检查，是否以“剑”结束</span><br><span class="line">str.includes(&apos;恩&apos;,1);               //同上，不再啰嗦</span><br><span class="line">str.repeat(2);                      //字符串重复指定次数“書剑恩仇录書剑恩仇录”，小数取整，Infinity和负数报错</span><br><span class="line">str.padStart(8,&apos;ab&apos;);               //指定字符从前开始补直到字符串长度符合要求，&quot;aba書剑恩仇录&quot;</span><br><span class="line">str.padEnd(8,&apos;ab&apos;);                 //指定字符从后开始补直到字符串长度符合要求，&quot;書剑恩仇录aba&quot;，若长度小于原长度，返回原字符串，上同</span><br></pre></td></tr></table></figure><h3 id="4-模版字符串"><a href="#4-模版字符串" class="headerlink" title="4.模版字符串"></a>4.模版字符串</h3><p>使用``包裹字符串 ${}包裹变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 普通字符串</span><br><span class="line">`In JavaScript &apos;\n&apos; is a line-feed.`</span><br><span class="line"></span><br><span class="line">// 多行字符串</span><br><span class="line">`In JavaScript this is</span><br><span class="line"> not legal.`</span><br><span class="line"></span><br><span class="line">console.log(`string text line 1 </span><br><span class="line">string text line 2`);</span><br><span class="line"></span><br><span class="line">// 字符串中嵌入变量</span><br><span class="line">let name = &quot;Bob&quot;, time = &quot;today&quot;;</span><br><span class="line">`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`</span><br></pre></td></tr></table></figure><h3 id="5-函数的扩展"><a href="#5-函数的扩展" class="headerlink" title="5.函数的扩展"></a>5.函数的扩展</h3><h4 id="1-参数默认值"><a href="#1-参数默认值" class="headerlink" title="1.参数默认值"></a>1.参数默认值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ES5中的写法</span><br><span class="line">function log(x, y) &#123;</span><br><span class="line">  //y = y || &apos;World&apos;;  --&gt; 这种写法如果y是false则不起作用，所以用下面的方式复制</span><br><span class="line">  if (typeof y === &apos;undefined&apos;) &#123;</span><br><span class="line">    y = &apos;World&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(&apos;Hello&apos;) // Hello World</span><br><span class="line"></span><br><span class="line">ES6中的写法</span><br><span class="line">function log(x, y = &apos;World&apos;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">log(&apos;Hello&apos;) // Hello World</span><br></pre></td></tr></table></figure><h4 id="2-箭头函数"><a href="#2-箭头函数" class="headerlink" title="2.箭头函数"></a>2.箭头函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var f = v =&gt; v;</span><br><span class="line">// 等同于</span><br><span class="line">var f = function (v) &#123;</span><br><span class="line">  return v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</span><br><span class="line">var f = () =&gt; 5;</span><br><span class="line">// 等同于</span><br><span class="line">var f = function () &#123; return 5 &#125;;</span><br></pre></td></tr></table></figure><h4 id="3-rest参数（剩余参数）"><a href="#3-rest参数（剩余参数）" class="headerlink" title="3.rest参数（剩余参数）"></a>3.rest参数（剩余参数）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo(a,b,...param)&#123; //...param会以数组的形式存储剩余的参数</span><br><span class="line">console.log(param);</span><br><span class="line">&#125;</span><br><span class="line">foo(1,2,3,4,5,6,7);//[3,4,5,6,7]</span><br></pre></td></tr></table></figure><h3 id="6-数组的扩展"><a href="#6-数组的扩展" class="headerlink" title="6.数组的扩展"></a>6.数组的扩展</h3><h4 id="1-Array-from"><a href="#1-Array-from" class="headerlink" title="1.Array.from"></a>1.Array.from</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let list = document.querySelectorAll(&quot;li&quot;)</span><br><span class="line">   console.log(Array.isArray(list));  //false</span><br><span class="line">   Array.from(list);  //将非数组list转为数组</span><br><span class="line">   console.log(Array.isArray(Array.from(list))); //true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.from(arrayLike[, mapFn[, thisArg]])</span><br></pre></td></tr></table></figure><p>返回值为转换后的数组。</p><p><strong>arrayLike</strong></p><p>想要转换的类数组对象或可迭代对象。</p><p>console.log(Array.from([1, 2, 3])); // [1, 2, 3]</p><p><strong>mapFn</strong></p><p>可选，map 函数，用于对每个元素进行处理，放入数组的是处理后的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Array.from([1, 2, 3], (n) =&gt; n * 2)); // [2, 4, 6]</span><br></pre></td></tr></table></figure><p><strong>thisArg</strong></p><p>可选，用于指定 map 函数执行时的 this 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let map = &#123;do: function(n) &#123;return n * 2;&#125;&#125;</span><br><span class="line">let arrayLike = [1, 2, 3];</span><br><span class="line">console.log(Array.from(arrayLike, function (n)&#123;</span><br><span class="line">return this.do(n);</span><br><span class="line">&#125;, map)); // [2, 4, 6]</span><br></pre></td></tr></table></figure><h4 id="2-Array-of"><a href="#2-Array-of" class="headerlink" title="2.Array.of"></a>2.Array.of</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.of(1,2,3,4); //将零散元素转为数组</span><br><span class="line">console.log(Array.isArray(Array.of(1, 2, 3, 4)));  //true</span><br></pre></td></tr></table></figure><h4 id="3-ES6-的合并数组"><a href="#3-ES6-的合并数组" class="headerlink" title="3. ES6 的合并数组"></a>3. ES6 的合并数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...arr1, ...arr2, ...arr3]</span><br></pre></td></tr></table></figure><h4 id="4-新增数组方法"><a href="#4-新增数组方法" class="headerlink" title="4.新增数组方法"></a>4.新增数组方法</h4><p><strong>1.find()</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找数组中符合条件的元素,若有多个符合条件的元素，则返回第一个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组空位处理为 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="number">1</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> <span class="literal">true</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><strong>2.findIndex()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查找数组中符合条件的元素索引，若有多个符合条件的元素，则返回第一个元素索引。</span><br><span class="line"></span><br><span class="line">let arr = Array.of(1, 2, 1, 3);</span><br><span class="line">// 参数1：回调函数</span><br><span class="line">// 参数2(可选)：指定回调函数中的 this 值</span><br><span class="line">console.log(arr.findIndex(item =&gt; item = 1)); // 0</span><br><span class="line"> </span><br><span class="line">// 数组空位处理为 undefined</span><br><span class="line">console.log([, 1].findIndex(n =&gt; true)); //0</span><br></pre></td></tr></table></figure><p><strong>3.fill()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将一定范围索引的数组元素内容填充为单个指定的值。</span><br><span class="line"></span><br><span class="line">let arr = Array.of(1, 2, 3, 4);</span><br><span class="line">// 参数1：用来填充的值</span><br><span class="line">// 参数2：被填充的起始索引</span><br><span class="line">// 参数3(可选)：被填充的结束索引，默认为数组末尾</span><br><span class="line">console.log(arr.fill(0,1,2)); // [1, 0, 3, 4]</span><br></pre></td></tr></table></figure><p><strong>4.copyWithin()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">将一定范围索引的数组元素修改为此数组另一指定范围索引的元素。</span><br><span class="line"></span><br><span class="line">// 参数1：被修改的起始索引</span><br><span class="line">// 参数2：被用来覆盖的数据的起始索引</span><br><span class="line">// 参数3(可选)：被用来覆盖的数据的结束索引，默认为数组末尾</span><br><span class="line">console.log([1, 2, 3, 4].copyWithin(0,2,4)); // [3, 4, 3, 4]</span><br><span class="line"> </span><br><span class="line">// 参数1为负数表示倒数</span><br><span class="line">console.log([1, 2, 3, 4].copyWithin(-2, 0)); // [1, 2, 1, 2]</span><br><span class="line"> </span><br><span class="line">console.log([1, 2, ,4].copyWithin(0, 2, 4)); // [, 4, , 4]</span><br></pre></td></tr></table></figure><p><strong>5.includes()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">includes()</span><br><span class="line"></span><br><span class="line">数组是否包含指定值。</span><br><span class="line"></span><br><span class="line">注意：与 Set 和 Map 的 has 方法区分；Set 的 has 方法用于查找值；Map 的 has 方法用于查找键名。</span><br><span class="line"></span><br><span class="line">// 参数1：包含的指定值</span><br><span class="line">[1, 2, 3].includes(1);    // true</span><br><span class="line"> </span><br><span class="line">// 参数2：可选，搜索的起始索引，默认为0</span><br><span class="line">[1, 2, 3].includes(1, 2); // false</span><br><span class="line"> </span><br><span class="line">// NaN 的包含判断</span><br><span class="line">[1, NaN, 3].includes(NaN); // true</span><br></pre></td></tr></table></figure><p><strong>6.flat()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log([1 ,[2, 3]].flat()); // [1, 2, 3]</span><br><span class="line"> </span><br><span class="line">// 指定转换的嵌套层数</span><br><span class="line">console.log([1, [2, [3, [4, 5]]]].flat(2)); // [1, 2, 3, [4, 5]]</span><br><span class="line"> </span><br><span class="line">// 不管嵌套多少层</span><br><span class="line">console.log([1, [2, [3, [4, 5]]]].flat(Infinity)); // [1, 2, 3, 4, 5]</span><br><span class="line"> </span><br><span class="line">// 自动跳过空位</span><br><span class="line">console.log([1, [2, , 3]].flat());&lt;p&gt; // [1, 2, 3]</span><br></pre></td></tr></table></figure><p><strong>7.flatMap()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先对数组中每个元素进行了的处理，再对数组执行 flat() 方法。</span><br><span class="line"></span><br><span class="line">// 参数1：遍历函数，该遍历函数可接受3个参数：当前元素、当前元素索引、原数组</span><br><span class="line">// 参数2：指定遍历函数中 this 的指向</span><br><span class="line">console.log([1, 2, 3].flatMap(n =&gt; [n * 2])); // [2, 4, 6]</span><br></pre></td></tr></table></figure><h3 id="7-Symbol"><a href="#7-Symbol" class="headerlink" title="7.Symbol"></a>7.Symbol</h3><p>ES6新增数据类型 属于基本数据类型，Symbol不可以new</p><p>Symbol声明的变量是唯一的，意义在于减少命名冲突；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    //Symbol的变量是唯一的，所以a1和a2永远不相等</span><br><span class="line">    let a1 = Symbol();</span><br><span class="line">    let a2 = Symbol();</span><br><span class="line">    console.log(a1 === a2);</span><br><span class="line">    </span><br><span class="line">   //Symbol.for(key)</span><br><span class="line">   //在使用Symbol时  会生成一个全局注册表，其中的数据以键值对的形式存在；能根据key来拿到对应的value</span><br><span class="line">   //若  a3  a4的key是相同的  那么a3 a4是相同的</span><br><span class="line">    let a3 = Symbol.for(&quot;a3&quot;);</span><br><span class="line">    let a4 = Symbol.for(&quot;a3&quot;);</span><br><span class="line">    console.log(a3 === a4);  //true</span><br><span class="line">    </span><br><span class="line">    //问题  若改变a3的值  a4的值会改变吗？</span><br><span class="line">    //是值复制   还是指针</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-ES6中的数据结构"><a href="#8-ES6中的数据结构" class="headerlink" title="8.ES6中的数据结构"></a>8.ES6中的数据结构</h3><h4 id="8-1Map"><a href="#8-1Map" class="headerlink" title="8.1Map"></a>8.1Map</h4><p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">p</span>: <span class="string">'Hello World'</span>&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, <span class="string">'content'</span>)   </span><br><span class="line">m.get(o) <span class="comment">// "content"</span></span><br><span class="line"></span><br><span class="line">m.has(o) <span class="comment">// true</span></span><br><span class="line">m.delete(o) <span class="comment">// true</span></span><br><span class="line">m.has(o) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="8-2Set"><a href="#8-2Set" class="headerlink" title="8.2Set"></a>8.2Set</h4><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set.add(ele)向set集合中追加ele元素</span><br><span class="line">set.has(ele)判断set集合中是否存在ele元素</span><br><span class="line">set.delete(ele)从集合中删除ele元素</span><br><span class="line">set.clear()清空set集合</span><br><span class="line">set.forEach( (ele) =&gt;&#123;&#125; )遍历集和</span><br></pre></td></tr></table></figure><h3 id="9-ES6-Reflect-与-Proxy"><a href="#9-ES6-Reflect-与-Proxy" class="headerlink" title="9. ES6 Reflect 与 Proxy"></a>9. ES6 Reflect 与 Proxy</h3><h4 id="9-1-Proxy"><a href="#9-1-Proxy" class="headerlink" title="9.1 Proxy"></a>9.1 Proxy</h4><p>一个 Proxy 对象由两个部分组成： target 、 handler 。在通过 Proxy 构造函数生成实例对象时，需要提供这两个参数。 target 即目标对象， handler 是一个对象，声明了代理 target 的指定行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>: function(target, key) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'getting '</span>+key);</span><br><span class="line">        <span class="keyword">return</span> target[key]; <span class="comment">// 不是target.key</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(target, key, value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setting '</span>+key);</span><br><span class="line">        target[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">proxy.name     <span class="comment">// 实际执行 handler.get</span></span><br><span class="line">proxy.age = <span class="number">25</span> <span class="comment">// 实际执行 handler.set</span></span><br><span class="line"><span class="comment">// getting name</span></span><br><span class="line"><span class="comment">// setting age</span></span><br><span class="line"><span class="comment">// 25</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// target 可以为空对象</span></span><br><span class="line"><span class="keyword">let</span> targetEpt = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxyEpt = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetEpt, handler)</span><br><span class="line"><span class="comment">// 调用 get 方法，此时目标对象为空，没有 name 属性</span></span><br><span class="line">proxyEpt.name <span class="comment">// getting name</span></span><br><span class="line"><span class="comment">// 调用 set 方法，向目标对象中添加了 name 属性</span></span><br><span class="line">proxyEpt.name = <span class="string">'Tom'</span></span><br><span class="line"><span class="comment">// setting name</span></span><br><span class="line"><span class="comment">// "Tom"</span></span><br><span class="line"><span class="comment">// 再次调用 get ，此时已经存在 name 属性</span></span><br><span class="line">proxyEpt.name</span><br><span class="line"><span class="comment">// getting name</span></span><br><span class="line"><span class="comment">// "Tom"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过构造函数新建实例时其实是对目标对象进行了浅拷贝，因此目标对象与代理对象会互相</span></span><br><span class="line"><span class="comment">// 影响</span></span><br><span class="line">targetEpt)</span><br><span class="line"><span class="comment">// &#123;name: "Tom"&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// handler 对象也可以为空，相当于不设置拦截操作，直接访问目标对象</span></span><br><span class="line"><span class="keyword">let</span> targetEmpty = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxyEmpty = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetEmpty,&#123;&#125;)</span><br><span class="line">proxyEmpty.name = <span class="string">"Tom"</span></span><br><span class="line">targetEmpty) <span class="comment">// &#123;name: "Tom"&#125;</span></span><br></pre></td></tr></table></figure><h4 id="9-2-Reflect"><a href="#9-2-Reflect" class="headerlink" title="9.2 Reflect"></a>9.2 Reflect</h4><p>ES6 中将 Object 的一些明显属于语言内部的方法移植到了 Reflect 对象上（当前某些方法会同时存在于 Object 和 Reflect 对象上），未来的新方法会只部署在 Reflect 对象上。</p><p>Reflect 对象对某些方法的返回结果进行了修改，使其更合理。</p><p>Reflect 对象使用函数的方式实现了 Object 的命令式操作。</p><ol><li><p><strong>Reflect.get</strong></p><p>查找并返回 target 对象的 name 属性</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.get(target, name, receiver) </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> exam = &#123;</span><br><span class="line">    name: <span class="string">"Tom"</span>,</span><br><span class="line">    age: <span class="number">24</span>,</span><br><span class="line">    <span class="keyword">get</span> info()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Reflect</span>.get(exam, <span class="string">'name'</span>); <span class="comment">// "Tom"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当 target 对象中存在 name 属性的 getter 方法， getter 方法的 this 会绑定 // receiver</span></span><br><span class="line"><span class="keyword">let</span> receiver = &#123;</span><br><span class="line">    name: <span class="string">"Jerry"</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Reflect</span>.get(exam, <span class="string">'info'</span>, receiver); <span class="comment">// Jerry20</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当 name 为不存在于 target 对象的属性时，返回 undefined</span></span><br><span class="line"><span class="built_in">Reflect</span>.get(exam, <span class="string">'birth'</span>); <span class="comment">// undefined</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当 target 不是对象时，会报错</span></span><br><span class="line"><span class="built_in">Reflect</span>.get(<span class="number">1</span>, <span class="string">'name'</span>); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Reflect.set</strong></li></ol><p>将 target 的 name 属性设置为 value。返回值为 boolean ，true 表示修改成功，false 表示失败。当 target 为不存在的对象时，会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">let exam = &#123;</span><br><span class="line">    name: &quot;Tom&quot;,</span><br><span class="line">    age: 24,</span><br><span class="line">    set info(value)&#123;</span><br><span class="line">        return this.age = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">exam.age; // 24</span><br><span class="line">Reflect.set(exam, &apos;age&apos;, 25); // true</span><br><span class="line">exam.age; // 25</span><br><span class="line"> </span><br><span class="line">// value 为空时会将 name 属性清除</span><br><span class="line">Reflect.set(exam, &apos;age&apos;, ); // true</span><br><span class="line">exam.age; // undefined</span><br><span class="line"> </span><br><span class="line">// 当 target 对象中存在 name 属性 setter 方法时，setter 方法中的 this 会绑定 // receiver , 所以修改的实际上是 receiver 的属性,</span><br><span class="line">let receiver = &#123;</span><br><span class="line">    age: 18</span><br><span class="line">&#125;</span><br><span class="line">Reflect.set(exam, &apos;info&apos;, 1, receiver); // true</span><br><span class="line">receiver.age; // 1</span><br><span class="line"> </span><br><span class="line">let receiver1 = &#123;</span><br><span class="line">    name: &apos;oppps&apos;</span><br><span class="line">&#125;</span><br><span class="line">Reflect.set(exam, &apos;info&apos;, 1, receiver1);</span><br><span class="line">receiver1.age; // 1</span><br></pre></td></tr></table></figure><h3 id="10-Promise和asymc"><a href="#10-Promise和asymc" class="headerlink" title="10.Promise和asymc"></a>10.Promise和asymc</h3><h4 id="10-1-Promise-状态"><a href="#10-1-Promise-状态" class="headerlink" title="10.1 Promise 状态"></a>10.1 Promise 状态</h4><p>Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。</p><p>Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">'success1'</span>);</span><br><span class="line">    resolve(<span class="string">'success2'</span>);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;  </span><br><span class="line">    resolve(<span class="string">'success3'</span>); </span><br><span class="line">    reject(<span class="string">'reject'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// success1</span></span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// success3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="10-2-async"><a href="#10-2-async" class="headerlink" title="10.2 async"></a>10.2 async</h4><p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。</p><p>和await结合使用 使Promise 看起来像同步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function testAwait (x) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(x);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">async function helloAsync() &#123;</span><br><span class="line">  var x = await testAwait (&quot;hello world&quot;);</span><br><span class="line">  console.log(x); </span><br><span class="line">&#125;</span><br><span class="line">helloAsync ();</span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      ES6基础知识
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="http://yoursite.com/2019/03/04/webpack/"/>
    <id>http://yoursite.com/2019/03/04/webpack/</id>
    <published>2019-03-04T14:47:43.000Z</published>
    <updated>2020-01-27T17:03:50.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h3 id="1-概念以及作用"><a href="#1-概念以及作用" class="headerlink" title="1.概念以及作用"></a>1.概念以及作用</h3><p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)</em>。当 webpack 处理应用程序时，它会递归地构建一个<em>依赖关系图(dependency graph)</em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em>。</p><blockquote><p>webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具；</p></blockquote><ul><li>借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 在没有使用webpack之前：</span><br><span class="line">举个例子：index.html里面有一大堆的css和js文件，如a.js   b.js   c.js  d.js等等</span><br><span class="line">（1）a.js要用到b.js里面的一个函数，则a.js要放在b.js后面</span><br><span class="line">（2）c.js要用到a.js里面的一个函数，则c.js要放在a.js后面</span><br><span class="line">（3）b.js又要用到d.js文件里面的函数，则b.js就要放在d.js后面</span><br><span class="line">如果有N多个js文件，需要手动处理他们的关系，即容易出错。</span><br><span class="line"></span><br><span class="line"># 使用webpack：</span><br><span class="line">webpack的理念就是一切皆模块化，把一堆的css文件和js文件放在一个总的入口文件，通过require引入，剩下的事情webpack会处理，包括所有模块的前后依赖关系，打包、压缩、合并成一个js文件，公共代码抽离成一个js文件、某些自己指定的js单独打包，模块可以是css/js/images/font等等。</span><br></pre></td></tr></table></figure><h3 id="2-webpack的使用"><a href="#2-webpack的使用" class="headerlink" title="2.webpack的使用"></a>2.webpack的使用</h3><h4 id="2-1webpack的安装"><a href="#2-1webpack的安装" class="headerlink" title="2.1webpack的安装"></a>2.1webpack的安装</h4><ol><li><p>运行<code>npm i webpack@4.27.1 -g</code>全局安装webpack，这样就能在全局使用webpack的命令</p><p><code>npm i webpack-cli@3.1.2 –g</code> 全局安装webpack命令行工具</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">配置环境变量</span><br></pre></td></tr></table></figure><ol><li>在项目根目录中运行<code>npm i webpack@4.27.1 --save-dev</code>安装到项目依赖中</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm info webpack <span class="comment">//查看npm上的webpack的信息</span></span><br><span class="line"></span><br><span class="line">webpack -v   <span class="comment">//查看当前安装的webpack的版本信息</span></span><br></pre></td></tr></table></figure><p>####2.2webpack的配置文件</p><ol><li><p>在项目根目录中创建<code>webpack.config.js</code></p></li><li><p>由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在<code>webpack.config.js</code>中配置这两个路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 导入处理路径的模块</span><br><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: path.resolve(__dirname, &apos;src/main.js&apos;), // 项目入口文件</span><br><span class="line">    output: &#123; // 配置输出选项</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;), // 配置输出的路径</span><br><span class="line">        filename: &apos;bundle.js&apos; // 配置输出的文件名</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用命令打包构建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 使用webpack命令即可打包项目、</span><br><span class="line">webpack   //没有指定webpack打包的配置文件，默认使用项目根路径下的webpack.config.js文件</span><br><span class="line">webpack --config webpack.config.js  //指定webpack打包的时候使用的配置文件</span><br><span class="line"></span><br><span class="line">// 当我们在控制台，直接输入 webpack 命令执行的时候，webpack 做了以下几步：</span><br><span class="line">//  1. 首先webpack 发现我们并没有通过命令的形式给它指定入口和出口</span><br><span class="line">//  2. webpack 就会去项目的根目录中查找一个叫做 `webpack.config.js` 的配置文件</span><br><span class="line">//  3. 当找到配置文件后，webpack会去解析执行这个配置文件，当解析执行完配置文件后，就得到了 配置文件中，导出的配置对象</span><br><span class="line">//  4. 当 webpack拿到配置对象后，就拿到了配置对象中指定的入口和出口，然后进行打包构建；</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-3webpack实时打包构建"><a href="#2-3webpack实时打包构建" class="headerlink" title="2.3webpack实时打包构建"></a>2.3webpack实时打包构建</h4><ol><li><p>由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用<code>webpack-dev-server</code>来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。</p></li><li><p>安装webpack-dev-server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack-dev-server@3.1.9 --save-dev</span><br><span class="line">npm i webpack@4.27.1 --save-dev     //项目中安装webpack</span><br><span class="line">npm i webpack-cli@3.1.2</span><br></pre></td></tr></table></figure></li><li><p>安装完成之后，在命令行直接运行<code>webpack-dev-server</code>来进行打包，发现报错，因为它不是全局命令，不可以直接使用。</p></li><li><p>我们借助于<code>package.json</code>文件中的指令来进行运行<code>webpack-dev-server</code>命令，在<code>scripts</code>节点下新增<code>&quot;dev&quot;: &quot;webpack-dev-server&quot;</code>指令，发现可以进行实时打包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">  &quot;dev&quot;: &quot;webpack-dev-server&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行项目</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>但是dist目录下并没有生成<code>bundle.js</code>文件，这是因为<code>webpack-dev-server</code>将打包好的文件放在了内存中。把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Project is running at  [1m [34mhttp://localhost:8084/ [39m[22m</span><br><span class="line">webpack output is served from /</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此时我们可以通过http://localhost:8083/bundle.js 文件，因为webpack-dev-server默认是将bundle.js文件打包到根路径，所以要能做到修改main.js之后页面也要同步变化，需要修改页面的script标签：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;../bundle.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>指定启动参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了能在访问http://localhost:8080/的时候直接访问到index首页，可以使用--contentBase src指令来修改dev指令，指定启动的根目录：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">   &quot;dev&quot;: &quot;webpack-dev-server --open --port 3001 --contentBase src --hot&quot;</span><br><span class="line"> &#125;,</span><br><span class="line"> </span><br><span class="line"> //  --open含义：构建完成自动打开浏览器</span><br><span class="line"> //  --port 3001 : 指定运行的端口</span><br><span class="line"> //  --contentBase src   :  指定运行的根目录是src，即认为src就是项目根目录</span><br><span class="line"> //  --hot : 以补丁的方式修改文件，而不是修改全部文件</span><br></pre></td></tr></table></figure></li><li><p>解决webpack4.0之后打包大小警告和热更新慢的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">https://cloud.tencent.com/developer/section/1477466</span><br><span class="line"></span><br><span class="line">#main.js </span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //1.设置为开发模式，不然热更新会比较缓慢</span><br><span class="line">    mode:&quot;development&quot;,</span><br><span class="line">    entry: path.resolve(__dirname, &apos;src/main.js&apos;),</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">        filename: &apos;bundle.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    //2.打包文件大小警告和错误的问题</span><br><span class="line">    performance: &#123;</span><br><span class="line">        hints:false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-4webpack配置文件生成参数"><a href="#2-4webpack配置文件生成参数" class="headerlink" title="2.4webpack配置文件生成参数"></a>2.4webpack配置文件生成参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">// 启用热更新的 第2步</span><br><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: path.join(__dirname, &apos;./src/main.js&apos;),</span><br><span class="line">  output: &#123; </span><br><span class="line">    path: path.join(__dirname, &apos;./dist&apos;), </span><br><span class="line">    filename: &apos;bundle.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123; </span><br><span class="line">    // 这是配置 dev-server 命令参数的第二种形式，相对来说，这种方式麻烦一些</span><br><span class="line">    //  --open --port 3000 --contentBase src --hot</span><br><span class="line">    open: true, // 自动打开浏览器</span><br><span class="line">    port: 3000, // 设置启动时候的运行端口</span><br><span class="line">    contentBase: &apos;src&apos;, // 指定托管的根目录</span><br><span class="line">    hot: true // 启用热更新 的 第1步</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [ // 配置插件的节点</span><br><span class="line">    new webpack.HotModuleReplacementPlugin(), // new 一个热更新的 模块对象， 这是 启用热更新的第 3 步</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####2.5html-webpack-plugin插件配置启动页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://www.npmjs.com/package/html-webpack-plugin</span><br><span class="line"></span><br><span class="line">html-webpack-plugin插件可以**将指定页面配置生成到内存中**，并且可以**将打包的bundle.js配置到内存中生成的html页面中**，使用步骤如下：</span><br></pre></td></tr></table></figure><ol><li>运行<code>npm i html-webpack-plugin@3.2.0 --save-dev</code>安装到开发依赖</li><li>修改<code>webpack.config.js</code>配置文件如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">// 导入自动生成HTMl文件的插件</span><br><span class="line">var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: path.join(__dirname, &apos;./src/main.js&apos;),</span><br><span class="line">    output: &#123; </span><br><span class="line">        path: path.join(__dirname, &apos;./dist&apos;), </span><br><span class="line">        filename: &apos;bundle.js&apos; </span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [ </span><br><span class="line">        // 添加plugins节点配置插件</span><br><span class="line">        new htmlWebpackPlugin(&#123;</span><br><span class="line">            template:path.resolve(__dirname, &apos;src/index.html&apos;),//模板路径</span><br><span class="line">            filename:&apos;index.html&apos;//自动生成的HTML文件的名称</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>package.json<code>中</code>script`节点中的dev指令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server --open --port 3001 --contentBase src --hot&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>将index.html中script标签注释掉，因为<code>html-webpack-plugin</code>插件会自动把bundle.js注入到index.html页面中！</p></li></ol><h4 id="2-6使用webpack打包css文件"><a href="#2-6使用webpack打包css文件" class="headerlink" title="2.6使用webpack打包css文件"></a>2.6使用webpack打包css文件</h4><p>一般情况下，我们并不推荐在html页面中直接引入其他css文件，这样会导致过多的请求。对应的，我们可以使用webpack来构建。使用步骤如下：</p><ol><li>运行 <code>npm i style-loader css-loader --save-dev</code></li><li>main.js中引入index.css</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import "./css/index.css"</span><br></pre></td></tr></table></figure><ol start="3"><li>修改<code>webpack.config.js</code>这个配置文件：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来配置第三方loader模块的</span></span><br><span class="line"><span class="built_in">module</span>: &#123; </span><br><span class="line">    rules: [ </span><br><span class="line">        <span class="comment">// 匹配以.css结尾的文件</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] &#125;<span class="comment">//处理css文件的规则</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>webpack 处理第三方文件类型的过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 发现这个要处理的文件不是JS文件，然后就去配置文件中，查找有没有对应的第三方 loader 规则</span><br><span class="line">2. 如果能找到对应的规则， 就会调用对应的loader处理这种文件类型；</span><br><span class="line">3. 在调用loader的时候，use中相关loader模块的调用顺序是从后向前调用的；</span><br><span class="line">4. 当最后的一个loader调用完毕，会把处理的结果直接交给 webpack 进行打包合并，最终输出到  bundle.js 中去</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-7使用webpack打包less文件"><a href="#2-7使用webpack打包less文件" class="headerlink" title="2.7使用webpack打包less文件"></a>2.7使用webpack打包less文件</h4><ol><li>运行<code>npm i less-loader less</code>，需要同时安装less-loader和less</li><li>main.js中引入index.less</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import "./css/index.less"</span><br></pre></td></tr></table></figure><ol start="3"><li>修改<code>webpack.config.js</code>这个配置文件：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123; <span class="comment">// 用来配置第三方loader模块的</span></span><br><span class="line">    rules: [ <span class="comment">// 文件的匹配规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] &#125;,<span class="comment">//处理css文件的规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.less$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>] &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-8使用webpack打包sass文件"><a href="#2-8使用webpack打包sass文件" class="headerlink" title="2.8使用webpack打包sass文件"></a>2.8使用webpack打包sass文件</h4><ol><li>运行<code>npm i sass-loader@7.3.1 node-sass --save-dev</code></li><li>main.js中引入index.scss   </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：文件名是scss结尾</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"./css/index.scss"</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在<code>webpack.config.js</code>中添加处理scss文件的loader模块：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123; <span class="comment">// 用来配置第三方loader模块的</span></span><br><span class="line">    rules: [ <span class="comment">// 文件的匹配规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] &#125;,<span class="comment">//处理css文件的规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.less$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>] &#125;,</span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>] &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####2.9使用webpack处理css中的路径</p><ol><li>运行<code>npm i url-loader file-loader --save-dev</code></li><li>在<code>webpack.config.js</code>中添加处理url路径的loader模块：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123; <span class="comment">// 用来配置第三方loader模块的</span></span><br><span class="line">    rules: [ <span class="comment">// 文件的匹配规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] &#125;,<span class="comment">//处理css文件的规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.less$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>] &#125;,</span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>] &#125;,</span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif|bmp|jpeg)$/</span>, <span class="attr">use</span>: <span class="string">'url-loader'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol><li>index.css</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">450px</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../images/<span class="number">1</span>.jpg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意点：url-loader默认情况下会将图片转换为base64编码的图片，好处是可以减少图片的二次请求。但是这种方式一般情况下适用于小图，如果是大图，我们可以像下面这样去使用：</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123; <span class="comment">// 用来配置第三方loader模块的</span></span><br><span class="line">    rules: [ <span class="comment">// 文件的匹配规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] &#125;,<span class="comment">//处理css文件的规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.less$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>] &#125;,</span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>] &#125;,</span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif|bmp|jpeg)$/</span>,</span><br><span class="line">         use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            limit: <span class="number">8192</span>,</span><br><span class="line">                            name:<span class="string">'[hash:8]-[name].[ext]'</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//limit ： 当图片大小小于等于指定的值时会进行base64编码</span></span><br><span class="line"><span class="comment">//name =[name].[ext]： 不给图片重命名，还是使用原图名。如果没有这个属性，则默认会使用hashcode的方式来给图片重命名。</span></span><br><span class="line"><span class="comment">//给图片重命名的好处是：如果在多个不同的目录下有两张同名的图片(内容不同)，不会产生冲突。(默认情况下webpack会将图片也打包到根路径下)</span></span><br><span class="line"><span class="comment">//如果既想多个文件夹下的同名的图片被打包后不冲突，又想保留原来的图片名字，可以这样使用：name=[hash:8]-[name].[ext]  ，  [hash:8]表示保留8位hash值，然后再去追加原来的[name]</span></span><br></pre></td></tr></table></figure><h4 id="2-10使用webpack处理字体图标"><a href="#2-10使用webpack处理字体图标" class="headerlink" title="2.10使用webpack处理字体图标"></a>2.10使用webpack处理字体图标</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">module: &#123; // 用来配置第三方loader模块的</span><br><span class="line">    rules: [ // 文件的匹配规则</span><br><span class="line">        &#123; test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;,//处理css文件的规则</span><br><span class="line">        &#123; test: /\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125;,</span><br><span class="line">        &#123; test: /\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                test: /\.(png|jpg|gif|bmp|jpeg)$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &apos;url-loader&apos;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            limit: 8192,</span><br><span class="line">                            name:&apos;[hash:8]-[name].[ext]&apos;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;   test: /\.(ttf|eot|svg|woff|woff2)$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader:&apos;url-loader&apos;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;, // 处理 字体文件的 loader</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-11webpack中babel的配置"><a href="#2-11webpack中babel的配置" class="headerlink" title="2.11webpack中babel的配置"></a>2.11webpack中babel的配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 webpack 中，默认只能处理一部分 ES6 的新语法；这时候就需要借助于第三方的 loader，来帮助webpack 处理这些高级的语法，当第三方loader可以把高级语法转为低级的语法，然后再把结果交给 webpack 去打包到 bundle.js 中</span><br></pre></td></tr></table></figure><ol><li>运行<code>npm i babel-core@6.26.3 babel-loader@7.1.5 babel-plugin-transform-runtime --save-dev</code>安装babel的相关loader包 (babel的转换工具)</li><li>运行<code>npm i babel-preset-env babel-preset-stage-0 --save-dev</code>安装babel转换的语法 (es6的语法和es5的语法的对应关系)</li><li>在<code>webpack.config.js</code>中添加相关loader模块，其中需要注意的是，一定要把<code>node_modules</code>文件夹添加到排除项：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123; <span class="comment">// 用来配置第三方loader模块的</span></span><br><span class="line">    rules: [ <span class="comment">// 文件的匹配规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] &#125;,<span class="comment">//处理css文件的规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.less$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>] &#125;,</span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>] &#125;,</span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif|bmp|jpeg)$/</span>, <span class="attr">use</span>: <span class="string">'url-loader?limit=1024&amp;name=[hash:8]-[name].[ext]'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.(ttf|eot|svg|woff|woff2)$/</span>, <span class="attr">use</span>: <span class="string">'url-loader'</span> &#125;, <span class="comment">// 处理 字体文件的 loader</span></span><br><span class="line">        <span class="comment">//配置 babel 的 loader规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">use</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span> &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在项目根目录中添加<code>.babelrc</code>文件，并修改这个配置文件如下(这个文件必须符合json的语法，不能有注释。字符串必须使用双引号)：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"env"</span>, <span class="string">"stage-0"</span>],</span><br><span class="line">  <span class="string">"plugins"</span>: [<span class="string">"transform-runtime"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：之前用的比较多的语法插件<code>babel-preset-es2015</code>更新为<code>babel-preset-env</code>，它包含了所有的ES相关的语法；</strong></p><h4 id="1-3-11-所有配置总结"><a href="#1-3-11-所有配置总结" class="headerlink" title="1.3.11 所有配置总结"></a>1.3.11 所有配置总结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"># 1.安装</span><br><span class="line">npm i webpack@4.20.1 --save-dev                   //安装webpack</span><br><span class="line">npm init -y                                                       //项目初始化</span><br><span class="line">npm i webpack-dev-server@3.1.9 --save-dev      //实时打包构建</span><br><span class="line">npm i webpack-cli@3.1.2      </span><br><span class="line">npm i html-webpack-plugin@3.2.0 --save-dev      //配置内存页面</span><br><span class="line">npm i style-loader css-loader --save-dev               //css加载器</span><br><span class="line">npm i less-loader less                                             //less加载器</span><br><span class="line">npm i sass-loader@7.3.1 node-sass --save-dev               //sass加载器</span><br><span class="line">npm i url-loader file-loader --save-dev                 //url加载器</span><br><span class="line">npm i babel-core@6.26.3 babel-loader@7.1.5 babel-plugin-transform-runtime --save-dev    //babel转换工具</span><br><span class="line">npm i babel-preset-env babel-preset-stage-0 --save-dev           //babel转换的语法</span><br><span class="line"></span><br><span class="line">#2.webpack.config.js</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">// 导入自动生成HTMl文件的插件</span><br><span class="line">var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: path.join(__dirname, &apos;./src/main.js&apos;),</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, &apos;./dist&apos;),</span><br><span class="line">        filename: &apos;bundle.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        // 添加plugins节点配置插件</span><br><span class="line">        new htmlWebpackPlugin(&#123;</span><br><span class="line">            template:path.resolve(__dirname, &apos;src/index.html&apos;),//模板路径</span><br><span class="line">            filename:&apos;index.html&apos;//自动生成的HTML文件的名称</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    module: &#123; // 用来配置第三方loader模块的</span><br><span class="line">        rules: [ // 文件的匹配规则</span><br><span class="line">            &#123; test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;,//处理css文件的规则</span><br><span class="line">            &#123; test: /\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125;,</span><br><span class="line">            &#123; test: /\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125;,</span><br><span class="line">            &#123; test: /\.(png|jpg|gif|bmp|jpeg)$/, use: &apos;url-loader?limit=1024&amp;name=[hash:8]-[name].[ext]&apos; &#125;,</span><br><span class="line">            &#123; test: /\.(ttf|eot|svg|woff|woff2)$/, use: &apos;url-loader&apos; &#125;, // 处理 字体文件的 loader</span><br><span class="line">            //配置 babel 的 loader规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉</span><br><span class="line">            &#123; test: /\.js$/, use: &apos;babel-loader&apos;, exclude: /node_modules/ &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#3.项目入口文件</span><br><span class="line">import &quot;./css/index.css&quot;</span><br><span class="line"></span><br><span class="line">console.log(&quot;ok&quot;);</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    showInfo()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p = new Person(&quot;xiaoming&quot;,18);</span><br><span class="line">console.log(p.name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#4.package.json</span><br><span class="line"> &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server --open --port 3000 --contentBase src --hot&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">#5.项目根目录 .babelrc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;env&quot;, &quot;stage-0&quot;],</span><br><span class="line">  &quot;plugins&quot;: [&quot;transform-runtime&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      webpack
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>AJAX</title>
    <link href="http://yoursite.com/2019/02/22/AJAX/"/>
    <id>http://yoursite.com/2019/02/22/AJAX/</id>
    <published>2019-02-22T12:54:10.000Z</published>
    <updated>2020-01-27T12:25:28.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h2 id="1-什么是AJAX？"><a href="#1-什么是AJAX？" class="headerlink" title="1.什么是AJAX？"></a>1.什么是AJAX？</h2><p> Ajax（Asynchronous JavaScript and XML的缩写）是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。</p><p><strong>AJAX的好处</strong>：可以通过<code>js</code>代码发送get或者post的请求去从后台获取到相应数据，并只对页面中的部分标签进行刷新渲染，而不需要刷新整个页面，节约了带宽，优化了性能</p><h2 id="2-创建AJAX对象"><a href="#2-创建AJAX对象" class="headerlink" title="2.创建AJAX对象"></a>2.创建AJAX对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//兼容性写法  ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);是为了兼容IE5 IE6</span><br><span class="line">var ajax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</span><br></pre></td></tr></table></figure><h2 id="3-AJAX的方法"><a href="#3-AJAX的方法" class="headerlink" title="3.AJAX的方法"></a>3.AJAX的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//设置请求方式</span><br><span class="line">ajax.open(&quot;post&quot;,&quot;url&quot;,true);  //第三个参数如果为true，则是异步，反之同步</span><br><span class="line"></span><br><span class="line">//设置请求头格式（post请求时一定要加请求头，这是因为在传输过程中会出现转码的情况，可能导致乱码的情况）</span><br><span class="line">xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);</span><br><span class="line"></span><br><span class="line">//发送请求:get请求参数放在url后面，post请求参数send()方法里面</span><br><span class="line">ajax.send(&quot;数据&quot;); </span><br><span class="line"></span><br><span class="line">//监听ajax状态，当ajax的状态发生改变的时候执行</span><br><span class="line">ajax.onreadystatechange = function()&#123;</span><br><span class="line">    //响应完成，浏览器已经可以获取到服务器响应结果了</span><br><span class="line">    if(this.readyState == 4)&#123;  //这是AJAX的状态码 区别与http的状态码 状态码还有 1 2 3 其中3是数据正在传输时的状态，他不保证数据的完整性</span><br><span class="line">        //http响应的状态码</span><br><span class="line">        if(this.state == 200)&#123;  //还有302  301  404...</span><br><span class="line">            //获取响应内容</span><br><span class="line">            console.log(this.responseText); //用ajax.responseText获取服务器返回的数据</span><br><span class="line">            //responseText 获得字符串形式的响应数据。</span><br><span class="line">   //responseXML 获得XML 形式的响应数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-数据渲染的两种方式"><a href="#4-数据渲染的两种方式" class="headerlink" title="4.数据渲染的两种方式"></a>4.数据渲染的两种方式</h2><h3 id="4-1数据在服务器中渲染完毕，返回给客户端一个完整页面"><a href="#4-1数据在服务器中渲染完毕，返回给客户端一个完整页面" class="headerlink" title="4.1数据在服务器中渲染完毕，返回给客户端一个完整页面"></a>4.1数据在服务器中渲染完毕，返回给客户端一个完整页面</h3><ol><li>浏览器发送请求至服务器</li><li>服务器接收到请求的信息，根据请求找到相应的信息（如JSON数据），在读取相应的页面文件，并渲染成一个完整的页面，将这个页面返回给客户端</li><li>客户端接收到此页面，并显示 (此方式要在服务器端安装art-template express-art-template等第三方模板）</li></ol><h3 id="4-2服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示"><a href="#4-2服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示" class="headerlink" title="4.2服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示"></a>4.2服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示</h3><ol><li>客户端发送数据请求给服务器</li><li>服务器拿到请求，找到相应的数据（如JSON），直接将此数据返回给客户端</li><li>客户端拿到数据后，在客户端进行渲染，并显示。（此方式要用到前端渲染插件template-web.js）</li></ol><h2 id="5-XML"><a href="#5-XML" class="headerlink" title="5.XML"></a>5.XML</h2><p>XML extensible Markup Language 扩展的标记语言，XML的标签可以自定义<br>HTML Hyper Text Markup Lanaguage HTML的标签是由W3C规范的，大概一共200多个</p><p><strong>XML用途：</strong><br>1、 定义数据结构<br>2、 作为配置文件出现</p><p><strong>XML组成：</strong><br>1、 XML文档声明<br>2、 XML标签<br>3、 XML属性<br>4、 XML注释</p><p><strong>XML文档注意点：</strong><br>1）xml的标签必须成对出现如，为成对出现时的标签也必须要是自关闭标签 如<br>2）xml标签名称区分大小写。<br>3）xml标签一定要正确配对。<br>4）xml标签名中间不能使用空格<br>5）xml标签名不能以数字开头<br>6）注意： 在一个xml文档中，有且仅有一个根标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//使用xml设计一个通讯录</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;contact&gt;</span><br><span class="line">&lt;person id=&quot;100&quot;&gt;</span><br><span class="line"> &lt;name&gt;张三&lt;/name&gt;</span><br><span class="line"> &lt;age&gt;18&lt;/age&gt;</span><br><span class="line"> &lt;phone&gt;12345678&lt;/phone&gt;</span><br><span class="line"> &lt;email&gt;12453@qq.com&lt;/email&gt;</span><br><span class="line">&lt;/person&gt;</span><br><span class="line">&lt;person id=&quot;101&quot;&gt;</span><br><span class="line"> &lt;name&gt;李四&lt;/name&gt;</span><br><span class="line"> &lt;age&gt;20&lt;/age&gt;</span><br><span class="line"> &lt;phone&gt;22345678&lt;/phone&gt;</span><br><span class="line"> &lt;email&gt;34453@qq.com&lt;/email&gt;</span><br><span class="line">&lt;/person&gt;</span><br><span class="line">&lt;/contact&gt;</span><br></pre></td></tr></table></figure><p><strong>xml的使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//服务器代码</span><br><span class="line">//返回XML格式的数据</span><br><span class="line">app.get(&quot;/getXML&quot;,(req,res)=&gt;&#123;</span><br><span class="line">//设置响应头，指定返回的数据是XML</span><br><span class="line">res.header(&quot;content-type&quot;,&quot;application/xml&quot;);</span><br><span class="line"></span><br><span class="line">var xml =  &apos;&lt;?xml version=&quot;1.1&quot; encoding=&quot;utf-8&quot;?&gt;&apos;;//XML文档声明</span><br><span class="line">xml += &apos;&lt;person&gt;&apos;;</span><br><span class="line">xml += &apos;&lt;name&gt;羊杨&lt;/name&gt;&apos;;</span><br><span class="line">xml += &apos;&lt;age&gt;16&lt;/age&gt;&apos;;</span><br><span class="line">xml += &apos;&lt;gender&gt;男&lt;/gender&gt;&apos;;</span><br><span class="line">xml += &apos;&lt;/person&gt;&apos;;</span><br><span class="line"></span><br><span class="line">res.send(xml);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//客户端代码</span><br><span class="line">ajax.onreadystatechange = function()&#123;</span><br><span class="line">if(this.readyState == 4)&#123;</span><br><span class="line">//获取响应的XML数据</span><br><span class="line">var xml = this.responseXML.documentElement;//ajax.responseXML.documentElement拿到文档数据</span><br><span class="line">var age = xml.querySelector(&quot;age&quot;);//用标签选择器获取到age数据  但此时age是&lt;age&gt;16&lt;/age&gt;</span><br><span class="line">console.log(age.innerHTML);//此处用innerText拿不到数据</span><br><span class="line">console.log(xml.children);//xml的语法几乎与html语法类似</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSON</p><p>json数据的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//服务器代码</span><br><span class="line">//返回JSON格式的数据</span><br><span class="line">app.get(&quot;/getJSON&quot;,(req,res)=&gt;&#123;</span><br><span class="line">//数组</span><br><span class="line">let arr = [</span><br><span class="line">&#123;</span><br><span class="line">name:&quot;zhangsan&quot;,</span><br><span class="line">age:&quot;18&quot;,</span><br><span class="line">gender:&quot;男&quot;,</span><br><span class="line">id:001</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name:&quot;lisi&quot;,</span><br><span class="line">age:&quot;28&quot;,</span><br><span class="line">gender:&quot;男&quot;,</span><br><span class="line">id:002</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">//将数组转换为JSON数据</span><br><span class="line">res.status(200).send(JSON.stringify(arr));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//客户端代码</span><br><span class="line">ajax.onreadystatechange = function()&#123;</span><br><span class="line">if(this.readyState == 4)&#123;</span><br><span class="line">console.log(this.responseText); //这是JSON字符串，在使用的时候往往需要转换为对象</span><br><span class="line">var students = JSON.parse(this.responseText);</span><br><span class="line">var html = template(&quot;generatorTable&quot;,&#123;students:students&#125;);</span><br><span class="line">container.innerHTML = html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-jQuery中的AJAX"><a href="#6-jQuery中的AJAX" class="headerlink" title="6.jQuery中的AJAX"></a>6.jQuery中的AJAX</h2><p>推荐使用 方便的一批</p><h3 id="6-1使用"><a href="#6-1使用" class="headerlink" title="6.1使用"></a>6.1使用</h3><p>客户端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    //请求方式</span><br><span class="line">    type:&quot;get&quot;, //post</span><br><span class="line">    </span><br><span class="line">    //请求路径</span><br><span class="line">    url:&quot;&quot;, //如http://localhost:3000/index</span><br><span class="line">    </span><br><span class="line">    //请求参数，无论是get还是post请求，请求参数都可以写在这里</span><br><span class="line">    //注意：请求为get时  在服务器得到请求参数时 仍然使用res.query</span><br><span class="line">    //这里的data数据必须为字符串 若要传入json数据 需要将json数据转换为字符串如 JSON.stringify(&#123;[&#123;&#125;,&#123;&#125;]&#125;)</span><br><span class="line">    data:&#123;name:&quot;zhangsan&quot;&#125;,</span><br><span class="line">    </span><br><span class="line">    //规定所要请求的数据的类型</span><br><span class="line">    dataType: &apos;&apos;,</span><br><span class="line">    </span><br><span class="line">    //在jQuery中如果请求已经是post，默认的contentType就是application/x-www-form-urlencoded,不需要单独再去写</span><br><span class="line">    //contentType: &quot;application/x-www-form-urlencoded&quot;,</span><br><span class="line">    //请求成功的回调</span><br><span class="line">    success:function(res)&#123;</span><br><span class="line">        console.log(res);//res是请求的到的数据</span><br><span class="line">    &#125;</span><br><span class="line">    //请求出错的回调 推荐写</span><br><span class="line">    error:function(err)&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">//无论请求的成功与否，只要请求结束都会执行此函数</span><br><span class="line">complete:function(xhr)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>服务器代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">let express = require(&quot;express&quot;);</span><br><span class="line">let app = express();</span><br><span class="line">const bodyParser = require(&apos;body-parser&apos;);</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended:false&#125;));</span><br><span class="line">//注意 当客户端中的data:JSON.stringify([&#123;name:&apos;zhangsan&apos;&#125;,&#123;name:&apos;lisi&apos;&#125;])时，服务器需要此配置</span><br><span class="line">//以解析body中的json数据</span><br><span class="line">app.use(bodyParser.json(&#123;extended:false&#125;));</span><br><span class="line"></span><br><span class="line">app.use(express.static(&quot;./views&quot;));</span><br><span class="line"></span><br><span class="line">//当ajax的url为&apos;/getJSON&apos;时 此接口响应 返回JSON格式的数据</span><br><span class="line">//此时ajax的dataType要设置为&apos;json&apos;</span><br><span class="line">app.get(&quot;/getJSON&quot;,(req,res)=&gt;&#123;</span><br><span class="line">    //数组</span><br><span class="line">    let arr = [</span><br><span class="line">        &#123;</span><br><span class="line">            name:&quot;zhangsan&quot;,</span><br><span class="line">            age:&quot;18&quot;,</span><br><span class="line">            gender:&quot;男&quot;,</span><br><span class="line">            id:001</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name:&quot;lisi&quot;,</span><br><span class="line">            age:&quot;28&quot;,</span><br><span class="line">            gender:&quot;男&quot;,</span><br><span class="line">            id:002</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    arr.forEach((user,idx)=&#123;</span><br><span class="line">        if(user.name == req.body.name)&#123;</span><br><span class="line">            res.status(200).send(JSON.stringify(user));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//当ajax的url为&apos;/getXML&apos;时 此接口响应 返回XML格式的数据</span><br><span class="line">//此时ajax的dataType要设置为&apos;xml&apos;</span><br><span class="line">app.get(&quot;/getXML&quot;,(req,res)=&gt;&#123;</span><br><span class="line">    //设置响应头，指定返回的数据是XML</span><br><span class="line">    res.header(&quot;content-type&quot;,&quot;application/xml&quot;);</span><br><span class="line"></span><br><span class="line">    var xml =  &apos;&lt;?xml version=&quot;1.1&quot; encoding=&quot;utf-8&quot;?&gt;&apos;;</span><br><span class="line">    xml += &apos;&lt;person&gt;&apos;;</span><br><span class="line">    xml += &apos;&lt;name&gt;zhangsan&lt;/name&gt;&apos;;</span><br><span class="line">    xml += &apos;&lt;age&gt;16&lt;/age&gt;&apos;;</span><br><span class="line">    xml += &apos;&lt;gender&gt;男&lt;/gender&gt;&apos;;</span><br><span class="line">    xml += &apos;&lt;/person&gt;&apos;;</span><br><span class="line"></span><br><span class="line">    res.send(xml);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>发送也接受html或script数据</p><p>服务器代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const app = express();</span><br><span class="line">const bodyParser = require(&apos;body-parser&apos;);</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended:false&#125;));</span><br><span class="line"></span><br><span class="line">app.use(express.static(&apos;views&apos;));</span><br><span class="line"></span><br><span class="line">app.get(&apos;/getScript&apos;,(req,res)=&gt;&#123;</span><br><span class="line">    res.header(&apos;content-type&apos;,&apos;application/javascript;charset=utf-8&apos;);</span><br><span class="line">    res.send(&apos;alert(123);&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(&apos;/getHtml&apos;,(req,res)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    res.header(&apos;content-type&apos;,&apos;text/html;charset=utf-8&apos;)</span><br><span class="line">    res.send(&apos;&lt;h1&gt;HTML&lt;/h1&gt;&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000,()=&gt;&#123;</span><br><span class="line">    console.log(&apos;running...&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#btn1&apos;).click(function()&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: &apos;get&apos;,</span><br><span class="line">        url: &apos;/getHtml&apos;,</span><br><span class="line">        data: &apos;&apos;,</span><br><span class="line">        dataType: &apos;html&apos;,</span><br><span class="line">        success:function(res)&#123;</span><br><span class="line">            //因为dataType为html  jQuery。AJAX会自动设置响应头为text/html  则 可以直接追加res到页面中</span><br><span class="line">            $(&apos;#info&apos;).append(res);</span><br><span class="line">        &#125;,</span><br><span class="line">        error:function(err)&#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(&apos;#btn2&apos;).click(function()&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: &apos;get&apos;,</span><br><span class="line">        url: &apos;/getScript&apos;,</span><br><span class="line">        data: &apos;&apos;,</span><br><span class="line">        dataType: &apos;script&apos;,</span><br><span class="line">        success:function(res)&#123;</span><br><span class="line">            //之所以alert()能执行  是因为将script代码打印到控制台  控制台会执行script代码</span><br><span class="line">            //也可以用script标签的对res进行封装 追加到页面中 也可以执行</span><br><span class="line">            console.log(res);</span><br><span class="line">        &#125;,</span><br><span class="line">        error:function(err)&#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="6-2dataType"><a href="#6-2dataType" class="headerlink" title="6.2dataType"></a>6.2dataType</h3><p><strong>dataType取值有xml、html、json、jsonp、script或者text</strong></p><p>当dataType取值为<strong>json</strong>，会自动将服务器返回的文本数据通过JSON.parse()转换成对象。<br>服务器应该设置这个响应头：<strong>res.header(“content-type”, “application/json;charset=utf-8”);</strong></p><p>当dataType为<strong>xml或者text</strong>的时候，返回的数据不会另做处理<br>服务器应该设置这个响应头：<strong>res.header(“content-type”,”application/xml”);</strong><br><strong>res.header(“content-type”,”text/plain;charset=utf-8”);</strong></p><p>当dataType为<strong>html</strong>的时候，返回的内容中的script标签会在网页内容被拼接到页面的时候执行<br>服务器应该设置这个响应头：<strong>res.header(“content-type”,”text/html;charset=utf-8”);</strong></p><p>当dataType为<strong>script</strong>的时候，会将服务器返回的结果当成js代码执行并且将js代码的文本内容返回给客户端<br>服务器应该设置这个响应头：<strong>res.header(“content-type”,”application/javascript”);</strong></p><p>当dataType为<strong>jsonp</strong>的时候，会向服务器发送一个jsonp请求<br>服务器应该设置这个响应头：<strong>res.header(“content-type”,”application/javascript”);</strong></p><h2 id="6-3nprogress的使用（全局事件处理）"><a href="#6-3nprogress的使用（全局事件处理）" class="headerlink" title="6.3nprogress的使用（全局事件处理）"></a>6.3nprogress的使用（全局事件处理）</h2><p>1、在html文件中引入nprogress.js 和 nprogress.css</p><p>2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(document).ajaxStart(function()&#123;//请求数据开始</span><br><span class="line">    NProgress.start();//数据加载动画</span><br><span class="line">&#125;).ajaxStop(function()&#123;//请求数据结束</span><br><span class="line">    NProgress.done();//数据加载完毕动画</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="7-跨域请求"><a href="#7-跨域请求" class="headerlink" title="7.跨域请求"></a>7.跨域请求</h2><p><strong>同源策略</strong>是浏览器的一种安全策略，所谓同源是指 <strong>域名，协议，端口完全相同</strong> ，只有同源的地址才可以相互通过AJAX的方式请求。</p><p>同源或者不同源说的是两个地址之间的关系，不同源地址之间请求我们称之为<strong>跨域请求</strong></p><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8000  是不可以通过ajax访问  http://locally.uieee.com/categories的</span><br><span class="line">因为两者不满足同源的条件</span><br></pre></td></tr></table></figure><h3 id="7-1如何进行跨域请求"><a href="#7-1如何进行跨域请求" class="headerlink" title="7.1如何进行跨域请求"></a>7.1如何进行跨域请求</h3><ol><li>CORS</li><li>JSONP</li><li>代理服务器</li><li>修改document.domain</li><li>Iframe</li><li>Location.hash</li><li>Window.postMessage()</li><li>Websocket</li></ol><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>只需要改动服务器，不用改动客户端代码，客户端可以直接使用$.ajax()</p><p>Cross Origin Resource Share，跨域资源共享。这种方案无需客户端作出任何变化（客户端不用改代码），只是在被请求的服务端响应的时候添加一个Access- Control-Allow-Origin 的响应头，表示这个资源是否允许指定域请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//直接在服务器配置如下,客户端代码和以前一样写</span><br><span class="line">app.all(&apos;*&apos;, function(req, res, next) &#123;</span><br><span class="line">    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">    res.header(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-type&apos;);</span><br><span class="line">    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS,PATCH&quot;);</span><br><span class="line">    res.header(&apos;Access-Control-Max-Age&apos;,6000);//预请求缓存10分钟</span><br><span class="line">    next();  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSON with Padding 实质上是通过script的src属性进行数据请求。本质上不是AJAX请求</p><p>需要服务器和客户端配合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//此时客户端的地址为http://localhost:3000</span><br><span class="line">实现要点</span><br><span class="line">//客户端代码</span><br><span class="line">var script = document.createElement(&apos;script&apos;);</span><br><span class="line">script.src = &apos;http://localhost:9999/testJSONP&apos;;//向http://localhost:9999发送跨域请求</span><br><span class="line">document.body.appendChild(script)</span><br><span class="line"></span><br><span class="line">//服务器代码</span><br><span class="line">app.get(&quot;/testJSONP&quot;,(req,res)=&gt;&#123;</span><br><span class="line">//设置响应头 服务器给客户端发送了一个js代码块</span><br><span class="line">res.header(&quot;content-type&quot;,&quot;application/javascript&quot;);</span><br><span class="line">let data = JSON.stringify(&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;) ;</span><br><span class="line">//服务器发送 `foo(&apos;&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;&apos;)` 这个字符串给客户端</span><br><span class="line">res.send(`foo($&#123;data&#125;)`);</span><br><span class="line">&#125;)</span><br><span class="line">//如果服务器给客户端返回的js代码块中有函数调用，必须提前在客户端中声明要调用的那个函数</span><br><span class="line">function foo(data)&#123;</span><br><span class="line">console.log(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>jQuery代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//客户端代码</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    type:&quot;get&quot;,</span><br><span class="line">    url:&quot;http://localhost:9999/testJSONP&quot;,</span><br><span class="line">    data:&apos;&apos;,</span><br><span class="line">    dataType: &apos;jsonp&apos;,</span><br><span class="line">    success:function(res)&#123;</span><br><span class="line">        $(&apos;body&apos;).append(res);</span><br><span class="line">    &#125;</span><br><span class="line">    error:function(err)&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">complete:function(xhr)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function foo(data)&#123;</span><br><span class="line">console.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//服务器http://localhost:3000代码</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const app = express();</span><br><span class="line">const bodyParser = require(&apos;body-parser&apos;);</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended:false&#125;));</span><br><span class="line"></span><br><span class="line">app.use(express.static(&apos;views&apos;));</span><br><span class="line"></span><br><span class="line">app.listen(3000,()=&gt;&#123;</span><br><span class="line">    console.log(&apos;running...&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//服务器http://localhost:8888代码</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const app = express();</span><br><span class="line">const bodyParser = require(&apos;body-parser&apos;);</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended:false&#125;));</span><br><span class="line"></span><br><span class="line">app.get(&apos;/getJsonp&apos;,(req,res)=&gt;&#123;</span><br><span class="line">    res.send(&apos;foo(&quot;你拿到了http://localhost:8888的jsonp&quot;);&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(8888,()=&gt;&#123;</span><br><span class="line">    console.log(&apos;running...&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="8-结束语"><a href="#8-结束语" class="headerlink" title="8.结束语"></a>8.结束语</h2><p>AJAX是通过<code>XMLHttpRequest</code>或者封装后的框架进行网络请求，由于这种方式的配置和调用方式非常混乱，已被Fetch取代</p>]]></content>
    
    <summary type="html">
    
      AJAX
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="AJAX" scheme="http://yoursite.com/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>JS基础知识</title>
    <link href="http://yoursite.com/2019/02/05/js%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/02/05/js基本知识/</id>
    <published>2019-02-05T13:25:25.000Z</published>
    <updated>2020-01-26T13:42:33.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS基础知识"><a href="#JS基础知识" class="headerlink" title="JS基础知识"></a>JS基础知识</h2><h3 id="1-JavaScript-是什么？"><a href="#1-JavaScript-是什么？" class="headerlink" title="1.JavaScript 是什么？"></a>1.JavaScript 是什么？</h3><ul><li>JavaScript 是一种轻量级的编程语言。</li><li>JavaScript 是可插入 HTML 页面的编程代码。</li><li>JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。</li></ul><h3 id="2-js的基本数据类型"><a href="#2-js的基本数据类型" class="headerlink" title="2.js的基本数据类型"></a>2.js的基本数据类型</h3><ol><li>Number</li><li>String</li><li>null</li><li>undefined</li><li>Boolean</li></ol><p>复杂的数据类型：Array  Function  Object</p><h3 id="3-typeof的类型"><a href="#3-typeof的类型" class="headerlink" title="3.typeof的类型"></a>3.typeof的类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typeof &quot;John&quot;                 // 返回 string </span><br><span class="line">typeof 3.14                   // 返回 number</span><br><span class="line">typeof NaN                    // 返回 number</span><br><span class="line">typeof false                  // 返回 boolean</span><br><span class="line">typeof [1,2,3,4]              // 返回 object</span><br><span class="line">typeof &#123;name:&apos;John&apos;, age:34&#125;  // 返回 object</span><br><span class="line">typeof new Date()             // 返回 object</span><br><span class="line">typeof function () &#123;&#125;         // 返回 function</span><br><span class="line">typeof myCar                  // 返回 undefined (如果 myCar 没有声明)</span><br><span class="line">typeof null                   // 返回 object</span><br></pre></td></tr></table></figure><p><code>typeof只能区分值类型，对引用类型无能为力，只能区分函数function</code><br><code>NaN</code>表示特殊的非数字值，<code>null</code>是空指针，并没有指向任何一个地址<br><code>typeof</code>能区分的五种基本类型：<code>string</code>、<code>boolean</code>、<code>number</code>、<code>undefined</code>、<code>symbol</code>和函数<code>function</code></p><h3 id="4-判断一个变量是否为数组"><a href="#4-判断一个变量是否为数组" class="headerlink" title="4.判断一个变量是否为数组"></a>4.判断一个变量是否为数组</h3><ol><li><p>instanceof 判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4];</span><br><span class="line">console.log(arr instanceof Array)//true;</span><br></pre></td></tr></table></figure></li><li><p>原型链方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,23,4];</span><br><span class="line">console.log(arr.__proto__.constructor==Array);//true</span><br><span class="line">console.log(arr.constructor==Array)//true 这两段代码是一样的</span><br></pre></td></tr></table></figure></li><li><p>Object.prototype.toString 的用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function isArray(o)&#123;</span><br><span class="line">return Object.prototype.toString.call(o)==&apos;[object Array]&apos;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(isArray(ary));</span><br></pre></td></tr></table></figure></li><li><p>Array.isArray()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray([1, 2, 3]);  </span><br><span class="line">// true</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-use-strict严格模式"><a href="#5-use-strict严格模式" class="headerlink" title="5.use strict严格模式"></a>5.use strict严格模式</h3><p><code>&quot;use strict&quot;</code> 是 <strong>ES5</strong> 特性，它使我们的代码在函数或整个脚本中处于<strong>严格模式</strong>。<strong>严格模式</strong>帮助我们在代码的早期避免 bug，并为其添加限制。</p><p><strong>严格模式</strong>的一些限制：</p><ol><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用<code>with</code>语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀 0 表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li><li><code>eval</code>不能在它的外层作用域引入变量</li><li><code>eval</code>和<code>arguments</code>不能被重新赋值</li><li><code>arguments</code>不会自动反映函数参数的变化</li><li>不能使用<code>arguments.callee</code></li><li>不能使用<code>arguments.caller</code></li><li>禁止<code>this</code>指向全局对象</li><li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li><li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li></ol><p>设立”严格模式”的目的，主要有以下几个：</p><ol><li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的Javascript做好铺垫。</li></ol><h3 id="6-JS数组方法"><a href="#6-JS数组方法" class="headerlink" title="6.JS数组方法"></a>6.JS数组方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Array.concat( ) 连接数组</span><br><span class="line">Array.join( ) 将数组元素连接起来以构建一个字符串</span><br><span class="line">Array.length 数组的大小</span><br><span class="line">Array.pop( ) 删除并返回数组的最后一个元素</span><br><span class="line">Array.push( ) 给数组添加元素</span><br><span class="line">Array.reverse( ) 颠倒数组中元素的顺序</span><br><span class="line">Array.shift( ) 将元素移出数组</span><br><span class="line">Array.slice( ) 返回数组的一部分</span><br><span class="line">Array.sort( ) 对数组元素进行排序</span><br><span class="line">Array.splice( ) 插入、删除或替换数组的元素</span><br><span class="line">Array.toLocaleString( ) 把数组转换成局部字符串</span><br><span class="line">Array.toString( ) 将数组转换成一个字符串</span><br><span class="line">Array.unshift( ) 在数组头部插入一个元素</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      js基本知识
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/23/Tomcat%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/01/23/Tomcat安装和使用/</id>
    <published>2019-01-23T12:16:30.000Z</published>
    <updated>2020-01-26T08:39:32.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tomcat安装和使用"><a href="#Tomcat安装和使用" class="headerlink" title="Tomcat安装和使用"></a>Tomcat安装和使用</h2><p>安装JDK步骤及配置JDK环境变量步骤省略。</p><h3 id="一下载安装。"><a href="#一下载安装。" class="headerlink" title="一下载安装。"></a>一下载安装。</h3><h4 id="1-官网下载"><a href="#1-官网下载" class="headerlink" title="1.官网下载"></a>1.官网下载</h4><p><img src="https://s2.ax1x.com/2020/01/24/1ZcTtx.png" alt></p><h4 id="2-文件减压"><a href="#2-文件减压" class="headerlink" title="2.文件减压"></a>2.文件减压</h4><p><img src="https://s2.ax1x.com/2020/01/24/1ZgXGV.png" alt></p><h3 id="二使用Tomcat"><a href="#二使用Tomcat" class="headerlink" title="二使用Tomcat"></a>二使用Tomcat</h3><ol><li><p>先解压下载的压缩包、然后在bin目录下找到startup.bat文件、并用鼠标双击此文件</p></li><li><p>然后在浏览器中输入<code>http://localhost:8080</code>回车后，显示如下界面：此时就说明Tomcat服务启动正常了。</p><p><img src="https://s2.ax1x.com/2020/01/26/1mslTI.jpg" alt></p><p>​</p></li><li><p>将打包后的文件放入<code>webapps</code>目录下在此启动Tomcat访问8080端口即可。</p></li></ol>]]></content>
    
    <summary type="html">
    
      Tomcat
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>CSS3动画</title>
    <link href="http://yoursite.com/2019/01/03/CSS3%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/01/03/CSS3动画/</id>
    <published>2019-01-03T12:55:30.000Z</published>
    <updated>2020-01-24T12:18:00.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS3动画"><a href="#CSS3动画" class="headerlink" title="CSS3动画"></a>CSS3动画</h2><p>通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。</p><p>###1.CSS3的@keyframes 规则</p><p>@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。</p><p>@keyframes 中创建动画时，请把它捆绑到某个选择器，否则不会产生动画效果。通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器：</p><ul><li>规定动画的名称</li><li>规定动画的时长</li></ul><h3 id="2-CSS3-中动画的使用"><a href="#2-CSS3-中动画的使用" class="headerlink" title="2.CSS3 中动画的使用"></a>2.CSS3 中动画的使用</h3><p>动画是使元素从一种样式逐渐变化为另一种样式的效果。</p><p>您可以改变任意多的样式任意多的次数。</p><p>请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。</p><p>0% 是动画的开始，100% 是动画的完成。</p><p>为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。</p><p>动画是使元素从一种样式逐渐变化为另一种样式的效果。</p><p>您可以改变任意多的样式任意多的次数。</p><p>请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。</p><p>0% 是动画的开始，100% 是动画的完成。</p><p>为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;style&gt; </span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">width:100px;</span><br><span class="line">height:100px;</span><br><span class="line">background:red;</span><br><span class="line">animation:myfirst 5s;</span><br><span class="line">-moz-animation:myfirst 5s; /* Firefox */</span><br><span class="line">-webkit-animation:myfirst 5s; /* Safari and Chrome */</span><br><span class="line">-o-animation:myfirst 5s; /* Opera */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes myfirst</span><br><span class="line">&#123;</span><br><span class="line">from &#123;background:red;&#125;</span><br><span class="line">to &#123;background:yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes myfirst /* Firefox */</span><br><span class="line">&#123;</span><br><span class="line">from &#123;background:red;&#125;</span><br><span class="line">to &#123;background:yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes myfirst /* Safari and Chrome */</span><br><span class="line">&#123;</span><br><span class="line">from &#123;background:red;&#125;</span><br><span class="line">to &#123;background:yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-o-keyframes myfirst /* Opera */</span><br><span class="line">&#123;</span><br><span class="line">from &#123;background:red;&#125;</span><br><span class="line">to &#123;background:yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;本例在 Internet Explorer 中无效。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="3-CSS3-动画属性"><a href="#3-CSS3-动画属性" class="headerlink" title="3.CSS3 动画属性"></a>3.CSS3 动画属性</h3><ul><li><p>animation (所有动画属性的简写属性，除了 animation-play-state 属性)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">animation: name duration timing-function delay iteration-count direction;</span><br><span class="line">animation: demo 3s liner 0.2 iteration-count direction;</span><br></pre></td></tr></table></figure></li><li><p>animation-name(为 @keyframes 动画指定名称)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation-name: keyframename|none;</span><br></pre></td></tr></table></figure></li><li><p>animation-duration(定义动画完成一个周期需要多少秒或毫秒)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation-duration: time;</span><br></pre></td></tr></table></figure></li><li><p>animation-timing-function(指定动画将如何完成一个周期）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">animation-timing-function: value;</span><br><span class="line"></span><br><span class="line">linear动画从头到尾的速度是相同的。</span><br><span class="line">ease默认。动画以低速开始，然后加快，在结束前变慢。</span><br><span class="line">ease-in动画以低速开始。</span><br><span class="line">ease-out动画以低速结束。</span><br><span class="line">ease-in-out动画以低速开始和结束。</span><br><span class="line">cubic-bezier(n,n,n,n)在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。</span><br></pre></td></tr></table></figure></li><li><p>animation-delay (定义动画什么时候开始)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation-delay: time;</span><br></pre></td></tr></table></figure></li><li><p>animation-iteration-count(定义动画应该播放多少次)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animation-iteration-count: value;</span><br><span class="line"></span><br><span class="line">n一个数字，定义应该播放多少次动画</span><br><span class="line">infinite指定动画应该播放无限次（永远）</span><br></pre></td></tr></table></figure></li><li><p>animation-direction (定义是否循环交替反向播放动画)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">animation-direction: normal|reverse|alternate|alternate-reverse|initial|inherit;</span><br><span class="line"></span><br><span class="line">normal默认值。动画按正常播放。</span><br><span class="line">reverse动画反向播放。</span><br><span class="line">alternate动画在奇数次（1、3、5...）正向播放，在偶数次（2、4、6...）反向播放。</span><br><span class="line">alternate-reverse 动画在奇数次（1、3、5...）反向播放，在偶数次（2、4、6...）正向播放。</span><br><span class="line">initial设置该属性为它的默认值。</span><br><span class="line">inherit从父元素继承该属性。</span><br></pre></td></tr></table></figure></li><li><p>animation–play-state(指定动画是否正在运行或已暂停)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animation-play-state: paused|running;</span><br><span class="line"></span><br><span class="line">paused指定暂停动画</span><br><span class="line">running指定正在运行的动画</span><br></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      CSS3动画
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="css3" scheme="http://yoursite.com/tags/css3/"/>
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>前端兼容性问题小结</title>
    <link href="http://yoursite.com/2018/12/21/%E5%89%8D%E7%AB%AF%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2018/12/21/前端兼容性问题小结/</id>
    <published>2018-12-21T12:45:30.000Z</published>
    <updated>2020-01-24T12:18:06.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端兼容性问题小结"><a href="#前端兼容性问题小结" class="headerlink" title="前端兼容性问题小结"></a>前端兼容性问题小结</h2><h3 id="1-不同浏览器的标签默认的外补丁和内补丁不同"><a href="#1-不同浏览器的标签默认的外补丁和内补丁不同" class="headerlink" title="1.不同浏览器的标签默认的外补丁和内补丁不同"></a>1.不同浏览器的标签默认的外补丁和内补丁不同</h3><p>问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。</p><p>碰到频率:100%</p><p>解决方案：CSS里    *{margin:0;padding:0;}，或使用第三方css文件重置。</p><p>备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。</p><h3 id="2-图片默认有间距"><a href="#2-图片默认有间距" class="headerlink" title="2.图片默认有间距"></a>2.图片默认有间距</h3><p>问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。</p><p>碰到几率：20%</p><p>解决方案：使用float属性为img布局</p><p>备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（我的一个学生使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以我禁止他们使用）</p><p>###3.IE9一下浏览器不能使用opacity</p><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">opacity: 0.5;</span><br><span class="line">filter:alpha(opacity = 50);</span><br><span class="line">filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50);</span><br></pre></td></tr></table></figure><h3 id="4-IE6-背景闪烁的问题"><a href="#4-IE6-背景闪烁的问题" class="headerlink" title="4.IE6 背景闪烁的问题"></a>4.IE6 背景闪烁的问题</h3><p>问题：链接、按钮用 <code>CSSsprites</code> 作为背景，在 <code>ie6</code> 下会有背景图闪烁的现象。原因是 <code>IE6</code> 没有将背景图缓存，每次触发 <code>hover</code> 的时候都会重新加载</p><p>解决：可以用 <code>JavaScript</code> 设置 <code>ie6</code> 缓存这些图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.execCommand(&quot;BackgroundImageCache&quot;, false, true);</span><br></pre></td></tr></table></figure><h3 id="5-键盘事件-keyCode-兼容性写法"><a href="#5-键盘事件-keyCode-兼容性写法" class="headerlink" title="5.键盘事件 keyCode 兼容性写法"></a>5.键盘事件 <code>keyCode</code> 兼容性写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var inp = document.getElementById(&apos;inp&apos;)</span><br><span class="line">var result = document.getElementById(&apos;result&apos;)</span><br><span class="line"></span><br><span class="line">function getKeyCode(e) &#123;</span><br><span class="line">  e = e ? e : (window.event ? window.event : &quot;&quot;)</span><br><span class="line">  return e.keyCode ? e.keyCode : e.which</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inp.onkeypress = function(e) &#123;</span><br><span class="line">  result.innerHTML = getKeyCode(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-DOM-事件处理程序的兼容写法"><a href="#6-DOM-事件处理程序的兼容写法" class="headerlink" title="6.DOM 事件处理程序的兼容写法"></a>6.DOM 事件处理程序的兼容写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">var eventshiv = &#123;</span><br><span class="line">    // event兼容</span><br><span class="line">    getEvent: function(event) &#123;</span><br><span class="line">        return event ? event : window.event;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">// &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;兼容</span><br><span class="line">getType: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(event) &#123;</span><br><span class="line">    &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; event.type;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// target兼容</span><br><span class="line">getTarget: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(event) &#123;</span><br><span class="line">    &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; event.target ? event.target : event.srcelem;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 添加事件句柄</span><br><span class="line">addHandler: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(elem, &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener) &#123;</span><br><span class="line">    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (elem.addEventListener) &#123;</span><br><span class="line">        elem.addEventListener(&lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);</span><br><span class="line">    &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (elem.attachEvent) &#123;</span><br><span class="line">        elem.attachEvent(&lt;span class=&quot;hljs-string&quot;&gt;&apos;on&apos;&lt;/span&gt; + &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener);</span><br><span class="line">    &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &#123;</span><br><span class="line">        // 在这里由于.与&lt;span class=&quot;hljs-string&quot;&gt;&apos;on&apos;&lt;/span&gt;字符串不能链接，只能用 []</span><br><span class="line">        elem[&lt;span class=&quot;hljs-string&quot;&gt;&apos;on&apos;&lt;/span&gt; + &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;] = listener;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 移除事件句柄</span><br><span class="line">removeHandler: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(elem, &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener) &#123;</span><br><span class="line">    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (elem.removeEventListener) &#123;</span><br><span class="line">        elem.removeEventListener(&lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);</span><br><span class="line">    &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (elem.detachEvent) &#123;</span><br><span class="line">        elem.detachEvent(&lt;span class=&quot;hljs-string&quot;&gt;&apos;on&apos;&lt;/span&gt; + &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener);</span><br><span class="line">    &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &#123;</span><br><span class="line">        elem[&lt;span class=&quot;hljs-string&quot;&gt;&apos;on&apos;&lt;/span&gt; + &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;] = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 添加事件代理</span><br><span class="line">addAgent: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (elem, &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, agent, listener) &#123;</span><br><span class="line">    elem.addEventListener(&lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (e) &#123;</span><br><span class="line">        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (e.target.matches(agent)) &#123;</span><br><span class="line">            listener.call(e.target, e); // this 指向 e.target</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 取消默认行为</span><br><span class="line">preventDefault: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(event) &#123;</span><br><span class="line">    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (event.preventDefault) &#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &#123;</span><br><span class="line">        event.returnValue = &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 阻止事件冒泡</span><br><span class="line">stopPropagation: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(event) &#123;</span><br><span class="line">    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (event.stopPropagation) &#123;</span><br><span class="line">        event.stopPropagation();</span><br><span class="line">    &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &#123;</span><br><span class="line">        event.cancelBubble = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      前端兼容性问题小结
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="兼容性" scheme="http://yoursite.com/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>css知识点小结(2)</title>
    <link href="http://yoursite.com/2018/12/13/css%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93-2/"/>
    <id>http://yoursite.com/2018/12/13/css知识点小结-2/</id>
    <published>2018-12-13T12:42:33.000Z</published>
    <updated>2020-01-23T06:01:48.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="css知识点小结-2"><a href="#css知识点小结-2" class="headerlink" title="css知识点小结(2)"></a>css知识点小结(2)</h2><h3 id="1-文本超出部分显示省略号"><a href="#1-文本超出部分显示省略号" class="headerlink" title="1.文本超出部分显示省略号"></a>1.文本超出部分显示省略号</h3><p>单行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">overflow:hidden；</span><br><span class="line">text-overflow:ellipsis;</span><br><span class="line">white-space:nowarp;</span><br></pre></td></tr></table></figure><p>多行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display: -webkit-box;</span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line">-webkit-line-clamp: 3; // 最多显示几行</span><br><span class="line">overflow: hidden;</span><br></pre></td></tr></table></figure><p>###2.优雅降级和渐进增强</p><p><strong>优雅降级：</strong></p><ul><li>Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。</li></ul><p><strong>渐进增强：</strong></p><ul><li><p>从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</p><p>如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；</p></li></ul><h3 id="3-transition和animation的区别"><a href="#3-transition和animation的区别" class="headerlink" title="3.transition和animation的区别"></a>3.transition和animation的区别</h3><ul><li>transition是过渡动画，animation是帧动画。</li><li>transition只能从一种状态过渡到另外一种状态，animation可以定制复杂动画(多个帧)，可以定义动画的区间等。</li><li>transition必须通过一些行为才能触发（js或者伪类来触发），animation的话直接就可以触发。</li></ul><h3 id="4-margin-left-calc-100-100px-代码中calc（）作用"><a href="#4-margin-left-calc-100-100px-代码中calc（）作用" class="headerlink" title="4.margin-left:calc(-100%-100px) 代码中calc（）作用"></a>4.margin-left:calc(-100%-100px) 代码中calc（）作用</h3><ul><li>通过计算来确定CSS属性值。</li><li>calc是英文单词calculate(计算)的缩写，是css3的一个新增的功能，你可以使用calc()给元素的border、margin、pading、font-size和width等属性设置动态值。calc()可以使用数学运算中的简单加（+）、减（-）、乘（）和除（/）来解决问题，而且还可以根据单位如px,em,rem和百分比来转化计算</li></ul><h3 id="5-Sass、Less的区别？"><a href="#5-Sass、Less的区别？" class="headerlink" title="5. Sass、Less的区别？"></a>5. Sass、Less的区别？</h3><p>CSS 预处理，他们是动态的样式语言。他们规定了一种特殊的语法并且内置了编译器，可以将less/sass写的代码通过编译器编译成 CSS。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Less和Sass的区别：</span><br><span class="line">1.变量符不一样，less 是@，而 Sass 是$;</span><br><span class="line">2.Sass支持条件语句，可以使用 if&#123;&#125;else&#123;&#125;,for&#123;&#125;循环等等。而 Less 不支持;</span><br><span class="line">3.Sass是基于Ruby，需要在服务端处理的；而Less是在客户端处理，需要引入less.js</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      css知识点小结
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>css知识点小结(1)</title>
    <link href="http://yoursite.com/2018/12/02/css%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93-1/"/>
    <id>http://yoursite.com/2018/12/02/css知识点小结-1/</id>
    <published>2018-12-02T11:30:30.000Z</published>
    <updated>2020-01-24T12:17:50.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="css知识点小结-1"><a href="#css知识点小结-1" class="headerlink" title="css知识点小结(1)"></a>css知识点小结(1)</h2><h3 id="1-css选择器优先级"><a href="#1-css选择器优先级" class="headerlink" title="1.css选择器优先级"></a>1.css选择器优先级</h3><p><strong>选择器的特殊性值表述为4个部分，用0,0,0,0表示，权重计算规则如下：</strong></p><ul><li>行间样式        1,0,0,0</li><li>ID选择器         0,1,0,0</li><li>类选择器、属性选择器或伪类     0,0,1,0</li><li>元素和伪元素    0,0,0,1</li></ul><p>最后比较特殊的一个标志<strong>!important</strong>（权重），它没有特殊性值，但它的优先级是<strong>最高的</strong></p><h3 id="2块格式化上下文（Block-Formatting-Context）及其工作原理"><a href="#2块格式化上下文（Block-Formatting-Context）及其工作原理" class="headerlink" title="2块格式化上下文（Block Formatting Context）及其工作原理"></a>2块格式化上下文（Block Formatting Context）及其工作原理</h3><p><strong>块格式上下文（BFC）是它是一个独立的渲染区域，容器里面的子元素不会影响到外面的元素。</strong></p><p>BFC特性</p><ol><li>在BFC中，盒子从顶端开始垂直地一个接一个地排列。</li><li>盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠。</li><li>在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。</li><li>BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。</li><li>计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。</li></ol><p><strong>如何触发BFC</strong></p><ul><li><code>float</code>的值不是<code>none</code>.</li><li><code>position</code>的值不是<code>static</code>或<code>relative</code>.</li><li><code>display</code>的值是<code>table-cell</code>、<code>table-caption</code>、<code>inline-block</code>、<code>flex</code>、或<code>inline-flex</code>。</li><li><code>overflow</code>的值不是<code>visible</code>。</li></ul><h3 id="3-如何清除浮动"><a href="#3-如何清除浮动" class="headerlink" title="3.如何清除浮动"></a>3.如何清除浮动</h3><ul><li>空div方法，在父盒子最后加一个空盒子并且加上clear:both<code>&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;</code></li><li>伪元素法，使用伪元素定义一个clearfix的样式类，然后使用<code>&lt;div class=&quot;clearfix&quot;&gt;</code></li><li>给父亲设置<code>overflow: auto</code>或<code>overflow: hidden</code>等方法（触发BFC）。</li><li>给父元素指定高度。</li></ul><h3 id="4-外边距重叠（外边距坍塌）"><a href="#4-外边距重叠（外边距坍塌）" class="headerlink" title="4.外边距重叠（外边距坍塌）"></a>4.外边距重叠（外边距坍塌）</h3><p><strong>在 CSS 当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。</strong></p><p>折叠结果遵循下列计算规则：</p><ol><li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li><li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li><li>两个外边距一正一负时，折叠结果是两者的相加的和。</li></ol><h3 id="5-伪元素及其使用"><a href="#5-伪元素及其使用" class="headerlink" title="5.伪元素及其使用"></a>5.伪元素及其使用</h3><p><strong>伪元素指的是两个冒号的选择器   div::before   div::after    p::first-letter</strong></p><p>伪元素的用途：</p><p>1.用after清除浮动</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class="clear-fix"&gt;</span><br><span class="line">   &lt;div&gt; &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-tag">clear-fix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">        <span class="attribute">clear</span>: both;</span><br><span class="line">        <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">        <span class="attribute">display</span>: block;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">overflow</span>: hidden</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用伪类实现简单图标</li><li>元素 hover 特效</li></ol><h3 id="6-flex布局中的属性"><a href="#6-flex布局中的属性" class="headerlink" title="6.flex布局中的属性"></a>6.flex布局中的属性</h3><p>在容器上可以设置6个属性：</p><ul><li>flex-direction    主轴方向</li><li>flex-wrap         主轴超出范围是否换行</li><li>flex-flow         flex-direction和flex-wrap的复合属性</li><li>justify-content   元素在主轴的对齐方式</li><li>align-items       元素在侧轴的对齐方式</li><li>align-content     元素在侧轴的对齐方式（多行）</li></ul><p>注意：当设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。</p><p>Flex 有六种属性可运用在 item 项目上:</p><ol><li>order            flex-item的排序</li><li>flex-basis       flex-item的宽度</li><li>flex-grow        flex-item占据剩余空间的比例</li><li>flex-shrink      flex-item占据收缩空间的比例</li><li>flex             flex-grow\flex-shrink\flex-basis的复合属性</li><li>align-self       规定flex-item自己的对齐方式</li></ol><h3 id="7-行内元素、块级元素"><a href="#7-行内元素、块级元素" class="headerlink" title="7.行内元素、块级元素"></a>7.行内元素、块级元素</h3><p>行内元素：在一行显示，不可以设置宽高。代表  span   a   input   select  strong</p><p>块级元素：换行显示，可以设置宽高。代表  div  dl  dd  dt  form   p   table  tr  th  td</p><p>行内块级元素：在一行显示，可以设置宽高。代表 img  input</p><h3 id="8-水平垂直居中的方式"><a href="#8-水平垂直居中的方式" class="headerlink" title="8.水平垂直居中的方式"></a>8.水平垂直居中的方式</h3><ol><li>flex布局</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display: flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">align-items: center;</span><br></pre></td></tr></table></figure><ol start="2"><li>position定位</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 父容器</span><br><span class="line">position: relative;</span><br><span class="line"></span><br><span class="line">// 子容器</span><br><span class="line">position:absolute;</span><br><span class="line">margin:auto;</span><br><span class="line">top:0;</span><br><span class="line">bottom:0;</span><br><span class="line">left:0;</span><br><span class="line">right:0;</span><br></pre></td></tr></table></figure><ol start="3"><li>position+transform</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 父容器</span><br><span class="line">position: relative;</span><br><span class="line"></span><br><span class="line">// 子容器</span><br><span class="line">position: absolute;</span><br><span class="line">top: 50%;</span><br><span class="line">left: 50%;</span><br><span class="line">transform: translate(-50%, -50%);</span><br></pre></td></tr></table></figure><ol start="4"><li>position+margin</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 父容器</span><br><span class="line">position: relative;</span><br><span class="line"></span><br><span class="line">// 子容器</span><br><span class="line">height: 50px;</span><br><span class="line">background-color: #21252b;</span><br><span class="line">position: absolute;</span><br><span class="line">margin: auto;</span><br><span class="line">top: 50%;</span><br><span class="line">left: 50%;</span><br><span class="line">margin-left: -25px;</span><br><span class="line">margin-top: -25px;</span><br></pre></td></tr></table></figure><h3 id="9-CSS中link和-import的区别"><a href="#9-CSS中link和-import的区别" class="headerlink" title="9.CSS中link和@import的区别"></a>9.CSS中link和@import的区别</h3><ul><li>link属于HTML标签，而@import是CSS提供的</li><li>页面加载时，link会同时被加载，而@import引用的CSS会等到页面加载完毕后再加载</li><li>import只在IE5以上被识别，存在兼容性问题，link无兼容性问题</li><li>link方式的样式的权重高于@import的权重</li></ul><h3 id="10-CSS的常用选择器"><a href="#10-CSS的常用选择器" class="headerlink" title="10.CSS的常用选择器"></a>10.CSS的常用选择器</h3><p>1.id选择器（#box）<br>2.类选择器（.box）<br>3.标签选择器（div）<br>4.相邻选择器（h1+p）<br>5.子选择器（ul&gt;li）<br>6.后代选择器（li  a）<br>7.通配符选择器（*）<br>8.属性选择器（a[attr=”d1”]）<br>9.伪类选择器（a:hover, li:nth-child）</p>]]></content>
    
    <summary type="html">
    
      css知识点小结
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>html知识点小结</title>
    <link href="http://yoursite.com/2018/11/25/html%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/11/25/html知识点总结/</id>
    <published>2018-11-25T12:15:50.000Z</published>
    <updated>2020-01-21T11:38:17.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="html知识点小结"><a href="#html知识点小结" class="headerlink" title="html知识点小结##"></a>html知识点小结##</h2><h3 id="1-语义化标签"><a href="#1-语义化标签" class="headerlink" title="1.语义化标签"></a>1.语义化标签</h3><p>简单的来说就是用正确的标签做正确的事情。</p><p>优点：</p><ul><li>见名知意，可读性好，方便代码的开发和维护。</li><li>有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。</li><li>方便其他设备解析，如盲人阅读器根据语义渲染网页</li></ul><h3 id="2-CSS-的-lt-link-gt-标签放在-lt-head-gt-lt-head-gt-之间？-JS-的-lt-script-gt-标签放在-lt-body-gt-之前"><a href="#2-CSS-的-lt-link-gt-标签放在-lt-head-gt-lt-head-gt-之间？-JS-的-lt-script-gt-标签放在-lt-body-gt-之前" class="headerlink" title="2. CSS 的&lt;link&gt;标签放在&lt;head&gt;&lt;/head&gt;之间？ JS 的&lt;script&gt;标签放在&lt;/body&gt;之前"></a>2. CSS 的<code>&lt;link&gt;</code>标签放在<code>&lt;head&gt;&lt;/head&gt;</code>之间？ JS 的<code>&lt;script&gt;</code>标签放在<code>&lt;/body&gt;</code>之前</h3><ul><li><p>把<code>&lt;link&gt;</code>放在 <code>&lt;head&gt;</code>中</p><p>这种做法可以让页面逐步呈现，提高了用户体验。如果将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。并且link会阻止页面渲染但是不会组织页面的加载。</p></li><li><p>把<code>&lt;script&gt;</code>标签恰好放在<code>&lt;/body&gt;</code>之前 </p><p>脚本在下载和执行期间会阻止 HTML 解析。把<code>&lt;script&gt;</code>标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户。</p></li></ul><h3 id="3-Reflow和Repaint（重绘和重排）"><a href="#3-Reflow和Repaint（重绘和重排）" class="headerlink" title="3.Reflow和Repaint（重绘和重排）"></a>3.Reflow和Repaint（重绘和重排）</h3><ul><li><p>Reflow：当涉及到DOM节点的布局属性发生变化时，就会重新计算该属性，浏览器会重新描绘相应的元素，此过程叫Reflow（回流或重排）。</p></li><li><p>Repaint：当影响DOM元素可见性的属性发生变化 (如 color) 时, 浏览器会重新描绘相应的元素, 此过程称为Repaint（重绘）。因此重排必然会引起重绘。</p><p>1- 调整窗口大小<br>2- 字体大小<br>3- 样式表变动<br>4- 元素内容变化，尤其是输入控件<br>5- CSS伪类激活，在用户交互过程中发生<br>6- DOM操作，DOM元素增删、修改<br>7- width, clientWidth, scrollTop等布局宽高的计算</p><p>Repaint和Reflow是不可避免的，只能说对性能的影响减到最小，给出下面几条建议：<br>1- 避免逐条更改样式。建议集中修改样式，例如操作className。<br>2- 避免频繁操作DOM。创建一个documentFragment或div，在它上面应用所有DOM操作，最后添加到文档里。设置      display:none的元素上操作，最后显示出来。<br>3- 避免频繁读取元素几何属性（例如scrollTop）。绝对定位具有复杂动画的元素。<br>4- 绝对定位使它脱离文档流，避免引起父元素及后续元素大量的回流</p></li></ul><h3 id="4-href和src区别"><a href="#4-href和src区别" class="headerlink" title="4.href和src区别"></a>4.href和src区别</h3><p><strong>它们之间的主要区别可以用这样一句话来概括：src用于替代这个元素，而href用于建立这个标签与外部资源之间的关系。</strong></p><ul><li>href<br>href标识超文本引用，用在link和a等元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系<br>若在文档中添加href ，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。</li><li>src<br>src表示引用资源，替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分。<br><br>当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。</li></ul><p>使用场景</p><ul><li>引用css文件时：<code>href=&quot;cssfile.css&quot;</code></li><li>引用js文件时：<code>src=&quot;myscript.js&quot;</code></li><li>引用图片：<code>src=&quot;mypic.jpg&quot;</code></li><li>网站链接：<code>href=&quot;http://www.webpage.com&quot;</code></li></ul><h3 id="5-浏览器的渲染过程"><a href="#5-浏览器的渲染过程" class="headerlink" title="5.浏览器的渲染过程"></a>5.浏览器的渲染过程</h3><ol><li>解析HTML生成DOM树。</li><li>解析CSS生成CSSOM规则树。</li><li>将DOM树与CSSOM规则树合并在一起生成渲染树。</li><li>遍历渲染树开始布局，计算每个节点的位置大小信息。</li><li>将渲染树每个节点绘制到屏幕。</li></ol><h3 id="6-doctype有什么用"><a href="#6-doctype有什么用" class="headerlink" title="6.doctype有什么用"></a>6.doctype有什么用</h3><p>DOCTYPE是document type的简写，它并不是 HTML 标签，也没有结束标签，它是一种标记语言的文档类型声明，即告诉浏览器当前 HTML 是用什么版本编写的。</p><p>1.告知浏览器文档使用哪种 HTML 或 XHTML 规范。</p><p>2.告诉浏览器按照何种规范解析页（如果你的页面没有DOCTYPE的声明，那么浏览器会进入Quirks模式）</p><h3 id="7-优化图片加载的方法"><a href="#7-优化图片加载的方法" class="headerlink" title="7.优化图片加载的方法"></a>7.优化图片加载的方法</h3><ol><li>图片懒加载。</li><li>使用icon和精灵图技术。</li><li>使用其他服务器单独存放图片。</li><li>如果图片过大，可以使用特殊编码的图片（base64编码）</li></ol><h3 id="8-常见的浏览器内核有哪些"><a href="#8-常见的浏览器内核有哪些" class="headerlink" title="8.常见的浏览器内核有哪些"></a>8.常见的浏览器内核有哪些</h3><p>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]</p><p>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等</p><p>Presto内核：Opera7及以上。     [Opera内核原为：Presto，现为：Blink;]</p><p>Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]</p><h3 id="9-SEO中的TDK"><a href="#9-SEO中的TDK" class="headerlink" title="9.SEO中的TDK"></a>9.SEO中的TDK</h3><p>网页标题(title)：用于告诉用户和搜索引擎当前页面的核心内容，title是搜索引擎根据用户检索关键词进行排名的核心指标，一般标题中含有搜索的关键词才能获得较好的排名;</p><p>页面描述(description)：显示在搜索结果中，以百度为例如下图，用于告知用户网站页面的主要内容，作为引导用户点击的索引;</p><p>页面关键词(keywords)：告诉搜索引擎当前页面内容的关键词，用户无论在搜索结果还是浏览页面时都看不到页面关键词。</p><p><img src="/.com//html%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%5Ctdk.jpg" alt></p><p><img src="/.com//html%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%5Ctdk2.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      html知识点小结
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>First-Blog</title>
    <link href="http://yoursite.com/2018/11/12/First-Blog/"/>
    <id>http://yoursite.com/2018/11/12/First-Blog/</id>
    <published>2018-11-12T11:32:00.000Z</published>
    <updated>2020-01-19T15:27:15.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个人的第一篇博客"><a href="#个人的第一篇博客" class="headerlink" title="个人的第一篇博客"></a><strong>个人的第一篇博客</strong></h1><p>今天开启了个人博客，打算记录和分享一些关于生活，学习，以及技术方面的内容，也算是一个简单的记录吧。              个人还是希望把日语继续学下去，工作中英语也很重要，还有各种前端技术，所以不能停滞不前，需要保持高度的学习状态，好好加油吧！</p>]]></content>
    
    <summary type="html">
    
      默兽的第一篇博客
    
    </summary>
    
      <category term="随想" scheme="http://yoursite.com/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="第一篇博客" scheme="http://yoursite.com/tags/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
