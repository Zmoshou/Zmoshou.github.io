<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moshou</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-04T13:51:02.226Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Moshou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>移动端键盘弹出顶起fixed定位问题</title>
    <link href="http://yoursite.com/2019/07/10/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%94%AE%E7%9B%98%E5%BC%B9%E5%87%BA%E9%A1%B6%E8%B5%B7fixed%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/07/10/移动端键盘弹出顶起fixed定位问题/</id>
    <published>2019-07-10T11:19:19.000Z</published>
    <updated>2020-02-04T13:51:02.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动端键盘弹出顶起fixed定位问题"><a href="#移动端键盘弹出顶起fixed定位问题" class="headerlink" title="移动端键盘弹出顶起fixed定位问题"></a>移动端键盘弹出顶起fixed定位问题</h2><blockquote><p>移动端页面的底部菜单栏，通常会使用fixed定位在底部。在安卓手机上经常会出现软键盘弹出时，底部定位被顶上去，下面提供vue和jQuery两种解决办法。</p></blockquote><h3 id="1vue-js代码"><a href="#1vue-js代码" class="headerlink" title="1vue.js代码"></a>1vue.js代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--html部分--&gt;</span><br><span class="line">&lt;div class=&quot;footer&quot; v-show=&quot;hideshow&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// js 部分</span><br><span class="line">data()&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    docmHeight: document.documentElement.clientHeight,  //默认屏幕高度</span><br><span class="line">showHeight: document.documentElement.clientHeight,   //实时屏幕高度</span><br><span class="line">hideshow:true,  //显示或者隐藏footer</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">  // window.onresize监听页面高度的变化</span><br><span class="line">  window.onresize = ()=&gt;&#123;</span><br><span class="line">    return(()=&gt;&#123;</span><br><span class="line">      this.showHeight = document.body.clientHeight;</span><br><span class="line">    &#125;)()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">//监听</span><br><span class="line">watch:&#123;</span><br><span class="line">  showHeight:function() &#123;</span><br><span class="line">    if(this.docmHeight &gt; this.showHeight)&#123;</span><br><span class="line">      this.hideshow=false</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      this.hideshow=true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="2-jQuery代码"><a href="#2-jQuery代码" class="headerlink" title="2 jQuery代码"></a>2 jQuery代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> winHeight = $(<span class="built_in">window</span>).height();  <span class="comment">//获取当前页面高度</span></span><br><span class="line">$(<span class="built_in">window</span>).resize(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> thisHeight = $(<span class="keyword">this</span>).height();</span><br><span class="line">    <span class="keyword">if</span> ( winHeight - thisHeight &gt; <span class="number">140</span> ) &#123;</span><br><span class="line">        <span class="comment">//键盘弹出</span></span><br><span class="line">        $(<span class="string">'.footer'</span>).css(<span class="string">'position'</span>,<span class="string">'static'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//键盘收起</span></span><br><span class="line">        $(<span class="string">'.footer'</span>).css(&#123;<span class="string">'position'</span>:<span class="string">'fixed'</span>,<span class="string">'bottom'</span>:<span class="string">'0'</span>&#125;);</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>原文链接：<a href="https://blog.csdn.net/Tessa_zzl/article/details/89680315" target="_blank" rel="noopener">https://blog.csdn.net/Tessa_zzl/article/details/89680315</a></p>]]></content>
    
    <summary type="html">
    
      移动端键盘弹出顶起fixed定位问题
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="移动端" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="fixed定位" scheme="http://yoursite.com/tags/fixed%E5%AE%9A%E4%BD%8D/"/>
    
  </entry>
  
  <entry>
    <title>git study</title>
    <link href="http://yoursite.com/2019/06/28/git-study/"/>
    <id>http://yoursite.com/2019/06/28/git-study/</id>
    <published>2019-06-28T10:06:19.000Z</published>
    <updated>2020-02-04T08:37:38.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h3 id="一-git介绍"><a href="#一-git介绍" class="headerlink" title="一 git介绍"></a>一 git介绍</h3><h4 id="1-什么是git？"><a href="#1-什么是git？" class="headerlink" title="1 什么是git？"></a>1 什么是git？</h4><ul><li>Git是目前世界上最先进的分布式版本控制系统。</li></ul><ul><li><p>Git 是 Linus Torvalds(林纳斯·托瓦兹) 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p><p>工作流程：</p><p><img src="https://s2.ax1x.com/2020/02/04/1B5eNq.png" alt></p></li></ul><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><p><strong>理解工作区，暂存区，版本库的区别？</strong></p><ul><li>工作区：就是你在电脑上看到的目录，比如目录下某个里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。</li><li>版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。</li></ul><p>使用Git提交文件到版本库有两步：</p><p>第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。</p><p>第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。</p><h4 id="2-什么又是版本控制系统？"><a href="#2-什么又是版本控制系统？" class="headerlink" title="2 什么又是版本控制系统？"></a>2 什么又是版本控制系统？</h4><ul><li>如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：想删除一个段落，又怕将来想恢复找        不回    来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去…… 结果就是保存的文件非常多，回头想找到某一次修改后的文件也十分麻烦</li></ul><h4 id="3-都是用于版本控制-svn和git有什么区别？"><a href="#3-都是用于版本控制-svn和git有什么区别？" class="headerlink" title="3 都是用于版本控制 svn和git有什么区别？"></a>3 都是用于版本控制 svn和git有什么区别？</h4><p><img src="https://s2.ax1x.com/2020/02/04/1B5JER.png" alt></p><ul><li>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就麻烦…</li><li>Git就是分布式版本控制系统，对应的是集中式的版本控制如SVN。简单的说，分布式的版本控制就是每个人都可以创建一个独立的代码仓库用于管理，各种版本控制的操作都可以在本地完成。每个人修改的代码都可以推送合并到另外一个代码仓库中。</li></ul><h3 id="二-基本使用"><a href="#二-基本使用" class="headerlink" title="二 基本使用"></a>二 基本使用</h3><h4 id="1-创建版本库"><a href="#1-创建版本库" class="headerlink" title="1 创建版本库"></a>1 创建版本库</h4><ol><li><p>新建一个文件夹</p></li><li><p>通过命令 *<em>git init *</em>把这个目录变成git可以管理的仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo</span><br><span class="line">$  git init</span><br><span class="line">Initialized empty Git repository in C:/Users/Shinelon/Desktop/git/gitDemo/.git/</span><br></pre></td></tr></table></figure><p>目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的</p></li><li><p>把文件添加到版本库中</p><p>目录下新建一个记事本文件 readme.txt 内容如下：11111111</p><p>添加指定目录到暂存区，包括子目录</p><ul><li><p>使用命令 <strong>git add</strong> 添加到暂存区(stage)里面去</p><p>git add [dir] 添加指定文件</p><p>git add . 添加所有文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)</span><br><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>如果和上面一样，没有任何提示，说明已经添加成功了。</p></li><li><p>用命令 <strong>git commit</strong> 把文件提交到仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)</span><br><span class="line">$ git commit -m &apos;第一次提交&apos;  //这里相当于注释</span><br><span class="line">[master (root-commit) 94c85ed] 第一次提交</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure></li><li><p>通过命令<strong>git status</strong>来查看是否还有文件未提交</p><p>当我们将readme.txt 稍作修改时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt  //此处表示 readme.txt文件被修改了</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>上面的命令告诉我们 readme.txt文件已被修改，但是未被提交的修改。</p></li><li><p>通过<strong>git diff</strong> 查看文件到底改了什么内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)</span><br><span class="line">$ git diff readme.txt</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 748099d..1ae13e4 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line">-11111111</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+11111111</span><br><span class="line">+22222222</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><p>readme.txt文件内容从一行11111111改成 二行 添加了一行22222222内容。</p><p>然后再次 第一步:git add    第二步：git commit 后可以再次提交</p></li></ul></li></ol><h4 id="2-版本回退"><a href="#2-版本回退" class="headerlink" title="2 版本回退"></a>2 版本回退</h4><ol><li><p>使用 <strong>git log</strong> 命令查看下历史记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit a387d6c1e2da74df7f00e34867cadec472c2eebe (HEAD -&gt; master)</span><br><span class="line">Author: e &lt;752625566@qq.com&gt;</span><br><span class="line">Date:   Mon Nov 25 18:55:52 2019 +0800</span><br><span class="line"></span><br><span class="line">    第二次提交</span><br><span class="line"></span><br><span class="line">commit 94c85ed50a6ad9c8b0075fa0f38abbdc719d01d8</span><br><span class="line">Author: e &lt;752625566@qq.com&gt;</span><br><span class="line">Date:   Mon Nov 25 18:29:47 2019 +0800</span><br><span class="line"></span><br><span class="line">    第一次提交</span><br></pre></td></tr></table></figure></li><li><p>版本回退操作</p><p><strong>第一种</strong>：<strong>git reset –hard HEAD^</strong>，回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推 ，</p><p>git reset –hard HEAD~10 回退10个版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)</span><br><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 94c85ed 第一次提交</span><br></pre></td></tr></table></figure><p>此时文件内容变为原来的 1111111</p><p><strong>第二种</strong>：可以通过 <strong>git reflog</strong> 命令即可获取到版本号:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)</span><br><span class="line">$ git reflog</span><br><span class="line">94c85ed (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">a387d6c HEAD@&#123;1&#125;: commit: 第二次提交</span><br><span class="line">94c85ed (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): 第一次提交</span><br></pre></td></tr></table></figure><p>再通过<strong>git reset –hard</strong> 版本号名 来恢复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)</span><br><span class="line">$ git reset --hard a387d6c</span><br><span class="line">HEAD is now at a387d6c 第二次提交</span><br></pre></td></tr></table></figure><p>此时readme.txt文件又恢复到第二次提交时的内容 11111111  22222222</p></li></ol><h4 id="3-Git撤销修改和删除文件操作"><a href="#3-Git撤销修改和删除文件操作" class="headerlink" title="3 Git撤销修改和删除文件操作"></a>3 Git撤销修改和删除文件操作</h4><ul><li><p>Git撤销修改 ，未提交之前，我发现添加的内容有误，需要恢复以前的版本</p><p><strong>git checkout – file</strong>可以丢弃工作区的修改 <strong>git checkout –文件名</strong>可以对单个文件撤销修改</p><p>命令 git checkout意思就是，把文件在工作区做的修改全部撤销</p><p>我们先对readme.txt文件进行修改  加内容 3333333</p><p>再</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)</span><br><span class="line">$ git checkout -- readme.txt</span><br><span class="line">//此时readme.txt添加的3333333没有了</span><br></pre></td></tr></table></figure><ol><li>readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。</li><li>另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。</li></ol></li><li><p>删除文件 </p><p>一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm readme.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉</p></li></ul><h4 id="4-远程仓库"><a href="#4-远程仓库" class="headerlink" title="4 远程仓库"></a>4 远程仓库</h4><ul><li><p>在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置：</p><ol><li><p>第一步：创建<strong>SSH Key</strong>。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<strong>id_rsa</strong>和<strong>id_rsa.pub</strong>这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：</p><p>ssh-keygen -t rsa –C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>”</p><p>id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p></li><li><p>第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。</p><p><img src="https://s2.ax1x.com/2020/02/04/1B58b9.png" alt></p></li></ol></li><li><p>如何添加远程仓库</p><p>现在的情景是：本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。</p><ol><li>登录github上，然后在右上角找到“create a new repo”创建一个新的仓库</li><li>我们根据GitHub的提示，在本地的testgit仓库下运行命令 git remote add origin <a href="https://github.com/Zmoshou/testgit.git" target="_blank" rel="noopener">https://github.com/Zmoshou/testgit.git</a></li><li>把本地库的内容推送到远程，使用 git push命令<strong>git push -u origin master</strong>，实际上是把当前分支master推送到远程</li><li>由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)</span><br><span class="line">$ git remote add origin https://github.com/Zmoshou/testgit.git</span><br><span class="line"></span><br><span class="line">Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)</span><br><span class="line">$ git push -u origin master</span><br><span class="line">Enumerating objects: 6, done.</span><br><span class="line">Counting objects: 100% (6/6), done.</span><br><span class="line">Delta compression using up to 4 threads</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (6/6), 445 bytes | 222.00 KiB/s, done.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/Zmoshou/testgit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;.</span><br></pre></td></tr></table></figure><p>  <img src="https://s2.ax1x.com/2020/02/04/1B5uCV.png" alt></p><ul><li><p>完成以上操作后，只要本地作了提交，就可以通过如下命令：<strong>git push origin master</strong></p><p>把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。</p></li><li><p>如何从远程库克隆？</p><p>使用命令git clone从远程仓库克隆一个本地库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/新建文件夹</span><br><span class="line">$ git clone https://github.com/Zmoshou/testgit.git</span><br><span class="line">Cloning into &apos;testgit&apos;...</span><br><span class="line">remote: Enumerating objects: 6, done.</span><br><span class="line">remote: Counting objects: 100% (6/6), done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 6 (delta 0), reused 6 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (6/6), done.</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="三-多人协作开发"><a href="#三-多人协作开发" class="headerlink" title="三 多人协作开发"></a>三 多人协作开发</h3><ul><li>首先创建一个git服务器，被多个人所操作(Github或者Gitlab)</li></ul><p><img src="https://s2.ax1x.com/2020/02/04/1B5m40.png" alt></p><h4 id="1-多人协助实现"><a href="#1-多人协助实现" class="headerlink" title="1 多人协助实现"></a>1 多人协助实现</h4><p>分为如下几个步骤：</p><ol><li><p>创建一个git裸服务器 （git init –bare）</p><p>由负责人来完成的。服务器新建一个项目目录</p></li><li><p>从裸服务器将版本库克隆至本地（git clone ）</p><p>使用命令 <strong>git clone git版本服务器地址</strong></p></li><li><p>本地常规操作(日常开发)</p></li><li><p>推送版本至服务器 （git remote +  git push origin master）</p><p>在这之前需要git add 和 git commit操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)</span><br><span class="line">$ git push origin master</span><br><span class="line">Enumerating objects: 4, done.</span><br><span class="line">Counting objects: 100% (4/4), done.</span><br><span class="line">Delta compression using up to 4 threads</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 262 bytes | 131.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/Zmoshou/testgit.git</span><br><span class="line">   a387d6c..bad13db  master -&gt; master</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>从远程服务器拉取版本（git pull）</p><p>在多人协助开发时，每个开发人员在推送自己的最新版本时，都需要确保当前版本是最新的，所以就需要先获取最新版本，也就是说需要从服务器拉取最新版本到本地。</p><p>需要使用 git pull命令</p><p>对很多开发人员而言，一打开电脑，马上先git pull，拉取最新的。然后进行常规开发，</p><p>开发完毕之后，在git push之前，还需要使用git pull再拉取一遍</p></li></ol><ul><li><strong>如果有新的开发人员加入进来，重复2<del>5过程。如果不是新的开发人员，重复3</del>5过程</strong></li><li>在整个协作开发时，有时候会出现冲突。通常都是由于开发人员分工不明确导致的，所以如果出现这种情况，需要两个程序员协商解决.。</li></ul><h4 id="2-分支"><a href="#2-分支" class="headerlink" title="2 分支"></a>2 分支</h4><ol><li><p>什么是分支</p><ul><li>在版本回退里已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</li></ul><p><img src="https://s2.ax1x.com/2020/02/04/1B5ZEn.png" alt></p><ul><li><p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长</p><p><img src="https://s2.ax1x.com/2020/02/04/1B5EHs.png" alt></p><p>当我们创建新的分支，</p><p>例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上</p></li><li><p>从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p><p><img src="https://s2.ax1x.com/2020/02/04/1B5K3T.png" alt></p></li><li><p>我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p><p><img src="https://s2.ax1x.com/2020/02/04/1B5MgU.png" alt></p></li><li><p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p><p><img src="https://s2.ax1x.com/2020/02/04/1B51u4.png" alt></p></li></ul></li><li><p>什么时候会用到分支</p><p>假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险，怎么办？</p><p>你可以创建一个属于自己的分支，别人看不见，还继续在原来的分支上工作，而你在自己的分支上进行开发，等开发完毕，合并即可。</p><p>在开源世界中，需用大量的程序员共同维护一个项目。也是需要使用分支，如Jquery</p></li><li><p>分支的基本操作</p><p>基本操作有如下几个：</p><ul><li><p>查看当前分支 （git branch）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>创建分支 （git branch 分支名）</p><p>切换分支（git checkout 分支名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (dev)</span><br><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b[自定义分支名]</span><br><span class="line"></span><br><span class="line">一般都使用与远程对应开发分支相同的名字，这里就是用上述中的 plugin-20190622 分支</span><br><span class="line">$ git checkout -b plugin-20190622</span><br></pre></td></tr></table></figure></li><li><p>关联</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=[远程分支名] [本地分支名]  //命令</span><br><span class="line">$ git branch --set-upstream-to=origin/plugin-20190930 plugin-20190622</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>分支上的常规操作</p><p>日常开发 然后使用git add 和git commit提交。</p><p>可以使用git log查看</p></li><li><p>分支的合并 （git checkout master + git merge 分支名）</p><p>分支的合并，一定是在 主分支上进行的。</p><p>只能在主分支合并其它分支。</p><p>需要两步：</p><p>1） 切换到主分支<strong>git checkout master</strong></p><p>2） 使用git merge 分支名 进行合并 <strong>git merge dev</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)</span><br><span class="line">$ git merge dev</span><br><span class="line">Updating bad13db..334a0e7</span><br><span class="line">Fast-forward</span><br><span class="line"> gittest.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>此时我们再次查看master的一个log情况</p><p>​</p></li><li><p>分支的删除（git branch -d 分支名）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)</span><br><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was 334a0e7).</span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      git基本知识学习
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>节流防抖</title>
    <link href="http://yoursite.com/2019/06/01/%E2%80%98%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"/>
    <id>http://yoursite.com/2019/06/01/‘节流防抖/</id>
    <published>2019-06-01T08:49:33.000Z</published>
    <updated>2020-02-04T05:21:16.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h2><p>防抖、节流<code>https://segmentfault.com/a/1190000016261602</code>这个写的很好，平时键盘抬起就会搜索，防抖后，间隔一段时间不输入才会搜索，节流后，可以做到不管是否停止打字，间隔一段时间都会搜索。</p><h3 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖(debounce)"></a>函数防抖(debounce)</h3><ul><li>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/模拟一段ajax请求,只要按下键盘，就会触发这次ajax请求。</span><br><span class="line">/* ajax函数用来输出传入的参数*/</span><br><span class="line">function ajax(content) &#123;</span><br><span class="line">  console.log(&apos;ajax request &apos; + content)</span><br><span class="line">&#125;</span><br><span class="line">/* 通过id值获取到DOM标签*/</span><br><span class="line">let inputa = document.getElementById(&apos;unDebounce&apos;)</span><br><span class="line"></span><br><span class="line">inputa.addEventListener(&apos;keyup&apos;, function (e) &#123;</span><br><span class="line">    ajax(e.target.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/ 延迟执行ajax请求后，当你在频繁的输入时，并不会发送请求，只有当你在指定间隔内没有输入时，才会执行函数/</span><br><span class="line">/* ajax函数用来输出传入的参数*/</span><br><span class="line">function ajax(content) &#123;</span><br><span class="line">  console.log(&apos;ajax request &apos; + content)</span><br><span class="line">&#125;</span><br><span class="line">/这里定义一个debounce函数，将传入的函数延迟5秒执行，如果间隔小于5秒，就会重新计时/</span><br><span class="line">function debounce(fun, delay) &#123;</span><br><span class="line">    return function (args) &#123;</span><br><span class="line">        let that = this</span><br><span class="line">        let _args = args</span><br><span class="line">        clearTimeout(fun.id)</span><br><span class="line">        fun.id = setTimeout(function () &#123;</span><br><span class="line">            fun.call(that, _args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* 通过id值获取到DOM标签*/    </span><br><span class="line">let inputb = document.getElementById(&apos;debounce&apos;);</span><br><span class="line">/这是个函数，是debounce返回的函数/</span><br><span class="line">let debounceAjax = debounce(ajax, 500)</span><br><span class="line">/* 添加监听键盘抬起事件，每次弹起就执行后面的回调函数，即将输入内容传值给debounceAjax函数延迟执行ajax*/</span><br><span class="line">inputb.addEventListener(&apos;keyup&apos;, function (e) &#123;</span><br><span class="line">        debounceAjax(e.target.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流(throttle)"></a>函数节流(throttle)</h3><p>规定在一个单位时间内，只能触发一次函数。<strong>如果这个单位时间内触发多次函数，只有一次生效。</strong>【性能优化】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let biu = function () &#123;</span><br><span class="line">    console.log(&apos;biu biu biu&apos;,new Date().Format(&apos;HH:mm:ss&apos;))</span><br><span class="line">&#125;</span><br><span class="line">setInterval(debounce(biu,500),1000)</span><br><span class="line">/*biu这个函数在第一次1.5s后执行，然后每隔1s执行一次*/</span><br><span class="line"></span><br><span class="line">let boom = function () &#123;</span><br><span class="line">    console.log(&apos;boom boom boom&apos;,new Date().Format(&apos;HH:mm:ss&apos;))</span><br><span class="line">&#125;</span><br><span class="line">setInterval(debounce(boom,2000),1000)</span><br><span class="line">/*boom这个函数，一次都不会执行，函数执行事件是1s，但是函数间隔2s才会执行，每次2s还没到，就重新计时了*/</span><br></pre></td></tr></table></figure><p>优化后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   /在不断输入时，ajax会按照我们设定的时间，每1s执行一次</span><br><span class="line">function throttle(fun, delay) &#123;</span><br><span class="line">       let last, deferTimer</span><br><span class="line">       return function (args) &#123;</span><br><span class="line">           let that = this</span><br><span class="line">           let _args = arguments</span><br><span class="line">           let now = +new Date()</span><br><span class="line">           if (last &amp;&amp; now &lt; last + delay) &#123;</span><br><span class="line">               clearTimeout(deferTimer)</span><br><span class="line">               deferTimer = setTimeout(function () &#123;</span><br><span class="line">                   last = now</span><br><span class="line">                   fun.apply(that, _args)</span><br><span class="line">               &#125;, delay)</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">               /如果现在=上一次的时间+延迟时间，那么就马上执行fun函数</span><br><span class="line">               last = now</span><br><span class="line">               fun.apply(that,_args)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">/*throttleAjax是个函数，*/</span><br><span class="line">   let throttleAjax = throttle(ajax, 1000);</span><br><span class="line"></span><br><span class="line">/* 获取当前的DOM元素，并添加键盘抬起的监听事件，每次抬起就调用函数throttleAjax*/</span><br><span class="line">   let inputc = document.getElementById(&apos;throttle&apos;)</span><br><span class="line">   inputc.addEventListener(&apos;keyup&apos;, function(e) &#123;</span><br><span class="line">       throttleAjax(e.target.value)</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">/不管我们设定的执行时间间隔多小，总是1s内只执行一次。</span><br><span class="line">let biubiu = function () &#123;</span><br><span class="line">       console.log(&apos;biu biu biu&apos;, new Date().Format(&apos;HH:mm:ss&apos;))</span><br><span class="line">   &#125;;</span><br><span class="line">   setInterval(throttle(biubiu,1000),10);</span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>函数防抖，类似法师技能读条，还没读完条再按技能，就会重新读条，但是会出现一直读条不能放技能的状况；函数节流，就是一直按着技能键，也能在规定时间内发技能。</p><ul><li>函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。</li><li>函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。</li><li>debounce<ul><li>search搜索联想，用户在不断输入值时，用防抖来节约请求资源。</li><li>window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</li></ul></li><li>throttle<ul><li>鼠标不断点击触发，mousedown(单位时间内只触发一次)</li><li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      节流防抖
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="节流防抖" scheme="http://yoursite.com/tags/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"/>
    
  </entry>
  
  <entry>
    <title>Vue相关问题</title>
    <link href="http://yoursite.com/2019/05/17/Vue%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/05/17/Vue相关问题/</id>
    <published>2019-05-17T10:59:24.000Z</published>
    <updated>2020-02-03T04:54:34.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue相关问题"><a href="#vue相关问题" class="headerlink" title="vue相关问题"></a>vue相关问题</h1><h4 id="1-vue实现双向绑定的原理？"><a href="#1-vue实现双向绑定的原理？" class="headerlink" title="1. vue实现双向绑定的原理？"></a>1. vue实现双向绑定的原理？</h4><p>MVVM 模式在于数据与视图的保持同步，意思是说数据改变时会自动更新视图，视图发生变化时会更新数据。</p><p> 所以我们需要做的就是<strong>如何检测到数据的变化然后通知我们去更新视图</strong>，<strong>如何检测到视图的变化然后去更新数据</strong>。<strong>检测视图这个比较简单，无非就是我们利用事件的监听即可</strong>。那么如何才能知道数据属性发生变化呢？这个就是利用我们上面说到的 <code>Object.defineProperty</code> 当我们的属性发生变化时，它会自动<strong>触发 set 函数从而能够通知我们去更新视图</strong>。</p><p>数据双向绑定作为 Vue 核心功能之一，Vue 则采用的<strong>是数据劫持与发布订阅相结合的方式实现双向绑定</strong>。</p><p>其中数据劫持是利用了 <strong>Object.defineProperty() 方法重新定义了对象获取属性值get和设置属性值set的操作</strong>来实现的；</p><p><img src="https://codingwithalice.github.io/img/assets_2019/v2-0acc539d759e5bf7c4dedb9aafafdb45_r.jpg" alt="preview"></p><p>劫持了数据之后，我们就需要一个监听器 Observer 来监听属性的变化。得知属性发生变化之后我们需要一个 Watcher 订阅者来更新视图，我们还需要一个 compile 指令解析器，用于解析我们的节点元素的指令与初始化视图。</p><ul><li>Observer 监听器：用来监听属性的变化通知订阅者</li><li>Watcher 订阅者：收到属性的变化，然后更新视图（这个过程中我们可能会有很多个订阅者 Watcher 所以我们要创建一个容器 Dep 去做一个统一的管理）</li><li>Compile 解析器：解析指令，初始化模版，绑定订阅者</li></ul><p><strong>语法</strong> <code>Object.defineProperty(obj,prop,descriptor)</code></p><p><strong>参数</strong>：obj：目标对象；prop：需要定义的属性或方法的名称；descriptor：目标属性所拥有的特性</p><p><strong>可供定义的特性列表</strong></p><table><thead><tr><th>可供定义的特性</th><th></th></tr></thead><tbody><tr><td>value</td><td>属性的值</td></tr><tr><td>writable</td><td>如果为false，属性的值就不能被重写</td></tr><tr><td>get</td><td>一旦目标属性被访问就会调回此方法，并将此方法的运算<strong>结果返回用户</strong></td></tr><tr><td>set</td><td>一旦<strong>目标属性被赋值</strong>，就会调回此方法</td></tr><tr><td>configurable</td><td>如果为false，则任何尝试删除目标属性或修改属性性以下特性（writable, configurable, enumerable）的行为将被<strong>无效化</strong>。</td></tr><tr><td>enumerable</td><td>是否能在for…in循环中遍历出来或在Object.keys中列举出来</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; &#125;;</span><br><span class="line">var name;</span><br><span class="line">Object.defineProperty(obj, &quot;data&quot;, &#123;</span><br><span class="line">    //获取值</span><br><span class="line">    get:function () &#123;return name;&#125;,</span><br><span class="line">    //设置值</span><br><span class="line">    set:function (val) &#123;name = val;console.log(val);&#125;</span><br><span class="line">&#125;)</span><br><span class="line">    obj.data = &apos;aaa&apos;;//赋值调用set</span><br><span class="line">   console.log(obj.data); //取值调用get</span><br></pre></td></tr></table></figure><p> 当我们<strong>访问或设置</strong>对象的属性的时候，都会<strong>触发相对应的函数</strong>，然后在这个函数里返回或设置属性的值。既然如此，我们当然可以在触发函数的时候动一些手脚做点我们自己想做的事情，这也就是“劫持”操作。</p><p> 在Vue中其实就是通过<code>Object.defineProperty</code>来<strong>劫持对象属性的setter和getter操作</strong>，并“种下”一个监听器，<strong>当数据发生变化的时候发出通知</strong>。</p><p>注意： <strong>该方法每次只能设置一个属性</strong>，那么就需要遍历对象来完成其属性的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(student).forEach(key =&gt; defineReactive(student, key))</span><br></pre></td></tr></table></figure><p> 另外还必须是一个<strong>具体的属性</strong>，这也非常的致命。假如后续需要扩展该对象，那么就必须手动为新属性设置 setter 和 getter 方法，<strong>这就是为什么不在 data 中声明的属性无法自动拥有双向绑定效果的原因</strong> 。这时需要调用 <code>Vue.set()</code>手动设置。</p><p> <strong>针对 Array 类型的劫持</strong></p><p> 数组是一种特殊的对象，<strong>其下标实际上就是对象的属性，所以理论上是可以采用 Object.defineProperty() 方法处理数组对象</strong>。 </p><p> 但是 Vue 并没有采用上述方法劫持数组对象，原因分析：1、特殊的 length 属性，相比较对象的属性，数组下标变化地相对频繁，并且改变数组长度的方法也比较灵活，一旦数组的长度发生变化，那么在无法自动感知的情况下，开发者只能手动更新新增的数组下标，这可是一个很繁琐的工作。2、数组主要的操作场景还是遍历，而对于每一个元素都挂载一个 get 和 set 方法，恐怕也是不小的性能负担。</p><p> <strong>数组方法的劫持</strong>：最终 Vue 选择劫持一些<strong>常用的数组操作方法，从而知晓数组的变化情况</strong>：<code>push&#39;, &#39;pop&#39;, &#39;shift&#39;, &#39;unshift&#39;, &#39;sort&#39;, &#39;reverse&#39;, &#39;splice&#39;</code>。数组方法的劫持涉及到原型相关的知识，首先数组实例大部分方法都是来源于 <code>Array.prototype</code> 对象。顺便提一下，<strong>采用 Vue.set() 方法设置数组元素时，Vue 内部实际上是调用劫持后的 splice() 方法来触发更新</strong>。</p><p><strong>总结</strong>：由上述内容可知，Vue 中的数据劫持分为两大部分：</p><p>针对 Object 类型，采用 <code>Object.defineProperty()</code>方法劫持属性的读取和设置方法；</p><p>针对 Array 类型，采用原型相关的知识劫持常用的函数，从而知晓当前数组发生变化。</p><p>并且 <code>Object.defineProperty()</code> 方法存在以下<strong>缺陷</strong>：<strong>每次只能设置一个具体的属性</strong>，导致需要遍历对象来设置属性，同时也导致了无法探测新增属性；属性描述符 configurable 对其的影响是致命的。</p><h5 id="1-1发布订阅模式"><a href="#1-1发布订阅模式" class="headerlink" title="1.1发布订阅模式"></a>1.1发布订阅模式</h5><p>在<strong>观察者</strong>模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在<strong>发布订阅</strong>模式中，发布者和订阅者<strong>不知道对方的存在</strong>。它们只有通过消息代理进行通信。</p><p>在<strong>发布订阅</strong>模式中，组件是松散耦合的，正好和观察者模式相反。</p><p><strong>观察者模式</strong>大多数时候是<strong>同步</strong>的，比如当事件触发，Subject就会去调用观察者的方法。而<strong>发布-订阅</strong>模式大多数时候是<strong>异步的</strong>（使用消息队列）。</p><p><img src="https://codingwithalice.github.io/img/assets_2019/1568963964686.png" alt="1568963964686"></p><h5 id="1-2-数据无法双向绑定的情况"><a href="#1-2-数据无法双向绑定的情况" class="headerlink" title="1.2 数据无法双向绑定的情况"></a>1.2 数据无法双向绑定的情况</h5><p><strong>Object.freeze(); 或者 数据未在实例中进行初始化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;  foo: &apos;bar&apos;&#125;</span><br><span class="line">Object.freeze(obj)</span><br><span class="line">new Vue(&#123;  el: &apos;#app&apos;,  data: obj&#125;)</span><br></pre></td></tr></table></figure><p>Object.freeze()方法有三个特点：</p><p>1.使对象不可扩展，无法向其添加新属性。</p><p>2.为对象的所有属性将 <strong>configurable</strong> 特性设置为 <strong>false</strong>。在 <strong>configurable</strong> 为 <strong>false</strong> 时，无法更改属性的特性且无法删除属性。</p><p>3.为对象的所有数据属性将 <strong>writable</strong> 特性设置为 <strong>false</strong>。当 <strong>writable</strong> 为 false 时，无法更改数据属性值。</p><p><strong>数据未在实例中进行初始化</strong></p><p>只有当实例被创建时 <code>data</code> 中存在的属性才是<strong>响应式</strong>的。也就是说如果你添加一个新的属性在created生命周期完成后，那么数据将无法进行绑定，如直接使用vm.a=”xxx”，虽然a成了实例的一个属性，但是对它的任何修改将不是响应式的</p><h4 id="2-vue组件之间的传值？"><a href="#2-vue组件之间的传值？" class="headerlink" title="2. vue组件之间的传值？"></a>2. vue组件之间的传值？</h4><ol><li><p>父传子： 先在<strong>父组件中绑定变量<child :msg="parent"></child></strong>，parent是定义在父组件中的变量/值； 再在<strong>子组件中添加props属性接收</strong>父组件传递过来的变量<code>props:[&#39;msg&#39;]</code>； 最后就可以在子组件中使用``来表示父组件中parent变量中的值了。</p></li><li><p>子传父： 先在子组件中<strong>绑定事件@change=”sendChild”</strong>，触发的时候在<code>setChild</code>事件中<strong>用$emit()触发父组件中的函数</strong>，并将子组件中的变量作为参数传递；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods：&#123;</span><br><span class="line">    sendChild:function()&#123;</span><br><span class="line">        this.$emit(&apos;transparent&apos;,this.msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在父组件中绑定事件<code>&lt;child @transparent=&quot;getChild&quot;&gt;&lt;/child&gt;</code>，当子组件触发这个事件的时候，就可以<strong>调用getChild方法获取到传递过来的参数</strong>；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    getChild(msg)&#123;</span><br><span class="line">        this.user=msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.兄弟组件互相传值，<strong>通过Vuex状态管理传值</strong>： 先通过npm加载vuex，创建store.js文件</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//store.js</span><br><span class="line">   import Vue from &apos;vue&apos;</span><br><span class="line">   import Vuex from &apos;vuex&apos;</span><br><span class="line">   Vue.use(Vuex);</span><br><span class="line">   const state=&#123;name:&apos;Alice&apos;&#125;;</span><br><span class="line">   const mutations=&#123;</span><br><span class="line">       newName(state,message)&#123;</span><br><span class="line">           state.name=message</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   export default new Vuex.Store(&#123;state,mutations&#125;)</span><br></pre></td></tr></table></figure><p>2.兄弟组件互相传值，引入bus.js文件，发布者订阅者模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Bus from &apos;./bus.js&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//一个子组件触发</span><br><span class="line">methods:&#123;</span><br><span class="line">  Bus.$emit(&apos;触发的方法名&apos;，需要传递的值);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//一个子组件监听</span><br><span class="line">   mounted:&#123;</span><br><span class="line">       bus.$on(&quot;方法名&quot;,(传递的值)=&gt;&#123; &#125;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>3.兄弟组件互相传值<code>$root</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//一个子组件触发</span><br><span class="line">this.$root.$emit(&apos;触发的方法名&apos;，需要传递的值);</span><br><span class="line">//一个子组件监听</span><br><span class="line">this.$root.$off(&quot;方法名&quot;);//每次进入先关闭一下</span><br><span class="line">this.$root.$on(&quot;方法名&quot;,(传递的值)=&gt;&#123; &#125;)</span><br></pre></td></tr></table></figure><h4 id="3-vue的生命周期有哪些？它们有什么不同？"><a href="#3-vue的生命周期有哪些？它们有什么不同？" class="headerlink" title="3.vue的生命周期有哪些？它们有什么不同？"></a>3.vue的生命周期有哪些？它们有什么不同？</h4><table><thead><tr><th>生命周期钩子</th><th>组件状态</th><th>响应类型</th><th>最佳实践</th></tr></thead><tbody><tr><td>beforeCreate</td><td>实例初始化之后，this指向创建的实例，不能访问到data、computed、watch、methods（都不存在）上的方法和数据</td><td>拿不到任何信息，无法篡改数据，一般做loding，这个时候的vue实例还什么都没有，但是$route对象是存在的，可以根据路由信息进行重定向之类的操作。</td><td>常用于初始化非响应式变量</td></tr><tr><td>created</td><td>实例创建完成，可访问data、computed、watch、methods上的方法和数据，还未挂载到DOM，不能访问到$el属性，$ref属性内容为空数组</td><td>$el,没有初始化，数据已加载完成，可以篡改数据，并更新，不会触发beforeUpdate，updated，在这结束loading，还做一些初始化，实现函数自执行 ，$ref属性内容为空数组；定义getter、setter存储器属性，在实例创建之后被调用，该阶段可以访问data，<strong>可以使用this</strong>。该阶段允许执行http请求操作。</td><td>常用于<strong>简单的ajax请求</strong>，页面的初始化</td></tr><tr><td>beforeMount</td><td>在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数</td><td>$el已被初始化，数据已加载完成，阔以篡改数据，并更新，不会触发beforeUpdate，updated。将HTML解析生成AST节点，再根据AST节点动态生成渲染函数。<strong>相关render函数首次被调用</strong>(划重点)。</td><td>-</td></tr><tr><td>mounted</td><td>实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问</td><td>$el已被初始化，数据已加载完成，阔以篡改数据，并更新，并且触发beforeUpdate，updated，在这发起后端请求，拿回数据，配合路由钩子做一些事情；在挂载完成之后被调用，执行render函数生成虚拟dom，创建真实dom替换虚拟dom，并挂载到实例。可以操作dom，比如事件监听</td><td>常用于获取信息和操作，<strong>ajax请求</strong></td></tr><tr><td>beforeUpdate</td><td>响应式数据更新时调用，发生在虚拟DOM打补丁之前</td><td>$vm.data更新之后，虚拟dom重新渲染之前被调用。在这个钩子可以修改$vm.data，并不会触发附加的重渲染过程。</td><td>适合在<strong>更新之前访问</strong>现有的DOM，比如手动移除已添加的事件监听器</td></tr><tr><td>updated</td><td>虚拟DOM重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作</td><td>虚拟dom重新渲染后调用，若再次修改$vm.data，会再次触发beforeUpdate、updated，进入死循环</td><td>避免在这个钩子函数中操作数据，可能<strong>陷入死循环</strong></td></tr><tr><td>beforeDestroy</td><td>实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例</td><td></td><td><strong>常用于销毁</strong>定时器、解绑全局事件、销毁插件对象等操作</td></tr><tr><td>destroyed</td><td>实例销毁后调用，调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁</td><td></td><td>-</td></tr></tbody></table><p>注：</p><p>created和mounted之间的区别：</p><ul><li><p>created和mounted中<strong>ajax请求</strong>的区别：created的时候视图未出现，请求较多的情况下，会出现<strong>白屏</strong>；</p></li><li><p>created 是在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图，比如初始化、获取屏幕高度调整、赋值等等；</p><p>而mounted是在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作；</p></li></ul><ol><li>初始化组件的时候，仅执行beforeCreated/created/beforeMount/mounted四个钩子函数；</li><li>当改变data中定义的<strong>响应式变量</strong>时，会执行beforeUpadate/updated；</li><li>初始化和销毁时的钩子函数只会执行一次，beforeUpadate/updated<strong>可执行多次</strong>；</li><li>挂载的时候，子组件完成挂载后，父组件才会挂载；</li><li>当子组件完成挂载后，父组件会<strong>主动执行一次</strong>beforeUpdate/updated钩子函数（仅首次）；</li><li>销毁父组件时，先将子组件销毁后，才会销毁父组件；</li><li>总结来说，虚拟dom开始渲染是在beforeMount时，dom实例挂载完成在mounted阶段显示。那么接下来了解就是render函数。render函数最终返回的是createNodeDescription(节点描述)，即俗称virtual node(虚拟节点)。</li></ol><h4 id="4-vuex的功能？能否进行兄弟组件之间的传值？"><a href="#4-vuex的功能？能否进行兄弟组件之间的传值？" class="headerlink" title="4. vuex的功能？能否进行兄弟组件之间的传值？"></a>4. vuex的功能？能否进行兄弟组件之间的传值？</h4><p>vuex专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它<strong>采用集中式存储管理应用的所有组件的状态</strong>，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p>主要用于管理vue中的数据，可以兄弟组件互相传值；</p><p><img src="https://codingwithalice.github.io/img/assets_2019/vuex.png" alt="img"></p><p>上图的解释：</p><p>① <strong>Vue Components</strong> 是我们的 <strong>vue 组件</strong>，<strong>组件</strong>会触发（dispatch）一些事件或动作( <strong>Actions</strong>); ② 我们在<strong>组件</strong>中发出的动作，肯定是想获取或者改变数据的，但是在 <strong>vuex</strong> 中，数据是集中管理的，我们不能直接去更改数据，所以会把这个动作提交（Commit）到 <strong>Mutations</strong> 中； ③ 然后 <strong>Mutations</strong> 就去改变（Mutate）<strong>State</strong> 中的数据； ④ 当 <strong>State</strong> 中的数据被改变之后，就会重新渲染（Render）到 <strong>Vue Components</strong> (组件)中去， <strong>Vue Components</strong> (组件)展示更新后的数据，完成一个流程。</p><p><strong>Vuex 的核心是 Store</strong>（仓库），相当于是一个容器，一个<strong>Store实例中包含以下属性的方法：</strong></p><p><strong>state</strong> 定义属性（状态 、数据） <strong>getters</strong> 用来获取属性【就像计算属性，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算；getter 接受 state 作为其第一个参数；】 <strong>actions</strong> 定义方法（动作）【也可以直接修改state，<strong>通过提交 mutation 的方式</strong>，而非直接改变 <code>this.$store.state.count</code>，是因为我们想要更明确地追踪到状态的变化；】 <strong>commit</strong> 提交变化，修改数据的唯一方式就是显示的提交 mutations <strong>mutations</strong> 定义变化，处理状态（数据）的改变【操作state中的数据<code>store.commit(&#39;increment&#39;)</code>；】 <strong>mapGetters</strong> 用来获取属性（数据） <strong>mapActions</strong> 用来获取方法（动作）state：管理项目的数据（进行数据初始化）；</p><p><strong>mutation和action之间有什么区别？怎么写代码修改vuex中的数据？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  actions,</span><br><span class="line">  mutation</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>action可以包含任意异步操作，提交的是mutation，而不是直接变更状态；</p><p>mutation是同步的。使用<code>this.$store.commit(&#39;xxx&#39;)</code> 来提交mutation。</p><p>（下文来自尤大大）</p><p>区分 actions 和 mutations 并不是为了解决竞态问题，而是<strong>为了能用 devtools 追踪状态变化</strong>。</p><p>事实上在 vuex 里面 actions 只是一个架构性的概念，并不是必须的，说到底只是一个函数，你在里面想干嘛都可以，只要<strong>最后触发 mutation 就行</strong>。异步竞态怎么处理那是用户自己的事情。vuex 真正限制你的只有 <strong>mutation 必须是同步的</strong>这一点（在 redux 里面就好像 reducer 必须同步返回下一个状态一样）。</p><p><strong>同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态</strong>（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。</p><p>如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app1&quot;&gt;</span><br><span class="line">    8</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//store.js</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import Vuex from &apos;vuex&apos;;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        count:0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el:&apos;#app1&apos;,</span><br><span class="line">    store,</span><br><span class="line">    computed:&#123;</span><br><span class="line">        count()&#123;</span><br><span class="line">            return this.$store.state.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="4-1vuex的使用"><a href="#4-1vuex的使用" class="headerlink" title="4.1vuex的使用"></a>4.1vuex的使用</h5><p>需要在根实例main.js中传入store</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import store from &apos;./store&apos;</span><br><span class="line">import &apos;styles/reset.css&apos;</span><br><span class="line">import &apos;styles/border.css&apos;</span><br><span class="line">import &apos;styles/iconfont.css&apos;</span><br><span class="line">import &apos;swiper/dist/css/swiper.css&apos;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line">fastClick.attach(document.body)</span><br><span class="line">Vue.use(VueAwesomeSwiper)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>写在一个页面上的话，需要判断本地是否已经有这个数据了</p><p><img src="https://codingwithalice.github.io/img/assets_2019/1567605439082.png" alt="1567605439082"></p><p>在src–store–index.js中声明state、mutations</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line">import state from &apos;./state&apos;</span><br><span class="line">import mutations from &apos;./mutations&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  mutations</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后在src–store–state.js中声明公共使用的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let defaultCity = &apos;上海&apos;</span><br><span class="line">try &#123;</span><br><span class="line">  if (localStorage.city) &#123;</span><br><span class="line">    defaultCity = localStorage.city</span><br><span class="line">  &#125;</span><br><span class="line">&#125; catch (e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  city: defaultCity //调用的时候，调用city就可以了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在src–store–mutations.js中声明改变公共变量的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  changeCity (state, city) &#123; //调用的时候使用changeCity就可以了</span><br><span class="line">    state.city = city</span><br><span class="line">    try &#123;</span><br><span class="line">      localStorage.city = city</span><br><span class="line">    &#125; catch (e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际使用的页面中，就可以直接使用了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 调用数据</span><br><span class="line">this.$store.state.city</span><br><span class="line">//修改store中的内容</span><br><span class="line">this.$store.dispatch(&apos;name&apos;,value)</span><br><span class="line">//或者直接使用commit进行修改</span><br><span class="line">this.$store.commit(&apos;name&apos;,value)</span><br></pre></td></tr></table></figure><h4 id="5-Axios调取数据？"><a href="#5-Axios调取数据？" class="headerlink" title="5. Axios调取数据？"></a>5. Axios调取数据？</h4><p>[页面直接引用 <code>&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</code>]</p><h5 id="5-1-axios的特性"><a href="#5-1-axios的特性" class="headerlink" title="5.1 axios的特性"></a>5.1 axios的特性</h5><p>1.可以从浏览器中创建XHR对象 2、可以从nodeJS中创建HTTP请求 3、支持Promise 4、可以拦截请求和响应 5、可以转换请求数据和响应数据 6、可以取消请求 7、可以自动转换JSON数据 8、客户端支持防御XSRF</p><p><strong>axios get 方法</strong>：仅仅请求后台数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&apos;index.php&apos;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><strong>aixos post方法</strong>：post请求更多的是要提交数据，params属性里的数据会出现在请求主体中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(&apos;/user&apos;, &#123;</span><br><span class="line">    firstName: &apos;Fred&apos;,</span><br><span class="line">    lastName: &apos;Flintstone&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><strong>多并发请求,一次性发几个请求</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getUserAccount() &#123;</span><br><span class="line">  return axios.get(&apos;/user/12345&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getUserPermissions() &#123;</span><br><span class="line">  return axios.get(&apos;/user/12345/permissions&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .then(axios.spread(function (acct, perms) &#123;</span><br><span class="line">    // acct为第一个请求的结果，perms为第二个请求的结果</span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure><p><strong>设置拦截器</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//请求拦截器</span><br><span class="line">axios.interceptors.request.use(  </span><br><span class="line">        config =&gt; &#123;</span><br><span class="line">            btn.innerHTML=&apos;请求数据中&apos;;</span><br><span class="line">            return config;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 错误时发生的事情</span><br><span class="line">        err =&gt; &#123;</span><br><span class="line">            console.log(err)</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 响应应拦截器</span><br><span class="line">       axios.interceptors.response.use(</span><br><span class="line">       config =&gt; &#123;</span><br><span class="line">           btn.innerHTML=&apos;请求数据成功&apos;;</span><br><span class="line">           return config;</span><br><span class="line">       &#125;,</span><br><span class="line">       // 错误时发生的事情</span><br><span class="line">       err =&gt; &#123;</span><br><span class="line">           console.log(err)</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p><strong>设置自定义请求头</strong>：</p><p>先安装Axios：<code>npm install axios --save</code></p><p>再在main.js中引入Axios：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">Vue.prototype.$http = axios;</span><br></pre></td></tr></table></figure><p>即可在组件中调用Axios：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this.$axios.get(&apos;index.php/url&apos;)</span><br><span class="line">  .then(response =&gt; &#123;</span><br><span class="line">    console.log(response)</span><br><span class="line">  &#125;).catch(error =&gt; &#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>然后设置自定义的头请求：</p><p><code>axios.defaults.timeout = 5000;//请求超时的时间设定</code></p><p><code>axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/json&#39;; //axios默认的请求方式</code></p><p><code>axios.defaults.baseURL = &#39;http://localhost:8008&#39;;//axios默认的请求地址</code></p><p><code>axios.defaults.headers.common[&quot;token&quot;] = &quot;noname&quot;;//有些接口必须登录才可以调用，而登陆注册并未写好，后台给了一个故固定的token，写在了头里面</code></p><h4 id="6-vue使用的UI框架？"><a href="#6-vue使用的UI框架？" class="headerlink" title="6. vue使用的UI框架？"></a>6. vue使用的UI框架？</h4><p><strong>animate.css</strong>是一款前端动画库，相似的有velocity-animate；</p><p>（element ui框架的按钮组件；</p><p> iView 是一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品</p><p> Vuetify.js根据材料设计规格提供 UI 布局；</p><p> 基于 Vue.js 的 Bootstrap 组件；</p><p> cube-ui 是滴滴团队开发的基于 Vue.js 实现的精致移动端组件库；</p><p> vue-beauty 是一套基于 vue.js 和 ant-design样式 的PC端 UI 组件库；</p><p> AT-UI 是一个模块化的前端 UI 框架，基于Vue.js 的快速和强大的 Web 界面；专门为桌面应用程序构建；</p><p> Vue-Blu是基于Vue.js和Bulma开发的开源UI组件库。旨在为PC端的前端开发(特别是中后台产品)提供一个快速且灵活的解决方案。）</p><p><strong>使用步骤：</strong></p><ol><li><strong>首先npm install animate.css –save；</strong></li><li>然后在vue文件的script中<strong>引入import animate from ‘animate.css’；</strong></li><li>最后<strong>绑定元素使用</strong>，如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;song&quot;&gt;</span><br><span class="line">        &lt;p id=&quot;f&quot; @click=&apos;fade&apos;&gt;hello&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    fade:function()&#123;</span><br><span class="line">        $(&apos;#f&apos;).addClass(&apos;animated bounceOutLeft&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分api常见：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">fade: &#123;</span><br><span class="line">       title: &apos;淡入淡出&apos;,</span><br><span class="line">       fadeIn: &apos;淡入&apos;,</span><br><span class="line">       fadeOut: &apos;淡出&apos;,</span><br><span class="line">     &#125;,</span><br><span class="line">     bounce: &#123;</span><br><span class="line">       title: &apos;弹跳类&apos;,</span><br><span class="line">       bounceIn: &apos;弹跳进入&apos;,</span><br><span class="line">       bounceOut: &apos;弹跳退出&apos;,</span><br><span class="line">     &#125;,</span><br><span class="line">     zoom: &#123;</span><br><span class="line">       title: &apos;缩放类&apos;,</span><br><span class="line">       zoomIn: &apos;放大进入&apos;,</span><br><span class="line">       zoomOut: &apos;缩小退出&apos;,</span><br><span class="line"></span><br><span class="line">     &#125;,</span><br><span class="line">     rotate: &#123;</span><br><span class="line">       title: &apos;旋转类&apos;,</span><br><span class="line">       rotateIn: &apos;顺时针旋转进入&apos;,</span><br><span class="line">     &#125;,</span><br><span class="line">     flip: &#123;</span><br><span class="line">       title: &apos;翻转类&apos;,</span><br><span class="line">     &#125;,</span><br><span class="line">     strong: &#123;</span><br><span class="line">       title: &apos;强调类&apos;,</span><br><span class="line">       bounce: &apos;弹跳&apos;,</span><br><span class="line">       flash: &apos;闪烁&apos;,</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h4 id="7-v-if和v-show之间的区别？"><a href="#7-v-if和v-show之间的区别？" class="headerlink" title="7.v-if和v-show之间的区别？"></a>7.v-if和v-show之间的区别？</h4><p> 相同点：v-if与v-show都可以动态控制dom元素显示隐藏</p><p> 不同点：</p><p>实现<strong>本质方法</strong>区别</p><ul><li>vue-show本质就是标签<code>display:为none;</code>，控制隐藏，DOM结构是一直存在的</li><li>vue-if是动态的向DOM树内<strong>添加或者删除DOM元素</strong></li></ul><p>编译的区别</p><ul><li>v-show其实就是在<strong>控制css</strong></li><li>v-if切换有一个局部编译/卸载的过程，切换过程中合适地<strong>销毁和重建内部的事件监听和子组件</strong></li></ul><p>编译的条件</p><ul><li>v-show<strong>都会编译</strong>，初始值为false，只是将display设为none，但它也编译了</li><li>v-if初始值为false，就不会编译了</li></ul><p>性能</p><ul><li>v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，故<strong>v-show性能更好一点</strong>。</li></ul><h4 id="8-v-for中key值的作用？"><a href="#8-v-for中key值的作用？" class="headerlink" title="8.v-for中key值的作用？"></a>8.v-for中key值的作用？</h4><p> key的作用主要是为了<strong>高效的更新虚拟DOM</strong>。另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以<strong>区分它们</strong>，否则vue只会替换其内部属性而不会触发过渡效果。</p><p> 在用v-for更新已渲染的元素列表的时候，会使用<strong>就地复用</strong>的策略；这就是说列表数据修改的时候，他会根据key值去判断某个值是否修改，如果修改了就重新渲染，不然就复用之前的元素。</p><h4 id="9-vue中插槽的作用？"><a href="#9-vue中插槽的作用？" class="headerlink" title="9.vue中插槽的作用？"></a>9.vue中插槽的作用？</h4><p> 插槽就是Vue实现的一套<strong>内容分发的API</strong>，将<code>&lt;slot&gt;&lt;/slot&gt;</code>元素作为承载分发内容的出口，没有插槽的情况下在组件标签内些一些内容是不起任何作用的。</p><p> 插槽内可以是任意内容。在<code>&lt;child-component&gt;你好&lt;/child-component&gt;</code>内放置一些内容，输出内容还是在组件中的内容，直接在父组件的<code>&lt;child-component&gt;</code>标签中定义的内容不会被渲染。<strong>在子组件template中加入<slot>元素占位，便能渲染父组件<child>标签下的内容</child></slot></strong>。</p><p> <strong>具名插槽</strong>，当需要多个插槽时，可以使用<code>&lt;slot&gt;</code>的特性：name。这个特性可以用来定义额外的插槽。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;root&quot;&gt;</span><br><span class="line">       &lt;child&gt;</span><br><span class="line">           &lt;header slot=&quot;header&quot;&gt;header&lt;/header&gt;</span><br><span class="line">           &lt;footer slot=&quot;footer&quot;&gt;footer&lt;/footer&gt;</span><br><span class="line">       &lt;/child&gt;</span><br><span class="line">   &lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">      Vue.component(&apos;child&apos;,&#123;</span><br><span class="line">           template:`&lt;div&gt;</span><br><span class="line">                           &lt;slot name=&quot;header&quot;&gt;default header&lt;/slot&gt;</span><br><span class="line">                           &lt;div&gt;content&lt;/div&gt;</span><br><span class="line">                           &lt;slot name=&quot;footer&quot;&gt;default footer&lt;/slot&gt;</span><br><span class="line">                       &lt;/div&gt;`</span><br><span class="line">           &#125;</span><br><span class="line">       )</span><br><span class="line">       var vm=new Vue(&#123;</span><br><span class="line">           el:&apos;#root&apos;</span><br><span class="line">       &#125;)</span><br><span class="line">//输出结果是 header   content   footer</span><br></pre></td></tr></table></figure><p> <strong>插槽默认内容</strong> ，插槽可以提供一个默认内容，如果如果父组件没有为这个插槽提供了内容，会显示默认的内容。如果父组件为这个插槽提供了内容，则默认的内容会被替换掉。</p><p> <strong>作用域插槽</strong>，作用域插槽就是父组件在<strong>调用子组件的时候给子组件传了一个插槽</strong>，这个插槽为作用域插槽，该插槽必须放在template标签里面，同时声明从子组件接收的数据放在一个自定义属性内，并定义该数据的渲染方式。（解决的问题：调用了两次child组件，因为调用的是同一个子组件，所以显示的内容完全一样。如何在每次调用时能有各自的渲染效果？）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;root&quot;&gt;</span><br><span class="line">       &lt;child&gt;</span><br><span class="line">           &lt;template slot-scope=&quot;props&quot;&gt;&lt;!--该插槽必须放在template标签内--&gt;</span><br><span class="line">               &lt;li&gt;&lt;/li&gt; &lt;!--定义渲染方式--&gt;</span><br><span class="line">           &lt;/template&gt;</span><br><span class="line">       &lt;/child&gt;</span><br><span class="line">       &lt;child&gt;</span><br><span class="line">           &lt;template slot-scope=&quot;props&quot;&gt;</span><br><span class="line">               &lt;h1&gt;&lt;/h1&gt;&lt;!--定义渲染方式--&gt;</span><br><span class="line">           &lt;/template&gt;</span><br><span class="line">       &lt;/child&gt;</span><br><span class="line">   &lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;child&apos;,&#123;</span><br><span class="line">            data: function()&#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    list:[1,2,3,4]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            template: `&lt;div&gt;</span><br><span class="line">                            &lt;ul&gt;</span><br><span class="line">                                &lt;slot v-for=&quot;value in list&quot; :value=value&gt;//使用slot占位</span><br><span class="line">                                &lt;/slot&gt;</span><br><span class="line">                            &lt;/ul&gt;</span><br><span class="line">                        &lt;/div&gt;`</span><br><span class="line">        &#125;)</span><br><span class="line">        var vm=new Vue(&#123;</span><br><span class="line">            el: &apos;#root&apos;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><h4 id="10-vue中watch和computed有什么区别？分别在哪种场合下使用？监听的是data里面的值吗？"><a href="#10-vue中watch和computed有什么区别？分别在哪种场合下使用？监听的是data里面的值吗？" class="headerlink" title="10.vue中watch和computed有什么区别？分别在哪种场合下使用？监听的是data里面的值吗？"></a>10.vue中watch和computed有什么区别？分别在哪种场合下使用？监听的是data里面的值吗？</h4><table><thead><tr><th>computed 计算属性</th><th>watch 观察的动作</th><th>methods</th></tr></thead><tbody><tr><td>1. 数据会被缓存，只要依赖不发生改变，即使页面重新渲染，该方法也不会被调用 2.computed中的函数必须用return返回</td><td>1. 直接监测一个值的变化，监测值不发生变化，该方法就不会调用； 2. watch只会监听数据的值是否发生改变，而不会去监听数据的地址是否发生改变。也就是说，watch想要监听引用类型数据的变化，需要进行深度监听。 3.watch中的函数有两个参数，前者是newVal，后者是oldVal。</td><td>每次页面发生渲染，都会被重新调用</td></tr><tr><td>在computed中不要对data中的属性进行赋值操作。如果对data中的属性进行赋值操作了，就是data中的属性发生改变，从而触发computed中的函数，形成死循环了。</td><td>监听复杂数据类型需用深度监听（在被监听对象中使用<code>handler</code>）；特殊情况下，watch无法监听到数组的变化，特殊情况就是说更改数组中的数据时，数组已经更改，但是视图没有更新。<strong>更改数组必须要用splice()或者$set</strong>。</td><td></td></tr><tr><td>使用场景：<strong>当一个值受多个属性影响的时候————购物车商品结算</strong></td><td>使用场景：<strong>当一条数据的更改影响到多条数据的时候———搜索框</strong></td><td></td></tr></tbody></table><p><strong>computed和watch区别：</strong></p><p>1、 功能上：computed是计算属性，也就是依赖其它的属性计算所得出最后的值，是用于定义<strong>基于数据之上的数据</strong>。watch是监听一个值的变化，然后执行对应的回调，是在<strong>某个数据变化时做一些事情</strong>。</p><p>2、 <strong>是否调用缓存</strong>：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调。</p><p>3、 <strong>是否调用return</strong>：computed中的函数必须要用return返回，watch中的函数不是必须要用return。</p><p>4、 如果一个值依赖多个属性（多对一），用<code>computed</code>肯定是更加方便的。如果一个值变化后会引起一系列操作，或者一个值变化会引起一系列值的变化（一对多），用<code>watch</code>更加方便一些。</p><h4 id="11-数据请求应该添加在生命周期的哪里？"><a href="#11-数据请求应该添加在生命周期的哪里？" class="headerlink" title="11.数据请求应该添加在生命周期的哪里？"></a>11.数据请求应该添加在生命周期的哪里？</h4><p> 看实际情况，一般在 created（或beforeRouter） 里面就可以，如果涉及到需要页面加载完成之后的话就用 mounted。主要的区分在于<strong>是否需要操作DOM结构</strong>。 1.在created的时候，视图中的html并没有渲染出来，所以此时如果直接去操作html的dom节点，一定找不到相关的元素； 2.而在mounted中，由于此时html已经渲染出来了，所以可以直接操作dom节点，（此时document.getelementById 即可生效了）；</p><h4 id="12-vue组件中data为什么是函数"><a href="#12-vue组件中data为什么是函数" class="headerlink" title="12.vue组件中data为什么是函数"></a>12.vue组件中data为什么是函数</h4><p>是因为js本身的特性带来的，跟vue本身设计无关。类比引用数据类型：Object是引用数据类型,如果不用function 返回,每个组件的data 都是内存的同一个地址,一个数据改变了其他也改变了;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//如果直接赋值，两个实例同时引用一个对象，那么当你修改其中一个属性的时候，另外一个实例也会跟着改</span><br><span class="line">var MyComponent = function() &#123;&#125;</span><br><span class="line">MyComponent.prototype.data = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">&#125;</span><br><span class="line">// 上面是一个虚拟的组件构造器，真实的组件构造器方法很多</span><br><span class="line"></span><br><span class="line">var component1 = new MyComponent()</span><br><span class="line">var component2 = new MyComponent()</span><br><span class="line">// 上面实例化出来两个组件实例，也就是通过&lt;my-component&gt;调用，创建的两个实例</span><br><span class="line"></span><br><span class="line">component1.data.a === component2.data.a // true</span><br><span class="line">component1.data.b = 5;</span><br><span class="line">component2.data.b // 5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;OK&lt;/div&gt;&apos;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125; // 返回一个唯一的对象，不要和其他组件共用一个对象进行返回</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立,不会相互影响；</p><h4 id="13-多页应用与单页应用的区别？以及优缺点"><a href="#13-多页应用与单页应用的区别？以及优缺点" class="headerlink" title="13.多页应用与单页应用的区别？以及优缺点"></a>13.多页应用与单页应用的区别？以及优缺点</h4><p><strong>多页应用：</strong></p><ul><li>定义：每一次页面的跳转，后端都会返回一个新的html文件。</li></ul><p>优点：1. <strong>首屏事件快</strong>（只请求 html 文件就可以展示页面了，只经历了一个http请求）；2. SEO（<strong>搜索引擎优化</strong>，可以识别 html 内的内容）效果好。</p><p>缺点：页面切换<strong>慢</strong>（每次跳转都要发送一个http请求）</p><p><strong>单页应用：</strong></p><ul><li>定义：每一次页面的跳转，都是使用<code>JS</code>渲染。页面跳转不使用 a 标签，而是使用<code>&lt;router-link to=&quot;./list&quot;&gt;&lt;/router-link&gt;</code>，不请求<code>html</code>文件，通过<code>JS</code>感知到<code>URL</code>的变化，可以用<code>JS</code>动态得把当前页面清除掉，再把下一个页面挂载到当前页面上。</li></ul><p>优点：页面切换<strong>快</strong>。不需要http请求。</p><p>缺点：首屏时间稍慢（除了请求一个html文件，还要请求一个 JS 文件）; SEO差（不认识JS文件中的内容）</p><h4 id="13-vue-router-路由守卫-有哪些钩子函数，哪一个是可以在全局使用的"><a href="#13-vue-router-路由守卫-有哪些钩子函数，哪一个是可以在全局使用的" class="headerlink" title="13.vue router[路由守卫]有哪些钩子函数，哪一个是可以在全局使用的"></a>13.vue router[路由守卫]有哪些钩子函数，哪一个是可以在全局使用的</h4><p>主要用来作用是<strong>拦截导航，让他完成跳转或取消</strong>。</p><p><strong>完整的导航解析流程</strong></p><ol><li>导航被触发。</li><li>在失活的组件里调用离开守卫。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li><li>在路由配置里调用 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li><li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数。</li></ol><p><strong>有三种方式可以植入路由导航过程中：</strong>全局的；单个路由独享的；组件级的</p><p><strong>①.全局</strong>导航钩子</p><ol><li>router.beforeEach <strong>全局前置守卫</strong> 进入路由之前</li><li>router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用</li><li>router.afterEach 全<strong>局后置钩子</strong> 进入路由之后</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// main.js 入口文件</span><br><span class="line">import router from &apos;./router&apos;; // 引入路由</span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123; </span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line">router.beforeResolve((to, from, next) =&gt; &#123;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line">router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">  console.log(&apos;afterEach 全局后置钩子&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这三个参数 to 、from 、next 分别的作用：</p><p><strong>to</strong>: Route，代表<strong>要进入的目标</strong>，它是一个路由对象；路由对象指的是平时通过<strong>this.$route获取到的路由对象</strong>。</p><p><strong>from</strong>: Route，代表当前<strong>正要离开的路由</strong>，同样也是一个路由对象</p><p><strong>next</strong>: Function，这是一个<strong>必须需要调用的方</strong>法，而具体的执行效果则依赖 next 方法调用的参数</p><p> <strong>next()</strong>：进入该路由。进入管道中的下一个钩子，如果全部的钩子执行完了，则导航的状态就是 confirmed（确认的） <strong>next(false)</strong>：取消进入路由，这代表中断掉当前的导航，即 to 代表的路由对象不会进入，被中断，此时该表 URL 地址会被重置到 from 路由对应的地址(也就是将要离开的路由地址)。 <strong>next(‘/’)</strong> 和 <strong>next({path: ‘/’})</strong>：在中断掉当前导航的同时，跳转到一个不同的地址 <strong>next(error)</strong>：如果传入参数是一个 Error 实例，那么导航被终止的同时会将错误传递给 router.onError() 注册过的回调 注意：next 方法必须要调用，否则钩子函数无法 resolved</p><p>不同于前置守卫，后置钩子并没有 next 函数，也不会改变导航本身</p><p><strong>②.路由独享的钩子</strong>：即单个路由独享的导航钩子，它是在<strong>路由配置上直接进行定义</strong>的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    routes: [&#123;</span><br><span class="line">            path: &apos;/file&apos;,</span><br><span class="line">            component: File,</span><br><span class="line">            beforeEnter: (to, from ,next) =&gt; &#123;/*do someting*/&#125;</span><br><span class="line">        &#125;]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>③.组件内的导航钩子</strong>：<code>beforeRouteEnter</code>、<code>beforeRouteUpdate</code>、<code>beforeRouteLeave</code>。直接在路由组件内部直接进行定义的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const File = &#123;</span><br><span class="line">    template: `&lt;div&gt;This is file&lt;/div&gt;`,</span><br><span class="line">    beforeRouteEnter(to, from, next) &#123;</span><br><span class="line">        // do someting</span><br><span class="line">        // 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeRouteUpdate(to, from, next) &#123;</span><br><span class="line">        // do someting</span><br><span class="line">        // 在当前路由改变，但是依然渲染该组件是调用</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeRouteLeave(to, from ,next) &#123;</span><br><span class="line">        // do someting</span><br><span class="line">        // 导航离开该组件的对应路由时被调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>beforeRouteEnter</code> <strong>不能获取组件实例 this</strong>，因为当守卫执行前，组件实例被没有被创建出来，剩下两个钩子则可以正常获取组件实例 this；但是并不意味着在<code>beforeRouteEnter</code>中无法访问组件实例，我们可以通过给 next 传入一个回调来访问组件实例。在导航被确认是，会执行这个回调，这时就可以访问组件实例了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//注意，仅仅是 beforRouteEnter 支持给 next 传递回调，其他两个并不支持。因为归根结底，支持回调是为了解决 this 问题，而其他两个钩子的 this 可以正确访问到组件实例，所有没有必要使用回调</span><br><span class="line">beforeRouteEnter(to, from, next) &#123;</span><br><span class="line">    next (vm =&gt; &#123;/*这里通过 vm 来访问组件实例解决了没有 this 的问题*/&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-data为什么要用return？不是为了使每个组件有独立的数据？（摘自vue官方文档）"><a href="#14-data为什么要用return？不是为了使每个组件有独立的数据？（摘自vue官方文档）" class="headerlink" title="14.data为什么要用return？不是为了使每个组件有独立的数据？（摘自vue官方文档）"></a>14.data为什么要用return？不是为了使每个组件有独立的数据？（摘自vue官方文档）</h4><p>当一个<strong>组件</strong>被定义，<code>data</code> 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 <code>data</code> 仍然是一个纯粹的对象，则所有的实例将<strong>共享引用</strong>同一个数据对象！通过提供 <code>data</code> 函数，每次创建一个新实例后，我们能够调用 <code>data</code> 函数，从而返回初始数据的一个全新副本数据对象。</p><h4 id="15-vue中的定时器，一般在哪个生命周期中清除"><a href="#15-vue中的定时器，一般在哪个生命周期中清除" class="headerlink" title="15.vue中的定时器，一般在哪个生命周期中清除"></a>15.vue中的定时器，一般在哪个生命周期中清除</h4><p>在beforeDestroy（）里面清除定时器，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beforeDestroy() &#123;</span><br><span class="line">    clearInterval(this.timer);        </span><br><span class="line">    this.timer = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Vue
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vue中生成二维码</title>
    <link href="http://yoursite.com/2019/04/26/vue%E4%B8%AD%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>http://yoursite.com/2019/04/26/vue中生成二维码/</id>
    <published>2019-04-26T13:18:32.000Z</published>
    <updated>2020-02-03T04:09:06.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态创建二维码相关问题"><a href="#动态创建二维码相关问题" class="headerlink" title="动态创建二维码相关问题"></a>动态创建二维码相关问题</h2><h3 id="1-动态生成二维码"><a href="#1-动态生成二维码" class="headerlink" title="1. 动态生成二维码"></a>1. 动态生成二维码</h3><p>先在终端中安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install qrcodejs2</span><br></pre></td></tr></table></figure><p>然后在要生成二维码的页面中调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import QRCode from &apos;qrcodejs2&apos;</span><br></pre></td></tr></table></figure><p>然后在要展示二维码的结构处，为结构添加class属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;qrcode&quot; ref=&quot;qrCodeUrl&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>然后在<code>script</code>标签中添加方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">creatQrCode() &#123; // 创建一个实例对象</span><br><span class="line">var  qrcode = new QRCode(this.$refs.qrCodeUrl, &#123;</span><br><span class="line">text: &apos;https://www.qtshe.com&apos;,</span><br><span class="line">width: 100,height: 100,colorDark: &apos;#000000&apos;,colorLight: &apos;#ffffff&apos;,     </span><br><span class="line">correctLevel: QRCode.CorrectLevel.H </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>到此为止，二维码的功能代码已经写完，但是最后一个方法是需要调用的，否则就没有效果。</p><p>如果是在页面点击进来就要显示的话，就去<code>mounted(){}</code>钩子里面调用一下<code>this.creatQrCode();</code>，</p><p>如果是点击某个按钮等触发事件出现二维码的，只要在触发事件中绑定该方法即可。</p><h3 id="2-在二级弹窗中显示二维码"><a href="#2-在二级弹窗中显示二维码" class="headerlink" title="2.在二级弹窗中显示二维码"></a>2.在二级弹窗中显示二维码</h3><p>①如果使用对话框显示二维码，有时会由于<code>html</code>元素还没有创建，导致生成二维码时报对象不存在或者<code>appenchild</code>方法未定义的错误。这时可以<strong>使用nextTick来处理</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">showQRCode()&#123;      </span><br><span class="line">    this.$nextTick(()=&gt;&#123;/* 使用了nextTick之后，会在生成DOM元素之后绑定*/  </span><br><span class="line">        var qrcode = new QRCode(this.$refs.qrcodeContainer, &#123;              </span><br><span class="line">            text: &apos;https://wallimn.iteye.com&apos;,              </span><br><span class="line">            width: 100,              </span><br><span class="line">            height: 100,              </span><br><span class="line">            colorDark: &apos;#000000&apos;,              </span><br><span class="line">            colorLight: &apos;#ffffff&apos;,              </span><br><span class="line">            correctLevel: QRCode.CorrectLevel.H          </span><br><span class="line">        &#125;)      &#125;  &#125;</span><br></pre></td></tr></table></figure><p>②定义完方法后，<strong>只在点击出现对话框的时候，调用showQRCode的方法</strong>即可；可以不用在mounted里面进行调用。</p><p>③多次<strong>点击会出现多个二维码</strong>，这个时候要设置<code>this.$refs.qrCodeUrl.innerHTML=&#39;&#39;;</code>，保证每一次点击重新生成二维码之前，都已经将之前的清除了；</p><p>④在跳转前的页面 设置的地址如下<code>text:&quot;&#39;/qrcode/&#39; + id &quot;</code>, 到了跳转到的页面，可以通过<strong>this.$route.params.id 获取到url中的id值</strong></p>]]></content>
    
    <summary type="html">
    
      二维码
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
      <category term="二维码" scheme="http://yoursite.com/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Vue学习</title>
    <link href="http://yoursite.com/2019/04/07/Vue%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/04/07/Vue学习/</id>
    <published>2019-04-07T13:48:13.000Z</published>
    <updated>2020-01-30T14:35:16.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue学习"><a href="#Vue学习" class="headerlink" title="Vue学习"></a>Vue学习</h2><h3 id="1基本介绍"><a href="#1基本介绍" class="headerlink" title="1基本介绍"></a>1基本介绍</h3><h4 id="1-1为什么要学习流行框架"><a href="#1-1为什么要学习流行框架" class="headerlink" title="1.1为什么要学习流行框架"></a>1.1为什么要学习流行框架</h4><ul><li>企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱；</li></ul><ul><li>企业中，使用框架，能够提高开发的效率；</li></ul><ul><li><p>提高开发效率的发展历程：</p><p>原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率）</p></li></ul><h4 id="1-2什么是Vue-js"><a href="#1-2什么是Vue-js" class="headerlink" title="1.2什么是Vue.js"></a>1.2什么是Vue.js</h4><p><a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/api/</a></p><ul><li>ue.js是是一套用于构建用户界面的<strong>渐进式框架</strong>，是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex）</li><li>Vue.js 是前端的<strong>主流框架之一</strong>，和Angular.js、React.js 一起，并成为前端三大主流框架！</li><li>Vue.js 是一套构建用户界面的框架，<strong>只关注视图层</strong>，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）</li></ul><h4 id="1-3-MVC和MVVM"><a href="#1-3-MVC和MVVM" class="headerlink" title="1.3.MVC和MVVM"></a>1.3.MVC和MVVM</h4><ul><li><strong>MVC</strong><ul><li>M - Model ：数据保存</li><li>V - View : 用户界面</li><li>C - Controller ： 业务逻辑</li></ul></li></ul><p>用户操作–&gt; View (负责接受用户的输入操作)–&gt;Controller（业务逻辑处理）–&gt;Model（数据持久化）–&gt;View（将结果通过View反馈给用户）</p><p><img src="https://s2.ax1x.com/2020/01/30/11lYyn.png" alt></p><p><strong>MVC有两个很明显的问题：</strong></p><ol><li>m层和v层直接打交道，导致这两层耦合度高</li><li>因为所有逻辑都写在c层，导致c层特别臃肿</li></ol><ul><li><strong>MVC</strong></li></ul><p>前端应用的复杂程度已不同往日，暴露出了三个痛点问题：</p><ol><li>开发者在代码中大量调用相同的DOM API, 处理繁琐，操作冗余，使得代码难以维护。</li><li>大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</li><li>当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致Model发生变化，开发者同样需要将变化的数据同步到Model中， 这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。</li></ol><p><strong>MVVM 的出现，完美解决了以上三个问题，MVVM 包含的三部分：</strong></p><ul><li>Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；</li><li>View 代表UI 组件，它负责将数据模型转化成UI 展现出来</li><li>ViewModel 是一个同步View 和 Model的对象。View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互。ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图：</li></ul><h3 id="2-Vue使用"><a href="#2-Vue使用" class="headerlink" title="2.Vue使用"></a>2.Vue使用</h3><h4 id="2-1基本使用"><a href="#2-1基本使用" class="headerlink" title="2.1基本使用"></a>2.1基本使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;!-- 1. 导入Vue的包 --&gt;</span><br><span class="line">  &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- id=&quot;app&quot; : app指的是将来 new 的Vue实例，会控制这个元素中的所有内容 --&gt;</span><br><span class="line">  &lt;!-- Vue 实例所控制的这个元素区域，就是我们的 View  --&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    // 2. 创建一个Vue的实例，就是我们 MVVM中的 ViewModel</span><br><span class="line">    //  当我们导入包之后，在浏览器的内存中，就多了一个 Vue 构造函数</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">  // 表示当前我们 new 的这个 Vue 实例，要控制页面上的哪个区域</span><br><span class="line">      el: &apos;#app&apos;,  </span><br><span class="line">      // 这里的 data 就是 MVVM中的 Model，专门用来保存每个页面的数据的</span><br><span class="line">      data: &#123; </span><br><span class="line">// data 属性中，存放的是el中要用到的数据</span><br><span class="line">        msg: &apos;欢迎学习Vue&apos; // 通过 Vue 提供的指令，很方便的就能把数据渲染到页面上，</span><br><span class="line">        程序员不再手动操作DOM元素了【前端的Vue之类的框架，不提倡我们去手动操作DOM元素了】</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="2-2-常用指令"><a href="#2-2-常用指令" class="headerlink" title="2.2 常用指令"></a>2.2 常用指令</h4><ul><li>v-cloak</li><li>v-text</li><li>v-html</li><li>v-bind</li><li>v-on</li><li>v-model</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    [v-cloak] &#123;</span><br><span class="line">      display: none;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- 使用 v-cloak 能够解决 插值表达式闪烁的问题  </span><br><span class="line">    vue-2.4.0.js的加载需要时间，在vue-2.4.0.js没有成功加载之前，</span><br><span class="line">    页面会显示&#123; &#123;msg&#125;&#125;文本信息 --&gt;</span><br><span class="line">    &lt;p v-cloak&gt;++++++++ &#123;&#123; msg &#125;&#125; ----------&lt;/p&gt;</span><br><span class="line">    &lt;h4 v-text=&quot;msg&quot;&gt;==================&lt;/h4&gt;</span><br><span class="line">    &lt;!-- 默认 v-text 是没有闪烁问题的 --&gt;</span><br><span class="line">    &lt;!-- v-text会覆盖元素中原本的内容，但是插值表达式只会替换自己的这个占位符，</span><br><span class="line">    不会把整个元素的内容清空 --&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;msg2&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div v-text=&quot;msg2&quot;&gt;&lt;/div&gt;</span><br><span class="line"> &lt;!-- v-html会覆盖元素中原本的内容，只不过会将msg2当做html文本进行解析 --&gt;</span><br><span class="line">    &lt;div v-html=&quot;msg2&quot;&gt;1212112&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- v-bind: 是Vue中提供的用于绑定属性的指令，v-bind 中，可以写合法的JS表达式 --&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;按钮1&quot; v-bind:title=&quot;mytitle + &apos;123&apos;&quot;&gt; </span><br><span class="line">    &lt;!-- 注意： v-bind: 指令可以被简写为 :要绑定的属性 --&gt;</span><br><span class="line"> &lt;input type=&quot;button&quot; value=&quot;按钮2&quot; :title=&quot;mytitle + &apos;3455&apos;&quot;&gt; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- Vue 中提供了 v-on: 事件绑定机制</span><br><span class="line">          下面代码错误：因为vue会将alert理解为一个变量，而在Vue中我们并没有定义alert变量，</span><br><span class="line">          所以找不到--&gt;</span><br><span class="line">    &lt;!-- &lt;input type=&quot;button&quot; value=&quot;按钮3&quot; :title=&quot;mytitle + &apos;888&apos;&quot; v-on:click=&quot;alert(&apos;hello&apos;)&quot;&gt;--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--v-on:click可以简写成@click--&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;按钮4&quot; @click=&quot;show&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        msg: &apos;123&apos;,</span><br><span class="line">        msg2: &apos;&lt;h1&gt;哈哈，我是一个大大的H1， 我大，我骄傲&lt;/h1&gt;&apos;,</span><br><span class="line">        mytitle: &apos;这是一个自己定义的title&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123; </span><br><span class="line">        // 这个 methods属性中定义了当前Vue实例所有可用的方法</span><br><span class="line">        show: function () &#123;</span><br><span class="line">          alert(&apos;Hello&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">//在vue中不推荐我们再去使用dom操作的方法</span><br><span class="line">document.getElementById(&apos;btn&apos;).onclick = function()&#123;</span><br><span class="line">      alert(&apos;Hello&apos;)</span><br><span class="line">    &#125; */</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="2-3事件修饰符"><a href="#2-3事件修饰符" class="headerlink" title="2.3事件修饰符"></a>2.3事件修饰符</h4><ul><li>.stop       阻止冒泡</li><li>.prevent    阻止默认事件</li><li>.capture    添加事件侦听器时使用事件捕获模式</li><li>.self       只当事件在该元素本身（比如不是子元素）触发时触发回调</li><li>.once       事件只触发一次</li></ul><h4 id="2-4-v-model和双向绑定"><a href="#2-4-v-model和双向绑定" class="headerlink" title="2.4 v-model和双向绑定"></a>2.4 v-model和双向绑定</h4><ul><li>只有v-model指令实现了双向绑定， v-model 只能运用在表单元素中。如： input(radio, text, address, email….)   select    checkbox   textarea</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form id=&quot;app&quot; action=&quot;#&quot;&gt;</span><br><span class="line">    &lt;p&gt;&lt;input  v-model=&quot;email&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;input v-model=&quot;name&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;modify&quot;&gt;点我修改数据源&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;show&quot;&gt;改完表单再点我&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script src=&quot;lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        email: &apos;zhangsan@qq.com&apos;,</span><br><span class="line">        name: &apos;zhangsan&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods:&#123;</span><br><span class="line">      modify:function()&#123;</span><br><span class="line">      this.email = &apos;lisi@.qq.com&apos;;</span><br><span class="line">      &#125;,</span><br><span class="line">      show:function()&#123;</span><br><span class="line">      alert(this.email);</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="2-5-双向绑定的原理"><a href="#2-5-双向绑定的原理" class="headerlink" title="2.5 双向绑定的原理"></a>2.5 双向绑定的原理</h4><h5 id="2-5-1页面–-gt-数据"><a href="#2-5-1页面–-gt-数据" class="headerlink" title="2.5.1页面–&gt;数据"></a>2.5.1页面–&gt;数据</h5><p>view更新data只需要添加DOM事件监听即可，比如input标签监听 ‘input’ 事件就可以实现</p><h5 id="2-5-2数据–-gt-页面"><a href="#2-5-2数据–-gt-页面" class="headerlink" title="2.5.2数据–&gt;页面"></a>2.5.2数据–&gt;页面</h5><p>是通过数据劫持 + 发布者-订阅者模式的方式来实现的</p><h5 id="2-5-3数据劫持"><a href="#2-5-3数据劫持" class="headerlink" title="2.5.3数据劫持"></a>2.5.3数据劫持</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue是通过Object.defineProperty()来实现数据劫持的</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;&#125;</span><br><span class="line">Object.defineProperty(book, &apos;name&apos;, &#123;</span><br><span class="line">    set: function (value) &#123;</span><br><span class="line">        name = value;</span><br><span class="line">        console.log(&apos;你取了一个书名叫做&apos; + value);</span><br><span class="line">    &#125;,</span><br><span class="line">    get: function () &#123;</span><br><span class="line">        return &apos;《&apos; + name + &apos;》&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">book.name = &apos;vue权威指南&apos;;  // 你取了一个书名叫做vue权威指南</span><br><span class="line">book.name = &apos;vue权威指南2&apos;;  // 你取了一个书名叫做vue权威指南</span><br><span class="line">console.log(book.name);  // 《vue权威指南》</span><br></pre></td></tr></table></figure><h5 id="2-5-4发布订阅模式"><a href="#2-5-4发布订阅模式" class="headerlink" title="2.5.4发布订阅模式"></a>2.5.4发布订阅模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//1.消息订阅器，内部维护了所有订阅者的列表</span><br><span class="line">function Dep () &#123;</span><br><span class="line">    this.subs = [];</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">    addSub: function(sub) &#123;</span><br><span class="line">        this.subs.push(sub);</span><br><span class="line">    &#125;,</span><br><span class="line">    notify: function(value) &#123;</span><br><span class="line">        this.subs.forEach(function(sub) &#123;</span><br><span class="line">            sub.update(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var dep = new Dep();</span><br><span class="line"></span><br><span class="line">//2.订阅者</span><br><span class="line">function Watcher() &#123;</span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">    update: function(value)&#123;</span><br><span class="line">        console.log(&quot;数据源已经变动，新的数据是&quot;+value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var w1 = new Watcher();</span><br><span class="line">var w2 = new Watcher();</span><br><span class="line">dep.addSub(w1);</span><br><span class="line">dep.addSub(w2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//3.数据源，通过defineProperty监听数据源的变化</span><br><span class="line">var book = &#123;&#125;</span><br><span class="line">Object.defineProperty(book, &apos;name&apos;, &#123;</span><br><span class="line">    set: function (value) &#123;</span><br><span class="line">        name = value;</span><br><span class="line">        //一旦数据源发生变化了，通知所有的订阅者更新数据</span><br><span class="line">        dep.notify(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    get: function () &#123;</span><br><span class="line">        return &apos;《&apos; + name + &apos;》&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">book.name = &apos;vue权威指南&apos;;  // 你取了一个书名叫做vue权威指南</span><br><span class="line">book.name = &apos;vue权威指南2&apos;;  // 你取了一个书名叫做vue权威指南</span><br><span class="line">console.log(book.name);  // 《vue权威指南》</span><br></pre></td></tr></table></figure><h5 id="2-5-5数据绑定的实现流程"><a href="#2-5-5数据绑定的实现流程" class="headerlink" title="2.5.5数据绑定的实现流程"></a>2.5.5数据绑定的实现流程</h5><ol><li>首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。</li><li>因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。</li><li>接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。</li></ol><blockquote><p>1.监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知所有订阅者。</p><p>2.订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。</p><p>3.解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅者</p></blockquote><p><img src="https://s2.ax1x.com/2020/01/30/11UMTA.png" alt></p><h4 id="2-6vue样式操作"><a href="#2-6vue样式操作" class="headerlink" title="2.6vue样式操作"></a>2.6vue样式操作</h4><h5 id="2-6-1-class操作"><a href="#2-6-1-class操作" class="headerlink" title="2.6.1 class操作"></a>2.6.1 class操作</h5><ul><li><p>普通css</p><p><code>&lt;h1 class=&quot;red thin&quot;&gt;这是一个很大很大的H1&lt;/h1&gt;</code></p></li><li><p>vue第一种使用方式，直接传递一个数组,class需要使用  v-bind 做数据绑定</p><p><code>&lt;h1 :class=&quot;[&#39;thin&#39;, &#39;italic&#39;]&quot;&gt;这是一个很大很大的H1，&lt;/h1&gt;</code></p></li><li><p>在数组中使用三元表达式</p><p><code>&lt;h1 :class=&quot;[&#39;thin&#39;, &#39;italic&#39;, flag?&#39;active&#39;:&#39;&#39;]&quot;&gt;这是一个很大很大的H1&lt;/h1&gt;</code></p></li><li><p>在数组中使用对象来代替三元表达式，提高代码的可读性</p><p><code>&lt;h1 :class=&quot;[&#39;thin&#39;, &#39;italic&#39;, {&#39;active&#39;:flag} ]&quot;&gt;这是一个很大很大的H1&lt;/h1&gt;</code></p></li></ul><h5 id="2-6-2-style操作"><a href="#2-6-2-style操作" class="headerlink" title="2.6.2 style操作"></a>2.6.2 style操作</h5><p>​    <code>&lt;h1 :style=&quot;styleObj1&quot;&gt;标题1&lt;/h1&gt;</code></p><p>​    <code>&lt;h1 :style=&quot;[styleObj1,styleObj2]&quot;&gt;标题2&lt;/h1&gt;</code></p>]]></content>
    
    <summary type="html">
    
      Vue
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue结合webpack的使用</title>
    <link href="http://yoursite.com/2019/03/19/Vue%E7%BB%93%E5%90%88webpack%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/03/19/Vue结合webpack的使用/</id>
    <published>2019-03-19T11:18:44.000Z</published>
    <updated>2020-01-28T14:45:09.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue结合webpack的使用"><a href="#Vue结合webpack的使用" class="headerlink" title="Vue结合webpack的使用"></a>Vue结合webpack的使用</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#1.安装vue</span><br><span class="line">   运行npm i vue@2.3.4将vue安装为运行依赖</span><br><span class="line">   </span><br><span class="line">#2.main.js</span><br><span class="line">/*</span><br><span class="line"> 注意：在webpack中使用 import Vue from &apos;vue&apos;导入的Vue构造函数功能不完整，只提供了runtime-only的方式，并没有提供像网页中那样的使用方式；</span><br><span class="line"> import Vue from &apos;vue&apos; 导入包的规则：</span><br><span class="line">   1. 找项目根目录中有没有 node_modules 的文件夹</span><br><span class="line">   2. 在node_modules中根据包名，找对应的vue文件夹</span><br><span class="line">   3. 在vue文件夹中，找一个叫做 package.json 的包配置文件</span><br><span class="line">   4. 在package.json文件中，查找一个 main 属性【main属性指定了这个包在被加载时候的入口文件】，这里我们发现入口文件为vue.runtime.common.js，并不是vue.js文件</span><br><span class="line"></span><br><span class="line"> 解决方案有两种：</span><br><span class="line">   1.在webpack.config.js下新增配置：</span><br><span class="line">       resolve: &#123;</span><br><span class="line">            alias: &#123;</span><br><span class="line">                &apos;vue$&apos;: &apos;vue/dist/vue.js&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        然后使用 import Vue from &apos;vue&apos;  就可以了</span><br><span class="line">        </span><br><span class="line">   2.手动修改导包的路径为：import Vue from &apos;vue/dist/vue&apos;&apos;，此时无需修改配置文件</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">var login = &#123;</span><br><span class="line">   template: &apos;&lt;h1&gt;这是login组件，是使用网页中形式创建出来的组件&lt;/h1&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        msg: &apos;123&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        login</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">#3.index.html</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;login&gt;&lt;/login&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">#4.webpack.config.js</span><br><span class="line">resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">        &apos;vue$&apos;: &apos;vue/dist/vue.js&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#5.package.json、.babelrc还有webpack的所需要安装的内容和之前一致</span><br></pre></td></tr></table></figure><h3 id="2-使用-vue的方式生成组件"><a href="#2-使用-vue的方式生成组件" class="headerlink" title="2.使用.vue的方式生成组件"></a>2.使用.vue的方式生成组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vscode中安装vetur插件，可以格式化html、标准css（有分号 、大括号的那种）、标准js（有分号 、双引号的那种）、vue文件webstorm中支持vue文件的提示，需要安装插件</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#1. 新建login.vue文件</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;这是登录组件，使用 .vue 文件定义出来的 &lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2.main.js引入.vue文件，并使用</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">import login from &apos;./login.vue&apos;</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        msg: &apos;123&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        login</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">#3. index.html</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;login&gt;&lt;/login&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">#4.安装vue-loader和 vue-template-compiler(默认情况下不支持import方式引入.vue文件，需要安装下面两个文件)</span><br><span class="line">npm i vue-loader@15.4.2 vue-template-compiler@2.3.4</span><br><span class="line">//注意：这里vue-template-compiler版本需要和当前使用的vue版本一致</span><br><span class="line"></span><br><span class="line">#5.webpack.config.js</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">//1.引入VueLoaderPlugin插件(在vue-loader15版本以后需要配置这个)</span><br><span class="line">const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: path.join(__dirname, &apos;./src/main.js&apos;),</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, &apos;./dist&apos;),</span><br><span class="line">        filename: &apos;bundle.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new htmlWebpackPlugin(&#123;</span><br><span class="line">            template:path.resolve(__dirname, &apos;src/index.html&apos;),//模板路径</span><br><span class="line">            filename:&apos;index.html&apos;//自动生成的HTML文件的名称</span><br><span class="line">        &#125;),</span><br><span class="line">        // 2.配置VueLoaderPlugin插件</span><br><span class="line">        new VueLoaderPlugin()</span><br><span class="line">    ],</span><br><span class="line">    module: &#123; </span><br><span class="line">        rules: [ </span><br><span class="line">            &#123; test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;,</span><br><span class="line">            &#123; test: /\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125;,</span><br><span class="line">            &#123; test: /\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125;,</span><br><span class="line">            &#123; test: /\.(png|jpg|gif|bmp|jpeg)$/, use: &apos;url-loader?limit=1024&amp;name=[hash:8]-[name].[ext]&apos; &#125;,</span><br><span class="line">            &#123; test: /\.(ttf|eot|svg|woff|woff2)$/, use: &apos;url-loader&apos; &#125;, </span><br><span class="line">            &#123; test: /\.js$/, use: &apos;babel-loader&apos;, exclude: /node_modules/ &#125;,</span><br><span class="line">            //3.处理 .vue 文件的 loader</span><br><span class="line">            &#123; test: /\.vue$/, use: &apos;vue-loader&apos; &#125; </span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">           &apos;vue$&apos;: &apos;vue/dist/vue.js&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-render渲染组件"><a href="#3-render渲染组件" class="headerlink" title="3.render渲染组件"></a>3.render渲染组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#main.js</span><br><span class="line"></span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">import login from &apos;./login.vue&apos;</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        msg: &apos;123&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    render: c =&gt; c(login)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//注意：此种方式会替换页面内容</span><br></pre></td></tr></table></figure><h3 id="4-vue组件中的数据"><a href="#4-vue组件中的数据" class="headerlink" title="4.vue组件中的数据"></a>4.vue组件中的数据</h3><h4 id="2-4-1-模块的导出"><a href="#2-4-1-模块的导出" class="headerlink" title="2.4.1 模块的导出"></a>2.4.1 模块的导出</h4><p>   ES6语法：</p><blockquote><ol><li><p>在ES6中使用 export default 和 export 导出模块中的成员;</p><p>(Node中使用 module.exports 和 export导出成员)</p></li><li><p>使用 import ** from ** 和 import ‘路径’ 还有 import {a, b} from ‘模块标识’ 导入其他模块</p></li></ol></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#1. 新建test.js</span><br><span class="line"><span class="comment">// 在 ES6 中，使用 export default 和 export 向外暴露成员：</span></span><br><span class="line"><span class="keyword">var</span> info = &#123;</span><br><span class="line">  name: <span class="string">'zs'</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> info</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注意：</span></span><br><span class="line"><span class="comment">   export default 向外暴露的成员，可以使用任意的变量来接收</span></span><br><span class="line"><span class="comment">   在一个模块中，export default 只允许向外暴露1次</span></span><br><span class="line"><span class="comment">   在一个模块中，可以同时使用 export default 和 export 向外暴露成员</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> title = <span class="string">'小星星'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> content = <span class="string">'哈哈哈'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*注意：</span></span><br><span class="line"><span class="comment">     使用 export 向外暴露的成员，只能使用 &#123; &#125; 的形式来接收，这种形式叫做 【按需导出】</span></span><br><span class="line"><span class="comment">     export 可以向外暴露多个成员， 同时如果某些成员在我们import 的时候不需要，则可以不在 &#123;&#125;  中定义</span></span><br><span class="line"><span class="comment">     使用 export 导出的成员，必须严格按照导出时候的名称来使用  &#123;&#125;  按需接收；</span></span><br><span class="line"><span class="comment">     使用 export 导出的成员，如果想换个名称来接收，可以使用 as 来起别名；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#2. main.js</span><br><span class="line"><span class="keyword">import</span> minfo3, &#123; title <span class="keyword">as</span> title123, content &#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"><span class="built_in">console</span>.log(minfo3)    <span class="comment">//这里的minfo3就是test.js中所暴露出来的default info</span></span><br><span class="line"><span class="built_in">console</span>.log(title123 + <span class="string">' --- '</span> + content)</span><br></pre></td></tr></table></figure><h4 id="2-4-2-vue中的数据导出"><a href="#2-4-2-vue中的数据导出" class="headerlink" title="2.4.2 .vue中的数据导出"></a>2.4.2 .vue中的数据导出</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#login.vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;这是登录组件，使用 .vue 文件定义出来的 --- &#123;&#123;msg&#125;&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button @click="show"&gt;点我&lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="comment">// 注意：组件中的 data 必须是 function</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        msg: <span class="string">"123321"</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      show() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"调用了 login.vue 中的 show 方法"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      webpack
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>ES6基础知识</title>
    <link href="http://yoursite.com/2019/03/19/ES6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/03/19/ES6基础知识/</id>
    <published>2019-03-19T11:18:44.000Z</published>
    <updated>2020-01-29T06:23:44.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES6基础知识"><a href="#ES6基础知识" class="headerlink" title="ES6基础知识"></a>ES6基础知识</h2><h3 id="1-let-和-const"><a href="#1-let-和-const" class="headerlink" title="1.let 和 const"></a>1.let 和 const</h3><p>在ES6之前，js只有全局作用域和函数作用域，ES6中let关键字为其引入了块级作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//&#123;&#125;代码块</span><br><span class="line">&#123;</span><br><span class="line">var a = 5;</span><br><span class="line">let b = 6;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);     //5</span><br><span class="line">console.log(b);     //b is undefined</span><br></pre></td></tr></table></figure><ul><li><p>let声明的变量只能在其所在的代码块内才能访问，var声明的变量由于是全局变量，因此可以在代码块外访问</p></li><li><p>const用来定义常量，相当于java中的<code>final</code>关键字。并且const声明常量之后就必须立即初始化！</p></li><li><p>et声明的变量一旦用let声明，那么在声明之前，此变量都是不可用的，术语称为“暂时性死区”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(a);                     //undefined</span><br><span class="line">var a=8;</span><br><span class="line">console.log(&quot;----------&quot;);</span><br><span class="line">console.log(b);                     //控制台报错</span><br><span class="line">let b=9;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-解构赋值"><a href="#2-解构赋值" class="headerlink" title="2.解构赋值"></a>2.解构赋值</h3><blockquote><p>ES6允许按照一定的模式从数组和对象中提取值，对变量进行赋值，这被称为解构。</p></blockquote><p>(1)、基本用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//新的定义方法</span><br><span class="line">let  [name,age,sex] = [&quot;李四&quot;,20,&quot;女&quot;];</span><br><span class="line"></span><br><span class="line">//以前的定义方法</span><br><span class="line">let name = &quot;李四&quot;;</span><br><span class="line">let age = 20;</span><br><span class="line">let sex = &quot;女&quot;</span><br></pre></td></tr></table></figure><p>(2)、对象的解构赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//前面的key值和后面的key值相对应的</span><br><span class="line">let &#123;name,age,friends&#125; = &#123;name:&quot;zhangsan&quot;,age:12,friends:[&quot;lulu&quot;,&quot;女&quot;]&#125;;</span><br><span class="line">console.log(name); //zhangsan</span><br></pre></td></tr></table></figure><p>(3)、嵌套数组的解构赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//只要一一对应就可以</span><br><span class="line">let [a1,[a2,a3,[a4,a5]]] = [1,[2,3,[4,5]]];</span><br><span class="line">console.log(a1,a2,a3,a4,a5);  //1，2，3，4，5</span><br></pre></td></tr></table></figure><p>(4)、字符串的解构赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let [a,b,c,d,e] = &quot;我是中国人&quot;;</span><br><span class="line">console.log(a);   //我</span><br><span class="line">console.log(b);   //是</span><br><span class="line">console.log(c);   //中</span><br><span class="line">console.log(d);   //国</span><br><span class="line">console.log(e);   //人</span><br></pre></td></tr></table></figure><p>(5)、空缺变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [a,b,,e]=[&apos;a&apos;,&apos;b&apos;,[1,2],4]</span><br></pre></td></tr></table></figure><p>(6)、多余变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [a,b,,e,f]=[&apos;a&apos;,&apos;b&apos;,[3,4],5]</span><br></pre></td></tr></table></figure><blockquote><p>注意：因为字符串有构造器，所以可以解析出来。</p></blockquote><h3 id="3-字符串的扩展"><a href="#3-字符串的扩展" class="headerlink" title="3.字符串的扩展"></a>3.字符串的扩展</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Unicode表示法</span><br><span class="line">&quot;\u&#123;码点&#125;&quot;</span><br><span class="line">&quot;\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;&quot;                 //&quot;ABC&quot;</span><br><span class="line"></span><br><span class="line">let str = &quot;書剑恩仇录&quot;;</span><br><span class="line">str.codePointAt(0).toString(16);    //返回字符的码点并由十进制转到16进制---66f8</span><br><span class="line">String.fromCodePoint(0x66f8);       //返回码点对应的字符---書</span><br><span class="line">for (let a of str)&#123;</span><br><span class="line">   console.log(a);</span><br><span class="line">&#125;                                   //for...of循环遍历字符串中每个字符挨个输出字符</span><br><span class="line">str.at(0);                          //返回指定位置的字符，目前只是提案</span><br><span class="line">str.startsWith(&apos;書&apos;,0);             //从指定位置往后开始检查，是否以“書”开始，位置参数可省略，默认为0</span><br><span class="line">str.endsWith(&apos;剑&apos;,1);               //从指定位置向前检查，是否以“剑”结束</span><br><span class="line">str.includes(&apos;恩&apos;,1);               //同上，不再啰嗦</span><br><span class="line">str.repeat(2);                      //字符串重复指定次数“書剑恩仇录書剑恩仇录”，小数取整，Infinity和负数报错</span><br><span class="line">str.padStart(8,&apos;ab&apos;);               //指定字符从前开始补直到字符串长度符合要求，&quot;aba書剑恩仇录&quot;</span><br><span class="line">str.padEnd(8,&apos;ab&apos;);                 //指定字符从后开始补直到字符串长度符合要求，&quot;書剑恩仇录aba&quot;，若长度小于原长度，返回原字符串，上同</span><br></pre></td></tr></table></figure><h3 id="4-模版字符串"><a href="#4-模版字符串" class="headerlink" title="4.模版字符串"></a>4.模版字符串</h3><p>使用``包裹字符串 ${}包裹变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 普通字符串</span><br><span class="line">`In JavaScript &apos;\n&apos; is a line-feed.`</span><br><span class="line"></span><br><span class="line">// 多行字符串</span><br><span class="line">`In JavaScript this is</span><br><span class="line"> not legal.`</span><br><span class="line"></span><br><span class="line">console.log(`string text line 1 </span><br><span class="line">string text line 2`);</span><br><span class="line"></span><br><span class="line">// 字符串中嵌入变量</span><br><span class="line">let name = &quot;Bob&quot;, time = &quot;today&quot;;</span><br><span class="line">`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`</span><br></pre></td></tr></table></figure><h3 id="5-函数的扩展"><a href="#5-函数的扩展" class="headerlink" title="5.函数的扩展"></a>5.函数的扩展</h3><h4 id="1-参数默认值"><a href="#1-参数默认值" class="headerlink" title="1.参数默认值"></a>1.参数默认值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ES5中的写法</span><br><span class="line">function log(x, y) &#123;</span><br><span class="line">  //y = y || &apos;World&apos;;  --&gt; 这种写法如果y是false则不起作用，所以用下面的方式复制</span><br><span class="line">  if (typeof y === &apos;undefined&apos;) &#123;</span><br><span class="line">    y = &apos;World&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(&apos;Hello&apos;) // Hello World</span><br><span class="line"></span><br><span class="line">ES6中的写法</span><br><span class="line">function log(x, y = &apos;World&apos;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">log(&apos;Hello&apos;) // Hello World</span><br></pre></td></tr></table></figure><h4 id="2-箭头函数"><a href="#2-箭头函数" class="headerlink" title="2.箭头函数"></a>2.箭头函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var f = v =&gt; v;</span><br><span class="line">// 等同于</span><br><span class="line">var f = function (v) &#123;</span><br><span class="line">  return v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</span><br><span class="line">var f = () =&gt; 5;</span><br><span class="line">// 等同于</span><br><span class="line">var f = function () &#123; return 5 &#125;;</span><br></pre></td></tr></table></figure><h4 id="3-rest参数（剩余参数）"><a href="#3-rest参数（剩余参数）" class="headerlink" title="3.rest参数（剩余参数）"></a>3.rest参数（剩余参数）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo(a,b,...param)&#123; //...param会以数组的形式存储剩余的参数</span><br><span class="line">console.log(param);</span><br><span class="line">&#125;</span><br><span class="line">foo(1,2,3,4,5,6,7);//[3,4,5,6,7]</span><br></pre></td></tr></table></figure><h3 id="6-数组的扩展"><a href="#6-数组的扩展" class="headerlink" title="6.数组的扩展"></a>6.数组的扩展</h3><h4 id="1-Array-from"><a href="#1-Array-from" class="headerlink" title="1.Array.from"></a>1.Array.from</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let list = document.querySelectorAll(&quot;li&quot;)</span><br><span class="line">   console.log(Array.isArray(list));  //false</span><br><span class="line">   Array.from(list);  //将非数组list转为数组</span><br><span class="line">   console.log(Array.isArray(Array.from(list))); //true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.from(arrayLike[, mapFn[, thisArg]])</span><br></pre></td></tr></table></figure><p>返回值为转换后的数组。</p><p><strong>arrayLike</strong></p><p>想要转换的类数组对象或可迭代对象。</p><p>console.log(Array.from([1, 2, 3])); // [1, 2, 3]</p><p><strong>mapFn</strong></p><p>可选，map 函数，用于对每个元素进行处理，放入数组的是处理后的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Array.from([1, 2, 3], (n) =&gt; n * 2)); // [2, 4, 6]</span><br></pre></td></tr></table></figure><p><strong>thisArg</strong></p><p>可选，用于指定 map 函数执行时的 this 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let map = &#123;do: function(n) &#123;return n * 2;&#125;&#125;</span><br><span class="line">let arrayLike = [1, 2, 3];</span><br><span class="line">console.log(Array.from(arrayLike, function (n)&#123;</span><br><span class="line">return this.do(n);</span><br><span class="line">&#125;, map)); // [2, 4, 6]</span><br></pre></td></tr></table></figure><h4 id="2-Array-of"><a href="#2-Array-of" class="headerlink" title="2.Array.of"></a>2.Array.of</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.of(1,2,3,4); //将零散元素转为数组</span><br><span class="line">console.log(Array.isArray(Array.of(1, 2, 3, 4)));  //true</span><br></pre></td></tr></table></figure><h4 id="3-ES6-的合并数组"><a href="#3-ES6-的合并数组" class="headerlink" title="3. ES6 的合并数组"></a>3. ES6 的合并数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...arr1, ...arr2, ...arr3]</span><br></pre></td></tr></table></figure><h4 id="4-新增数组方法"><a href="#4-新增数组方法" class="headerlink" title="4.新增数组方法"></a>4.新增数组方法</h4><p><strong>1.find()</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找数组中符合条件的元素,若有多个符合条件的元素，则返回第一个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组空位处理为 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="number">1</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> <span class="literal">true</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><strong>2.findIndex()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查找数组中符合条件的元素索引，若有多个符合条件的元素，则返回第一个元素索引。</span><br><span class="line"></span><br><span class="line">let arr = Array.of(1, 2, 1, 3);</span><br><span class="line">// 参数1：回调函数</span><br><span class="line">// 参数2(可选)：指定回调函数中的 this 值</span><br><span class="line">console.log(arr.findIndex(item =&gt; item = 1)); // 0</span><br><span class="line"> </span><br><span class="line">// 数组空位处理为 undefined</span><br><span class="line">console.log([, 1].findIndex(n =&gt; true)); //0</span><br></pre></td></tr></table></figure><p><strong>3.fill()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将一定范围索引的数组元素内容填充为单个指定的值。</span><br><span class="line"></span><br><span class="line">let arr = Array.of(1, 2, 3, 4);</span><br><span class="line">// 参数1：用来填充的值</span><br><span class="line">// 参数2：被填充的起始索引</span><br><span class="line">// 参数3(可选)：被填充的结束索引，默认为数组末尾</span><br><span class="line">console.log(arr.fill(0,1,2)); // [1, 0, 3, 4]</span><br></pre></td></tr></table></figure><p><strong>4.copyWithin()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">将一定范围索引的数组元素修改为此数组另一指定范围索引的元素。</span><br><span class="line"></span><br><span class="line">// 参数1：被修改的起始索引</span><br><span class="line">// 参数2：被用来覆盖的数据的起始索引</span><br><span class="line">// 参数3(可选)：被用来覆盖的数据的结束索引，默认为数组末尾</span><br><span class="line">console.log([1, 2, 3, 4].copyWithin(0,2,4)); // [3, 4, 3, 4]</span><br><span class="line"> </span><br><span class="line">// 参数1为负数表示倒数</span><br><span class="line">console.log([1, 2, 3, 4].copyWithin(-2, 0)); // [1, 2, 1, 2]</span><br><span class="line"> </span><br><span class="line">console.log([1, 2, ,4].copyWithin(0, 2, 4)); // [, 4, , 4]</span><br></pre></td></tr></table></figure><p><strong>5.includes()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">includes()</span><br><span class="line"></span><br><span class="line">数组是否包含指定值。</span><br><span class="line"></span><br><span class="line">注意：与 Set 和 Map 的 has 方法区分；Set 的 has 方法用于查找值；Map 的 has 方法用于查找键名。</span><br><span class="line"></span><br><span class="line">// 参数1：包含的指定值</span><br><span class="line">[1, 2, 3].includes(1);    // true</span><br><span class="line"> </span><br><span class="line">// 参数2：可选，搜索的起始索引，默认为0</span><br><span class="line">[1, 2, 3].includes(1, 2); // false</span><br><span class="line"> </span><br><span class="line">// NaN 的包含判断</span><br><span class="line">[1, NaN, 3].includes(NaN); // true</span><br></pre></td></tr></table></figure><p><strong>6.flat()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log([1 ,[2, 3]].flat()); // [1, 2, 3]</span><br><span class="line"> </span><br><span class="line">// 指定转换的嵌套层数</span><br><span class="line">console.log([1, [2, [3, [4, 5]]]].flat(2)); // [1, 2, 3, [4, 5]]</span><br><span class="line"> </span><br><span class="line">// 不管嵌套多少层</span><br><span class="line">console.log([1, [2, [3, [4, 5]]]].flat(Infinity)); // [1, 2, 3, 4, 5]</span><br><span class="line"> </span><br><span class="line">// 自动跳过空位</span><br><span class="line">console.log([1, [2, , 3]].flat());&lt;p&gt; // [1, 2, 3]</span><br></pre></td></tr></table></figure><p><strong>7.flatMap()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先对数组中每个元素进行了的处理，再对数组执行 flat() 方法。</span><br><span class="line"></span><br><span class="line">// 参数1：遍历函数，该遍历函数可接受3个参数：当前元素、当前元素索引、原数组</span><br><span class="line">// 参数2：指定遍历函数中 this 的指向</span><br><span class="line">console.log([1, 2, 3].flatMap(n =&gt; [n * 2])); // [2, 4, 6]</span><br></pre></td></tr></table></figure><h3 id="7-Symbol"><a href="#7-Symbol" class="headerlink" title="7.Symbol"></a>7.Symbol</h3><p>ES6新增数据类型 属于基本数据类型，Symbol不可以new</p><p>Symbol声明的变量是唯一的，意义在于减少命名冲突；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    //Symbol的变量是唯一的，所以a1和a2永远不相等</span><br><span class="line">    let a1 = Symbol();</span><br><span class="line">    let a2 = Symbol();</span><br><span class="line">    console.log(a1 === a2);</span><br><span class="line">    </span><br><span class="line">   //Symbol.for(key)</span><br><span class="line">   //在使用Symbol时  会生成一个全局注册表，其中的数据以键值对的形式存在；能根据key来拿到对应的value</span><br><span class="line">   //若  a3  a4的key是相同的  那么a3 a4是相同的</span><br><span class="line">    let a3 = Symbol.for(&quot;a3&quot;);</span><br><span class="line">    let a4 = Symbol.for(&quot;a3&quot;);</span><br><span class="line">    console.log(a3 === a4);  //true</span><br><span class="line">    </span><br><span class="line">    //问题  若改变a3的值  a4的值会改变吗？</span><br><span class="line">    //是值复制   还是指针</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-ES6中的数据结构"><a href="#8-ES6中的数据结构" class="headerlink" title="8.ES6中的数据结构"></a>8.ES6中的数据结构</h3><h4 id="8-1Map"><a href="#8-1Map" class="headerlink" title="8.1Map"></a>8.1Map</h4><p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">p</span>: <span class="string">'Hello World'</span>&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, <span class="string">'content'</span>)   </span><br><span class="line">m.get(o) <span class="comment">// "content"</span></span><br><span class="line"></span><br><span class="line">m.has(o) <span class="comment">// true</span></span><br><span class="line">m.delete(o) <span class="comment">// true</span></span><br><span class="line">m.has(o) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="8-2Set"><a href="#8-2Set" class="headerlink" title="8.2Set"></a>8.2Set</h4><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set.add(ele)向set集合中追加ele元素</span><br><span class="line">set.has(ele)判断set集合中是否存在ele元素</span><br><span class="line">set.delete(ele)从集合中删除ele元素</span><br><span class="line">set.clear()清空set集合</span><br><span class="line">set.forEach( (ele) =&gt;&#123;&#125; )遍历集和</span><br></pre></td></tr></table></figure><h3 id="9-ES6-Reflect-与-Proxy"><a href="#9-ES6-Reflect-与-Proxy" class="headerlink" title="9. ES6 Reflect 与 Proxy"></a>9. ES6 Reflect 与 Proxy</h3><h4 id="9-1-Proxy"><a href="#9-1-Proxy" class="headerlink" title="9.1 Proxy"></a>9.1 Proxy</h4><p>一个 Proxy 对象由两个部分组成： target 、 handler 。在通过 Proxy 构造函数生成实例对象时，需要提供这两个参数。 target 即目标对象， handler 是一个对象，声明了代理 target 的指定行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>: function(target, key) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'getting '</span>+key);</span><br><span class="line">        <span class="keyword">return</span> target[key]; <span class="comment">// 不是target.key</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(target, key, value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setting '</span>+key);</span><br><span class="line">        target[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">proxy.name     <span class="comment">// 实际执行 handler.get</span></span><br><span class="line">proxy.age = <span class="number">25</span> <span class="comment">// 实际执行 handler.set</span></span><br><span class="line"><span class="comment">// getting name</span></span><br><span class="line"><span class="comment">// setting age</span></span><br><span class="line"><span class="comment">// 25</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// target 可以为空对象</span></span><br><span class="line"><span class="keyword">let</span> targetEpt = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxyEpt = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetEpt, handler)</span><br><span class="line"><span class="comment">// 调用 get 方法，此时目标对象为空，没有 name 属性</span></span><br><span class="line">proxyEpt.name <span class="comment">// getting name</span></span><br><span class="line"><span class="comment">// 调用 set 方法，向目标对象中添加了 name 属性</span></span><br><span class="line">proxyEpt.name = <span class="string">'Tom'</span></span><br><span class="line"><span class="comment">// setting name</span></span><br><span class="line"><span class="comment">// "Tom"</span></span><br><span class="line"><span class="comment">// 再次调用 get ，此时已经存在 name 属性</span></span><br><span class="line">proxyEpt.name</span><br><span class="line"><span class="comment">// getting name</span></span><br><span class="line"><span class="comment">// "Tom"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过构造函数新建实例时其实是对目标对象进行了浅拷贝，因此目标对象与代理对象会互相</span></span><br><span class="line"><span class="comment">// 影响</span></span><br><span class="line">targetEpt)</span><br><span class="line"><span class="comment">// &#123;name: "Tom"&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// handler 对象也可以为空，相当于不设置拦截操作，直接访问目标对象</span></span><br><span class="line"><span class="keyword">let</span> targetEmpty = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxyEmpty = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetEmpty,&#123;&#125;)</span><br><span class="line">proxyEmpty.name = <span class="string">"Tom"</span></span><br><span class="line">targetEmpty) <span class="comment">// &#123;name: "Tom"&#125;</span></span><br></pre></td></tr></table></figure><h4 id="9-2-Reflect"><a href="#9-2-Reflect" class="headerlink" title="9.2 Reflect"></a>9.2 Reflect</h4><p>ES6 中将 Object 的一些明显属于语言内部的方法移植到了 Reflect 对象上（当前某些方法会同时存在于 Object 和 Reflect 对象上），未来的新方法会只部署在 Reflect 对象上。</p><p>Reflect 对象对某些方法的返回结果进行了修改，使其更合理。</p><p>Reflect 对象使用函数的方式实现了 Object 的命令式操作。</p><ol><li><p><strong>Reflect.get</strong></p><p>查找并返回 target 对象的 name 属性</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.get(target, name, receiver) </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> exam = &#123;</span><br><span class="line">    name: <span class="string">"Tom"</span>,</span><br><span class="line">    age: <span class="number">24</span>,</span><br><span class="line">    <span class="keyword">get</span> info()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Reflect</span>.get(exam, <span class="string">'name'</span>); <span class="comment">// "Tom"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当 target 对象中存在 name 属性的 getter 方法， getter 方法的 this 会绑定 // receiver</span></span><br><span class="line"><span class="keyword">let</span> receiver = &#123;</span><br><span class="line">    name: <span class="string">"Jerry"</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Reflect</span>.get(exam, <span class="string">'info'</span>, receiver); <span class="comment">// Jerry20</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当 name 为不存在于 target 对象的属性时，返回 undefined</span></span><br><span class="line"><span class="built_in">Reflect</span>.get(exam, <span class="string">'birth'</span>); <span class="comment">// undefined</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当 target 不是对象时，会报错</span></span><br><span class="line"><span class="built_in">Reflect</span>.get(<span class="number">1</span>, <span class="string">'name'</span>); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Reflect.set</strong></li></ol><p>将 target 的 name 属性设置为 value。返回值为 boolean ，true 表示修改成功，false 表示失败。当 target 为不存在的对象时，会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">let exam = &#123;</span><br><span class="line">    name: &quot;Tom&quot;,</span><br><span class="line">    age: 24,</span><br><span class="line">    set info(value)&#123;</span><br><span class="line">        return this.age = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">exam.age; // 24</span><br><span class="line">Reflect.set(exam, &apos;age&apos;, 25); // true</span><br><span class="line">exam.age; // 25</span><br><span class="line"> </span><br><span class="line">// value 为空时会将 name 属性清除</span><br><span class="line">Reflect.set(exam, &apos;age&apos;, ); // true</span><br><span class="line">exam.age; // undefined</span><br><span class="line"> </span><br><span class="line">// 当 target 对象中存在 name 属性 setter 方法时，setter 方法中的 this 会绑定 // receiver , 所以修改的实际上是 receiver 的属性,</span><br><span class="line">let receiver = &#123;</span><br><span class="line">    age: 18</span><br><span class="line">&#125;</span><br><span class="line">Reflect.set(exam, &apos;info&apos;, 1, receiver); // true</span><br><span class="line">receiver.age; // 1</span><br><span class="line"> </span><br><span class="line">let receiver1 = &#123;</span><br><span class="line">    name: &apos;oppps&apos;</span><br><span class="line">&#125;</span><br><span class="line">Reflect.set(exam, &apos;info&apos;, 1, receiver1);</span><br><span class="line">receiver1.age; // 1</span><br></pre></td></tr></table></figure><h3 id="10-Promise和asymc"><a href="#10-Promise和asymc" class="headerlink" title="10.Promise和asymc"></a>10.Promise和asymc</h3><h4 id="10-1-Promise-状态"><a href="#10-1-Promise-状态" class="headerlink" title="10.1 Promise 状态"></a>10.1 Promise 状态</h4><p>Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。</p><p>Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">'success1'</span>);</span><br><span class="line">    resolve(<span class="string">'success2'</span>);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;  </span><br><span class="line">    resolve(<span class="string">'success3'</span>); </span><br><span class="line">    reject(<span class="string">'reject'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// success1</span></span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// success3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="10-2-async"><a href="#10-2-async" class="headerlink" title="10.2 async"></a>10.2 async</h4><p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。</p><p>和await结合使用 使Promise 看起来像同步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function testAwait (x) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(x);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">async function helloAsync() &#123;</span><br><span class="line">  var x = await testAwait (&quot;hello world&quot;);</span><br><span class="line">  console.log(x); </span><br><span class="line">&#125;</span><br><span class="line">helloAsync ();</span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      ES6基础知识
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="http://yoursite.com/2019/03/04/webpack/"/>
    <id>http://yoursite.com/2019/03/04/webpack/</id>
    <published>2019-03-04T14:47:43.000Z</published>
    <updated>2020-01-27T17:03:50.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h3 id="1-概念以及作用"><a href="#1-概念以及作用" class="headerlink" title="1.概念以及作用"></a>1.概念以及作用</h3><p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)</em>。当 webpack 处理应用程序时，它会递归地构建一个<em>依赖关系图(dependency graph)</em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em>。</p><blockquote><p>webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具；</p></blockquote><ul><li>借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 在没有使用webpack之前：</span><br><span class="line">举个例子：index.html里面有一大堆的css和js文件，如a.js   b.js   c.js  d.js等等</span><br><span class="line">（1）a.js要用到b.js里面的一个函数，则a.js要放在b.js后面</span><br><span class="line">（2）c.js要用到a.js里面的一个函数，则c.js要放在a.js后面</span><br><span class="line">（3）b.js又要用到d.js文件里面的函数，则b.js就要放在d.js后面</span><br><span class="line">如果有N多个js文件，需要手动处理他们的关系，即容易出错。</span><br><span class="line"></span><br><span class="line"># 使用webpack：</span><br><span class="line">webpack的理念就是一切皆模块化，把一堆的css文件和js文件放在一个总的入口文件，通过require引入，剩下的事情webpack会处理，包括所有模块的前后依赖关系，打包、压缩、合并成一个js文件，公共代码抽离成一个js文件、某些自己指定的js单独打包，模块可以是css/js/images/font等等。</span><br></pre></td></tr></table></figure><h3 id="2-webpack的使用"><a href="#2-webpack的使用" class="headerlink" title="2.webpack的使用"></a>2.webpack的使用</h3><h4 id="2-1webpack的安装"><a href="#2-1webpack的安装" class="headerlink" title="2.1webpack的安装"></a>2.1webpack的安装</h4><ol><li><p>运行<code>npm i webpack@4.27.1 -g</code>全局安装webpack，这样就能在全局使用webpack的命令</p><p><code>npm i webpack-cli@3.1.2 –g</code> 全局安装webpack命令行工具</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">配置环境变量</span><br></pre></td></tr></table></figure><ol><li>在项目根目录中运行<code>npm i webpack@4.27.1 --save-dev</code>安装到项目依赖中</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm info webpack <span class="comment">//查看npm上的webpack的信息</span></span><br><span class="line"></span><br><span class="line">webpack -v   <span class="comment">//查看当前安装的webpack的版本信息</span></span><br></pre></td></tr></table></figure><p>####2.2webpack的配置文件</p><ol><li><p>在项目根目录中创建<code>webpack.config.js</code></p></li><li><p>由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在<code>webpack.config.js</code>中配置这两个路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 导入处理路径的模块</span><br><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: path.resolve(__dirname, &apos;src/main.js&apos;), // 项目入口文件</span><br><span class="line">    output: &#123; // 配置输出选项</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;), // 配置输出的路径</span><br><span class="line">        filename: &apos;bundle.js&apos; // 配置输出的文件名</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用命令打包构建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 使用webpack命令即可打包项目、</span><br><span class="line">webpack   //没有指定webpack打包的配置文件，默认使用项目根路径下的webpack.config.js文件</span><br><span class="line">webpack --config webpack.config.js  //指定webpack打包的时候使用的配置文件</span><br><span class="line"></span><br><span class="line">// 当我们在控制台，直接输入 webpack 命令执行的时候，webpack 做了以下几步：</span><br><span class="line">//  1. 首先webpack 发现我们并没有通过命令的形式给它指定入口和出口</span><br><span class="line">//  2. webpack 就会去项目的根目录中查找一个叫做 `webpack.config.js` 的配置文件</span><br><span class="line">//  3. 当找到配置文件后，webpack会去解析执行这个配置文件，当解析执行完配置文件后，就得到了 配置文件中，导出的配置对象</span><br><span class="line">//  4. 当 webpack拿到配置对象后，就拿到了配置对象中指定的入口和出口，然后进行打包构建；</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-3webpack实时打包构建"><a href="#2-3webpack实时打包构建" class="headerlink" title="2.3webpack实时打包构建"></a>2.3webpack实时打包构建</h4><ol><li><p>由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用<code>webpack-dev-server</code>来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。</p></li><li><p>安装webpack-dev-server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack-dev-server@3.1.9 --save-dev</span><br><span class="line">npm i webpack@4.27.1 --save-dev     //项目中安装webpack</span><br><span class="line">npm i webpack-cli@3.1.2</span><br></pre></td></tr></table></figure></li><li><p>安装完成之后，在命令行直接运行<code>webpack-dev-server</code>来进行打包，发现报错，因为它不是全局命令，不可以直接使用。</p></li><li><p>我们借助于<code>package.json</code>文件中的指令来进行运行<code>webpack-dev-server</code>命令，在<code>scripts</code>节点下新增<code>&quot;dev&quot;: &quot;webpack-dev-server&quot;</code>指令，发现可以进行实时打包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">  &quot;dev&quot;: &quot;webpack-dev-server&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行项目</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>但是dist目录下并没有生成<code>bundle.js</code>文件，这是因为<code>webpack-dev-server</code>将打包好的文件放在了内存中。把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Project is running at  [1m [34mhttp://localhost:8084/ [39m[22m</span><br><span class="line">webpack output is served from /</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此时我们可以通过http://localhost:8083/bundle.js 文件，因为webpack-dev-server默认是将bundle.js文件打包到根路径，所以要能做到修改main.js之后页面也要同步变化，需要修改页面的script标签：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;../bundle.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>指定启动参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了能在访问http://localhost:8080/的时候直接访问到index首页，可以使用--contentBase src指令来修改dev指令，指定启动的根目录：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">   &quot;dev&quot;: &quot;webpack-dev-server --open --port 3001 --contentBase src --hot&quot;</span><br><span class="line"> &#125;,</span><br><span class="line"> </span><br><span class="line"> //  --open含义：构建完成自动打开浏览器</span><br><span class="line"> //  --port 3001 : 指定运行的端口</span><br><span class="line"> //  --contentBase src   :  指定运行的根目录是src，即认为src就是项目根目录</span><br><span class="line"> //  --hot : 以补丁的方式修改文件，而不是修改全部文件</span><br></pre></td></tr></table></figure></li><li><p>解决webpack4.0之后打包大小警告和热更新慢的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">https://cloud.tencent.com/developer/section/1477466</span><br><span class="line"></span><br><span class="line">#main.js </span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //1.设置为开发模式，不然热更新会比较缓慢</span><br><span class="line">    mode:&quot;development&quot;,</span><br><span class="line">    entry: path.resolve(__dirname, &apos;src/main.js&apos;),</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">        filename: &apos;bundle.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    //2.打包文件大小警告和错误的问题</span><br><span class="line">    performance: &#123;</span><br><span class="line">        hints:false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-4webpack配置文件生成参数"><a href="#2-4webpack配置文件生成参数" class="headerlink" title="2.4webpack配置文件生成参数"></a>2.4webpack配置文件生成参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">// 启用热更新的 第2步</span><br><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: path.join(__dirname, &apos;./src/main.js&apos;),</span><br><span class="line">  output: &#123; </span><br><span class="line">    path: path.join(__dirname, &apos;./dist&apos;), </span><br><span class="line">    filename: &apos;bundle.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123; </span><br><span class="line">    // 这是配置 dev-server 命令参数的第二种形式，相对来说，这种方式麻烦一些</span><br><span class="line">    //  --open --port 3000 --contentBase src --hot</span><br><span class="line">    open: true, // 自动打开浏览器</span><br><span class="line">    port: 3000, // 设置启动时候的运行端口</span><br><span class="line">    contentBase: &apos;src&apos;, // 指定托管的根目录</span><br><span class="line">    hot: true // 启用热更新 的 第1步</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [ // 配置插件的节点</span><br><span class="line">    new webpack.HotModuleReplacementPlugin(), // new 一个热更新的 模块对象， 这是 启用热更新的第 3 步</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####2.5html-webpack-plugin插件配置启动页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://www.npmjs.com/package/html-webpack-plugin</span><br><span class="line"></span><br><span class="line">html-webpack-plugin插件可以**将指定页面配置生成到内存中**，并且可以**将打包的bundle.js配置到内存中生成的html页面中**，使用步骤如下：</span><br></pre></td></tr></table></figure><ol><li>运行<code>npm i html-webpack-plugin@3.2.0 --save-dev</code>安装到开发依赖</li><li>修改<code>webpack.config.js</code>配置文件如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">// 导入自动生成HTMl文件的插件</span><br><span class="line">var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: path.join(__dirname, &apos;./src/main.js&apos;),</span><br><span class="line">    output: &#123; </span><br><span class="line">        path: path.join(__dirname, &apos;./dist&apos;), </span><br><span class="line">        filename: &apos;bundle.js&apos; </span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [ </span><br><span class="line">        // 添加plugins节点配置插件</span><br><span class="line">        new htmlWebpackPlugin(&#123;</span><br><span class="line">            template:path.resolve(__dirname, &apos;src/index.html&apos;),//模板路径</span><br><span class="line">            filename:&apos;index.html&apos;//自动生成的HTML文件的名称</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>package.json<code>中</code>script`节点中的dev指令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server --open --port 3001 --contentBase src --hot&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>将index.html中script标签注释掉，因为<code>html-webpack-plugin</code>插件会自动把bundle.js注入到index.html页面中！</p></li></ol><h4 id="2-6使用webpack打包css文件"><a href="#2-6使用webpack打包css文件" class="headerlink" title="2.6使用webpack打包css文件"></a>2.6使用webpack打包css文件</h4><p>一般情况下，我们并不推荐在html页面中直接引入其他css文件，这样会导致过多的请求。对应的，我们可以使用webpack来构建。使用步骤如下：</p><ol><li>运行 <code>npm i style-loader css-loader --save-dev</code></li><li>main.js中引入index.css</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import "./css/index.css"</span><br></pre></td></tr></table></figure><ol start="3"><li>修改<code>webpack.config.js</code>这个配置文件：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来配置第三方loader模块的</span></span><br><span class="line"><span class="built_in">module</span>: &#123; </span><br><span class="line">    rules: [ </span><br><span class="line">        <span class="comment">// 匹配以.css结尾的文件</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] &#125;<span class="comment">//处理css文件的规则</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>webpack 处理第三方文件类型的过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 发现这个要处理的文件不是JS文件，然后就去配置文件中，查找有没有对应的第三方 loader 规则</span><br><span class="line">2. 如果能找到对应的规则， 就会调用对应的loader处理这种文件类型；</span><br><span class="line">3. 在调用loader的时候，use中相关loader模块的调用顺序是从后向前调用的；</span><br><span class="line">4. 当最后的一个loader调用完毕，会把处理的结果直接交给 webpack 进行打包合并，最终输出到  bundle.js 中去</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-7使用webpack打包less文件"><a href="#2-7使用webpack打包less文件" class="headerlink" title="2.7使用webpack打包less文件"></a>2.7使用webpack打包less文件</h4><ol><li>运行<code>npm i less-loader less</code>，需要同时安装less-loader和less</li><li>main.js中引入index.less</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import "./css/index.less"</span><br></pre></td></tr></table></figure><ol start="3"><li>修改<code>webpack.config.js</code>这个配置文件：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123; <span class="comment">// 用来配置第三方loader模块的</span></span><br><span class="line">    rules: [ <span class="comment">// 文件的匹配规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] &#125;,<span class="comment">//处理css文件的规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.less$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>] &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-8使用webpack打包sass文件"><a href="#2-8使用webpack打包sass文件" class="headerlink" title="2.8使用webpack打包sass文件"></a>2.8使用webpack打包sass文件</h4><ol><li>运行<code>npm i sass-loader@7.3.1 node-sass --save-dev</code></li><li>main.js中引入index.scss   </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：文件名是scss结尾</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"./css/index.scss"</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在<code>webpack.config.js</code>中添加处理scss文件的loader模块：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123; <span class="comment">// 用来配置第三方loader模块的</span></span><br><span class="line">    rules: [ <span class="comment">// 文件的匹配规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] &#125;,<span class="comment">//处理css文件的规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.less$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>] &#125;,</span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>] &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####2.9使用webpack处理css中的路径</p><ol><li>运行<code>npm i url-loader file-loader --save-dev</code></li><li>在<code>webpack.config.js</code>中添加处理url路径的loader模块：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123; <span class="comment">// 用来配置第三方loader模块的</span></span><br><span class="line">    rules: [ <span class="comment">// 文件的匹配规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] &#125;,<span class="comment">//处理css文件的规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.less$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>] &#125;,</span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>] &#125;,</span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif|bmp|jpeg)$/</span>, <span class="attr">use</span>: <span class="string">'url-loader'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol><li>index.css</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">450px</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../images/<span class="number">1</span>.jpg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意点：url-loader默认情况下会将图片转换为base64编码的图片，好处是可以减少图片的二次请求。但是这种方式一般情况下适用于小图，如果是大图，我们可以像下面这样去使用：</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123; <span class="comment">// 用来配置第三方loader模块的</span></span><br><span class="line">    rules: [ <span class="comment">// 文件的匹配规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] &#125;,<span class="comment">//处理css文件的规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.less$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>] &#125;,</span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>] &#125;,</span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif|bmp|jpeg)$/</span>,</span><br><span class="line">         use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            limit: <span class="number">8192</span>,</span><br><span class="line">                            name:<span class="string">'[hash:8]-[name].[ext]'</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//limit ： 当图片大小小于等于指定的值时会进行base64编码</span></span><br><span class="line"><span class="comment">//name =[name].[ext]： 不给图片重命名，还是使用原图名。如果没有这个属性，则默认会使用hashcode的方式来给图片重命名。</span></span><br><span class="line"><span class="comment">//给图片重命名的好处是：如果在多个不同的目录下有两张同名的图片(内容不同)，不会产生冲突。(默认情况下webpack会将图片也打包到根路径下)</span></span><br><span class="line"><span class="comment">//如果既想多个文件夹下的同名的图片被打包后不冲突，又想保留原来的图片名字，可以这样使用：name=[hash:8]-[name].[ext]  ，  [hash:8]表示保留8位hash值，然后再去追加原来的[name]</span></span><br></pre></td></tr></table></figure><h4 id="2-10使用webpack处理字体图标"><a href="#2-10使用webpack处理字体图标" class="headerlink" title="2.10使用webpack处理字体图标"></a>2.10使用webpack处理字体图标</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">module: &#123; // 用来配置第三方loader模块的</span><br><span class="line">    rules: [ // 文件的匹配规则</span><br><span class="line">        &#123; test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;,//处理css文件的规则</span><br><span class="line">        &#123; test: /\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125;,</span><br><span class="line">        &#123; test: /\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                test: /\.(png|jpg|gif|bmp|jpeg)$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &apos;url-loader&apos;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            limit: 8192,</span><br><span class="line">                            name:&apos;[hash:8]-[name].[ext]&apos;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;   test: /\.(ttf|eot|svg|woff|woff2)$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader:&apos;url-loader&apos;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;, // 处理 字体文件的 loader</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-11webpack中babel的配置"><a href="#2-11webpack中babel的配置" class="headerlink" title="2.11webpack中babel的配置"></a>2.11webpack中babel的配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 webpack 中，默认只能处理一部分 ES6 的新语法；这时候就需要借助于第三方的 loader，来帮助webpack 处理这些高级的语法，当第三方loader可以把高级语法转为低级的语法，然后再把结果交给 webpack 去打包到 bundle.js 中</span><br></pre></td></tr></table></figure><ol><li>运行<code>npm i babel-core@6.26.3 babel-loader@7.1.5 babel-plugin-transform-runtime --save-dev</code>安装babel的相关loader包 (babel的转换工具)</li><li>运行<code>npm i babel-preset-env babel-preset-stage-0 --save-dev</code>安装babel转换的语法 (es6的语法和es5的语法的对应关系)</li><li>在<code>webpack.config.js</code>中添加相关loader模块，其中需要注意的是，一定要把<code>node_modules</code>文件夹添加到排除项：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123; <span class="comment">// 用来配置第三方loader模块的</span></span><br><span class="line">    rules: [ <span class="comment">// 文件的匹配规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] &#125;,<span class="comment">//处理css文件的规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.less$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>] &#125;,</span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>] &#125;,</span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif|bmp|jpeg)$/</span>, <span class="attr">use</span>: <span class="string">'url-loader?limit=1024&amp;name=[hash:8]-[name].[ext]'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.(ttf|eot|svg|woff|woff2)$/</span>, <span class="attr">use</span>: <span class="string">'url-loader'</span> &#125;, <span class="comment">// 处理 字体文件的 loader</span></span><br><span class="line">        <span class="comment">//配置 babel 的 loader规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">use</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span> &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在项目根目录中添加<code>.babelrc</code>文件，并修改这个配置文件如下(这个文件必须符合json的语法，不能有注释。字符串必须使用双引号)：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"env"</span>, <span class="string">"stage-0"</span>],</span><br><span class="line">  <span class="string">"plugins"</span>: [<span class="string">"transform-runtime"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：之前用的比较多的语法插件<code>babel-preset-es2015</code>更新为<code>babel-preset-env</code>，它包含了所有的ES相关的语法；</strong></p><h4 id="1-3-11-所有配置总结"><a href="#1-3-11-所有配置总结" class="headerlink" title="1.3.11 所有配置总结"></a>1.3.11 所有配置总结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"># 1.安装</span><br><span class="line">npm i webpack@4.20.1 --save-dev                   //安装webpack</span><br><span class="line">npm init -y                                                       //项目初始化</span><br><span class="line">npm i webpack-dev-server@3.1.9 --save-dev      //实时打包构建</span><br><span class="line">npm i webpack-cli@3.1.2      </span><br><span class="line">npm i html-webpack-plugin@3.2.0 --save-dev      //配置内存页面</span><br><span class="line">npm i style-loader css-loader --save-dev               //css加载器</span><br><span class="line">npm i less-loader less                                             //less加载器</span><br><span class="line">npm i sass-loader@7.3.1 node-sass --save-dev               //sass加载器</span><br><span class="line">npm i url-loader file-loader --save-dev                 //url加载器</span><br><span class="line">npm i babel-core@6.26.3 babel-loader@7.1.5 babel-plugin-transform-runtime --save-dev    //babel转换工具</span><br><span class="line">npm i babel-preset-env babel-preset-stage-0 --save-dev           //babel转换的语法</span><br><span class="line"></span><br><span class="line">#2.webpack.config.js</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">// 导入自动生成HTMl文件的插件</span><br><span class="line">var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: path.join(__dirname, &apos;./src/main.js&apos;),</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, &apos;./dist&apos;),</span><br><span class="line">        filename: &apos;bundle.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        // 添加plugins节点配置插件</span><br><span class="line">        new htmlWebpackPlugin(&#123;</span><br><span class="line">            template:path.resolve(__dirname, &apos;src/index.html&apos;),//模板路径</span><br><span class="line">            filename:&apos;index.html&apos;//自动生成的HTML文件的名称</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    module: &#123; // 用来配置第三方loader模块的</span><br><span class="line">        rules: [ // 文件的匹配规则</span><br><span class="line">            &#123; test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;,//处理css文件的规则</span><br><span class="line">            &#123; test: /\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125;,</span><br><span class="line">            &#123; test: /\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125;,</span><br><span class="line">            &#123; test: /\.(png|jpg|gif|bmp|jpeg)$/, use: &apos;url-loader?limit=1024&amp;name=[hash:8]-[name].[ext]&apos; &#125;,</span><br><span class="line">            &#123; test: /\.(ttf|eot|svg|woff|woff2)$/, use: &apos;url-loader&apos; &#125;, // 处理 字体文件的 loader</span><br><span class="line">            //配置 babel 的 loader规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉</span><br><span class="line">            &#123; test: /\.js$/, use: &apos;babel-loader&apos;, exclude: /node_modules/ &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#3.项目入口文件</span><br><span class="line">import &quot;./css/index.css&quot;</span><br><span class="line"></span><br><span class="line">console.log(&quot;ok&quot;);</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    showInfo()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p = new Person(&quot;xiaoming&quot;,18);</span><br><span class="line">console.log(p.name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#4.package.json</span><br><span class="line"> &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server --open --port 3000 --contentBase src --hot&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">#5.项目根目录 .babelrc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;env&quot;, &quot;stage-0&quot;],</span><br><span class="line">  &quot;plugins&quot;: [&quot;transform-runtime&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      webpack
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>AJAX</title>
    <link href="http://yoursite.com/2019/02/22/AJAX/"/>
    <id>http://yoursite.com/2019/02/22/AJAX/</id>
    <published>2019-02-22T12:54:10.000Z</published>
    <updated>2020-01-27T12:25:28.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h2 id="1-什么是AJAX？"><a href="#1-什么是AJAX？" class="headerlink" title="1.什么是AJAX？"></a>1.什么是AJAX？</h2><p> Ajax（Asynchronous JavaScript and XML的缩写）是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。</p><p><strong>AJAX的好处</strong>：可以通过<code>js</code>代码发送get或者post的请求去从后台获取到相应数据，并只对页面中的部分标签进行刷新渲染，而不需要刷新整个页面，节约了带宽，优化了性能</p><h2 id="2-创建AJAX对象"><a href="#2-创建AJAX对象" class="headerlink" title="2.创建AJAX对象"></a>2.创建AJAX对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//兼容性写法  ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);是为了兼容IE5 IE6</span><br><span class="line">var ajax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</span><br></pre></td></tr></table></figure><h2 id="3-AJAX的方法"><a href="#3-AJAX的方法" class="headerlink" title="3.AJAX的方法"></a>3.AJAX的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//设置请求方式</span><br><span class="line">ajax.open(&quot;post&quot;,&quot;url&quot;,true);  //第三个参数如果为true，则是异步，反之同步</span><br><span class="line"></span><br><span class="line">//设置请求头格式（post请求时一定要加请求头，这是因为在传输过程中会出现转码的情况，可能导致乱码的情况）</span><br><span class="line">xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);</span><br><span class="line"></span><br><span class="line">//发送请求:get请求参数放在url后面，post请求参数send()方法里面</span><br><span class="line">ajax.send(&quot;数据&quot;); </span><br><span class="line"></span><br><span class="line">//监听ajax状态，当ajax的状态发生改变的时候执行</span><br><span class="line">ajax.onreadystatechange = function()&#123;</span><br><span class="line">    //响应完成，浏览器已经可以获取到服务器响应结果了</span><br><span class="line">    if(this.readyState == 4)&#123;  //这是AJAX的状态码 区别与http的状态码 状态码还有 1 2 3 其中3是数据正在传输时的状态，他不保证数据的完整性</span><br><span class="line">        //http响应的状态码</span><br><span class="line">        if(this.state == 200)&#123;  //还有302  301  404...</span><br><span class="line">            //获取响应内容</span><br><span class="line">            console.log(this.responseText); //用ajax.responseText获取服务器返回的数据</span><br><span class="line">            //responseText 获得字符串形式的响应数据。</span><br><span class="line">   //responseXML 获得XML 形式的响应数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-数据渲染的两种方式"><a href="#4-数据渲染的两种方式" class="headerlink" title="4.数据渲染的两种方式"></a>4.数据渲染的两种方式</h2><h3 id="4-1数据在服务器中渲染完毕，返回给客户端一个完整页面"><a href="#4-1数据在服务器中渲染完毕，返回给客户端一个完整页面" class="headerlink" title="4.1数据在服务器中渲染完毕，返回给客户端一个完整页面"></a>4.1数据在服务器中渲染完毕，返回给客户端一个完整页面</h3><ol><li>浏览器发送请求至服务器</li><li>服务器接收到请求的信息，根据请求找到相应的信息（如JSON数据），在读取相应的页面文件，并渲染成一个完整的页面，将这个页面返回给客户端</li><li>客户端接收到此页面，并显示 (此方式要在服务器端安装art-template express-art-template等第三方模板）</li></ol><h3 id="4-2服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示"><a href="#4-2服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示" class="headerlink" title="4.2服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示"></a>4.2服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示</h3><ol><li>客户端发送数据请求给服务器</li><li>服务器拿到请求，找到相应的数据（如JSON），直接将此数据返回给客户端</li><li>客户端拿到数据后，在客户端进行渲染，并显示。（此方式要用到前端渲染插件template-web.js）</li></ol><h2 id="5-XML"><a href="#5-XML" class="headerlink" title="5.XML"></a>5.XML</h2><p>XML extensible Markup Language 扩展的标记语言，XML的标签可以自定义<br>HTML Hyper Text Markup Lanaguage HTML的标签是由W3C规范的，大概一共200多个</p><p><strong>XML用途：</strong><br>1、 定义数据结构<br>2、 作为配置文件出现</p><p><strong>XML组成：</strong><br>1、 XML文档声明<br>2、 XML标签<br>3、 XML属性<br>4、 XML注释</p><p><strong>XML文档注意点：</strong><br>1）xml的标签必须成对出现如，为成对出现时的标签也必须要是自关闭标签 如<br>2）xml标签名称区分大小写。<br>3）xml标签一定要正确配对。<br>4）xml标签名中间不能使用空格<br>5）xml标签名不能以数字开头<br>6）注意： 在一个xml文档中，有且仅有一个根标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//使用xml设计一个通讯录</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;contact&gt;</span><br><span class="line">&lt;person id=&quot;100&quot;&gt;</span><br><span class="line"> &lt;name&gt;张三&lt;/name&gt;</span><br><span class="line"> &lt;age&gt;18&lt;/age&gt;</span><br><span class="line"> &lt;phone&gt;12345678&lt;/phone&gt;</span><br><span class="line"> &lt;email&gt;12453@qq.com&lt;/email&gt;</span><br><span class="line">&lt;/person&gt;</span><br><span class="line">&lt;person id=&quot;101&quot;&gt;</span><br><span class="line"> &lt;name&gt;李四&lt;/name&gt;</span><br><span class="line"> &lt;age&gt;20&lt;/age&gt;</span><br><span class="line"> &lt;phone&gt;22345678&lt;/phone&gt;</span><br><span class="line"> &lt;email&gt;34453@qq.com&lt;/email&gt;</span><br><span class="line">&lt;/person&gt;</span><br><span class="line">&lt;/contact&gt;</span><br></pre></td></tr></table></figure><p><strong>xml的使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//服务器代码</span><br><span class="line">//返回XML格式的数据</span><br><span class="line">app.get(&quot;/getXML&quot;,(req,res)=&gt;&#123;</span><br><span class="line">//设置响应头，指定返回的数据是XML</span><br><span class="line">res.header(&quot;content-type&quot;,&quot;application/xml&quot;);</span><br><span class="line"></span><br><span class="line">var xml =  &apos;&lt;?xml version=&quot;1.1&quot; encoding=&quot;utf-8&quot;?&gt;&apos;;//XML文档声明</span><br><span class="line">xml += &apos;&lt;person&gt;&apos;;</span><br><span class="line">xml += &apos;&lt;name&gt;羊杨&lt;/name&gt;&apos;;</span><br><span class="line">xml += &apos;&lt;age&gt;16&lt;/age&gt;&apos;;</span><br><span class="line">xml += &apos;&lt;gender&gt;男&lt;/gender&gt;&apos;;</span><br><span class="line">xml += &apos;&lt;/person&gt;&apos;;</span><br><span class="line"></span><br><span class="line">res.send(xml);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//客户端代码</span><br><span class="line">ajax.onreadystatechange = function()&#123;</span><br><span class="line">if(this.readyState == 4)&#123;</span><br><span class="line">//获取响应的XML数据</span><br><span class="line">var xml = this.responseXML.documentElement;//ajax.responseXML.documentElement拿到文档数据</span><br><span class="line">var age = xml.querySelector(&quot;age&quot;);//用标签选择器获取到age数据  但此时age是&lt;age&gt;16&lt;/age&gt;</span><br><span class="line">console.log(age.innerHTML);//此处用innerText拿不到数据</span><br><span class="line">console.log(xml.children);//xml的语法几乎与html语法类似</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSON</p><p>json数据的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//服务器代码</span><br><span class="line">//返回JSON格式的数据</span><br><span class="line">app.get(&quot;/getJSON&quot;,(req,res)=&gt;&#123;</span><br><span class="line">//数组</span><br><span class="line">let arr = [</span><br><span class="line">&#123;</span><br><span class="line">name:&quot;zhangsan&quot;,</span><br><span class="line">age:&quot;18&quot;,</span><br><span class="line">gender:&quot;男&quot;,</span><br><span class="line">id:001</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name:&quot;lisi&quot;,</span><br><span class="line">age:&quot;28&quot;,</span><br><span class="line">gender:&quot;男&quot;,</span><br><span class="line">id:002</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">//将数组转换为JSON数据</span><br><span class="line">res.status(200).send(JSON.stringify(arr));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//客户端代码</span><br><span class="line">ajax.onreadystatechange = function()&#123;</span><br><span class="line">if(this.readyState == 4)&#123;</span><br><span class="line">console.log(this.responseText); //这是JSON字符串，在使用的时候往往需要转换为对象</span><br><span class="line">var students = JSON.parse(this.responseText);</span><br><span class="line">var html = template(&quot;generatorTable&quot;,&#123;students:students&#125;);</span><br><span class="line">container.innerHTML = html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-jQuery中的AJAX"><a href="#6-jQuery中的AJAX" class="headerlink" title="6.jQuery中的AJAX"></a>6.jQuery中的AJAX</h2><p>推荐使用 方便的一批</p><h3 id="6-1使用"><a href="#6-1使用" class="headerlink" title="6.1使用"></a>6.1使用</h3><p>客户端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    //请求方式</span><br><span class="line">    type:&quot;get&quot;, //post</span><br><span class="line">    </span><br><span class="line">    //请求路径</span><br><span class="line">    url:&quot;&quot;, //如http://localhost:3000/index</span><br><span class="line">    </span><br><span class="line">    //请求参数，无论是get还是post请求，请求参数都可以写在这里</span><br><span class="line">    //注意：请求为get时  在服务器得到请求参数时 仍然使用res.query</span><br><span class="line">    //这里的data数据必须为字符串 若要传入json数据 需要将json数据转换为字符串如 JSON.stringify(&#123;[&#123;&#125;,&#123;&#125;]&#125;)</span><br><span class="line">    data:&#123;name:&quot;zhangsan&quot;&#125;,</span><br><span class="line">    </span><br><span class="line">    //规定所要请求的数据的类型</span><br><span class="line">    dataType: &apos;&apos;,</span><br><span class="line">    </span><br><span class="line">    //在jQuery中如果请求已经是post，默认的contentType就是application/x-www-form-urlencoded,不需要单独再去写</span><br><span class="line">    //contentType: &quot;application/x-www-form-urlencoded&quot;,</span><br><span class="line">    //请求成功的回调</span><br><span class="line">    success:function(res)&#123;</span><br><span class="line">        console.log(res);//res是请求的到的数据</span><br><span class="line">    &#125;</span><br><span class="line">    //请求出错的回调 推荐写</span><br><span class="line">    error:function(err)&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">//无论请求的成功与否，只要请求结束都会执行此函数</span><br><span class="line">complete:function(xhr)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>服务器代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">let express = require(&quot;express&quot;);</span><br><span class="line">let app = express();</span><br><span class="line">const bodyParser = require(&apos;body-parser&apos;);</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended:false&#125;));</span><br><span class="line">//注意 当客户端中的data:JSON.stringify([&#123;name:&apos;zhangsan&apos;&#125;,&#123;name:&apos;lisi&apos;&#125;])时，服务器需要此配置</span><br><span class="line">//以解析body中的json数据</span><br><span class="line">app.use(bodyParser.json(&#123;extended:false&#125;));</span><br><span class="line"></span><br><span class="line">app.use(express.static(&quot;./views&quot;));</span><br><span class="line"></span><br><span class="line">//当ajax的url为&apos;/getJSON&apos;时 此接口响应 返回JSON格式的数据</span><br><span class="line">//此时ajax的dataType要设置为&apos;json&apos;</span><br><span class="line">app.get(&quot;/getJSON&quot;,(req,res)=&gt;&#123;</span><br><span class="line">    //数组</span><br><span class="line">    let arr = [</span><br><span class="line">        &#123;</span><br><span class="line">            name:&quot;zhangsan&quot;,</span><br><span class="line">            age:&quot;18&quot;,</span><br><span class="line">            gender:&quot;男&quot;,</span><br><span class="line">            id:001</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name:&quot;lisi&quot;,</span><br><span class="line">            age:&quot;28&quot;,</span><br><span class="line">            gender:&quot;男&quot;,</span><br><span class="line">            id:002</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    arr.forEach((user,idx)=&#123;</span><br><span class="line">        if(user.name == req.body.name)&#123;</span><br><span class="line">            res.status(200).send(JSON.stringify(user));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//当ajax的url为&apos;/getXML&apos;时 此接口响应 返回XML格式的数据</span><br><span class="line">//此时ajax的dataType要设置为&apos;xml&apos;</span><br><span class="line">app.get(&quot;/getXML&quot;,(req,res)=&gt;&#123;</span><br><span class="line">    //设置响应头，指定返回的数据是XML</span><br><span class="line">    res.header(&quot;content-type&quot;,&quot;application/xml&quot;);</span><br><span class="line"></span><br><span class="line">    var xml =  &apos;&lt;?xml version=&quot;1.1&quot; encoding=&quot;utf-8&quot;?&gt;&apos;;</span><br><span class="line">    xml += &apos;&lt;person&gt;&apos;;</span><br><span class="line">    xml += &apos;&lt;name&gt;zhangsan&lt;/name&gt;&apos;;</span><br><span class="line">    xml += &apos;&lt;age&gt;16&lt;/age&gt;&apos;;</span><br><span class="line">    xml += &apos;&lt;gender&gt;男&lt;/gender&gt;&apos;;</span><br><span class="line">    xml += &apos;&lt;/person&gt;&apos;;</span><br><span class="line"></span><br><span class="line">    res.send(xml);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>发送也接受html或script数据</p><p>服务器代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const app = express();</span><br><span class="line">const bodyParser = require(&apos;body-parser&apos;);</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended:false&#125;));</span><br><span class="line"></span><br><span class="line">app.use(express.static(&apos;views&apos;));</span><br><span class="line"></span><br><span class="line">app.get(&apos;/getScript&apos;,(req,res)=&gt;&#123;</span><br><span class="line">    res.header(&apos;content-type&apos;,&apos;application/javascript;charset=utf-8&apos;);</span><br><span class="line">    res.send(&apos;alert(123);&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(&apos;/getHtml&apos;,(req,res)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    res.header(&apos;content-type&apos;,&apos;text/html;charset=utf-8&apos;)</span><br><span class="line">    res.send(&apos;&lt;h1&gt;HTML&lt;/h1&gt;&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000,()=&gt;&#123;</span><br><span class="line">    console.log(&apos;running...&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#btn1&apos;).click(function()&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: &apos;get&apos;,</span><br><span class="line">        url: &apos;/getHtml&apos;,</span><br><span class="line">        data: &apos;&apos;,</span><br><span class="line">        dataType: &apos;html&apos;,</span><br><span class="line">        success:function(res)&#123;</span><br><span class="line">            //因为dataType为html  jQuery。AJAX会自动设置响应头为text/html  则 可以直接追加res到页面中</span><br><span class="line">            $(&apos;#info&apos;).append(res);</span><br><span class="line">        &#125;,</span><br><span class="line">        error:function(err)&#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(&apos;#btn2&apos;).click(function()&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: &apos;get&apos;,</span><br><span class="line">        url: &apos;/getScript&apos;,</span><br><span class="line">        data: &apos;&apos;,</span><br><span class="line">        dataType: &apos;script&apos;,</span><br><span class="line">        success:function(res)&#123;</span><br><span class="line">            //之所以alert()能执行  是因为将script代码打印到控制台  控制台会执行script代码</span><br><span class="line">            //也可以用script标签的对res进行封装 追加到页面中 也可以执行</span><br><span class="line">            console.log(res);</span><br><span class="line">        &#125;,</span><br><span class="line">        error:function(err)&#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="6-2dataType"><a href="#6-2dataType" class="headerlink" title="6.2dataType"></a>6.2dataType</h3><p><strong>dataType取值有xml、html、json、jsonp、script或者text</strong></p><p>当dataType取值为<strong>json</strong>，会自动将服务器返回的文本数据通过JSON.parse()转换成对象。<br>服务器应该设置这个响应头：<strong>res.header(“content-type”, “application/json;charset=utf-8”);</strong></p><p>当dataType为<strong>xml或者text</strong>的时候，返回的数据不会另做处理<br>服务器应该设置这个响应头：<strong>res.header(“content-type”,”application/xml”);</strong><br><strong>res.header(“content-type”,”text/plain;charset=utf-8”);</strong></p><p>当dataType为<strong>html</strong>的时候，返回的内容中的script标签会在网页内容被拼接到页面的时候执行<br>服务器应该设置这个响应头：<strong>res.header(“content-type”,”text/html;charset=utf-8”);</strong></p><p>当dataType为<strong>script</strong>的时候，会将服务器返回的结果当成js代码执行并且将js代码的文本内容返回给客户端<br>服务器应该设置这个响应头：<strong>res.header(“content-type”,”application/javascript”);</strong></p><p>当dataType为<strong>jsonp</strong>的时候，会向服务器发送一个jsonp请求<br>服务器应该设置这个响应头：<strong>res.header(“content-type”,”application/javascript”);</strong></p><h2 id="6-3nprogress的使用（全局事件处理）"><a href="#6-3nprogress的使用（全局事件处理）" class="headerlink" title="6.3nprogress的使用（全局事件处理）"></a>6.3nprogress的使用（全局事件处理）</h2><p>1、在html文件中引入nprogress.js 和 nprogress.css</p><p>2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(document).ajaxStart(function()&#123;//请求数据开始</span><br><span class="line">    NProgress.start();//数据加载动画</span><br><span class="line">&#125;).ajaxStop(function()&#123;//请求数据结束</span><br><span class="line">    NProgress.done();//数据加载完毕动画</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="7-跨域请求"><a href="#7-跨域请求" class="headerlink" title="7.跨域请求"></a>7.跨域请求</h2><p><strong>同源策略</strong>是浏览器的一种安全策略，所谓同源是指 <strong>域名，协议，端口完全相同</strong> ，只有同源的地址才可以相互通过AJAX的方式请求。</p><p>同源或者不同源说的是两个地址之间的关系，不同源地址之间请求我们称之为<strong>跨域请求</strong></p><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8000  是不可以通过ajax访问  http://locally.uieee.com/categories的</span><br><span class="line">因为两者不满足同源的条件</span><br></pre></td></tr></table></figure><h3 id="7-1如何进行跨域请求"><a href="#7-1如何进行跨域请求" class="headerlink" title="7.1如何进行跨域请求"></a>7.1如何进行跨域请求</h3><ol><li>CORS</li><li>JSONP</li><li>代理服务器</li><li>修改document.domain</li><li>Iframe</li><li>Location.hash</li><li>Window.postMessage()</li><li>Websocket</li></ol><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>只需要改动服务器，不用改动客户端代码，客户端可以直接使用$.ajax()</p><p>Cross Origin Resource Share，跨域资源共享。这种方案无需客户端作出任何变化（客户端不用改代码），只是在被请求的服务端响应的时候添加一个Access- Control-Allow-Origin 的响应头，表示这个资源是否允许指定域请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//直接在服务器配置如下,客户端代码和以前一样写</span><br><span class="line">app.all(&apos;*&apos;, function(req, res, next) &#123;</span><br><span class="line">    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">    res.header(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-type&apos;);</span><br><span class="line">    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS,PATCH&quot;);</span><br><span class="line">    res.header(&apos;Access-Control-Max-Age&apos;,6000);//预请求缓存10分钟</span><br><span class="line">    next();  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSON with Padding 实质上是通过script的src属性进行数据请求。本质上不是AJAX请求</p><p>需要服务器和客户端配合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//此时客户端的地址为http://localhost:3000</span><br><span class="line">实现要点</span><br><span class="line">//客户端代码</span><br><span class="line">var script = document.createElement(&apos;script&apos;);</span><br><span class="line">script.src = &apos;http://localhost:9999/testJSONP&apos;;//向http://localhost:9999发送跨域请求</span><br><span class="line">document.body.appendChild(script)</span><br><span class="line"></span><br><span class="line">//服务器代码</span><br><span class="line">app.get(&quot;/testJSONP&quot;,(req,res)=&gt;&#123;</span><br><span class="line">//设置响应头 服务器给客户端发送了一个js代码块</span><br><span class="line">res.header(&quot;content-type&quot;,&quot;application/javascript&quot;);</span><br><span class="line">let data = JSON.stringify(&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;) ;</span><br><span class="line">//服务器发送 `foo(&apos;&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;&apos;)` 这个字符串给客户端</span><br><span class="line">res.send(`foo($&#123;data&#125;)`);</span><br><span class="line">&#125;)</span><br><span class="line">//如果服务器给客户端返回的js代码块中有函数调用，必须提前在客户端中声明要调用的那个函数</span><br><span class="line">function foo(data)&#123;</span><br><span class="line">console.log(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>jQuery代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//客户端代码</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    type:&quot;get&quot;,</span><br><span class="line">    url:&quot;http://localhost:9999/testJSONP&quot;,</span><br><span class="line">    data:&apos;&apos;,</span><br><span class="line">    dataType: &apos;jsonp&apos;,</span><br><span class="line">    success:function(res)&#123;</span><br><span class="line">        $(&apos;body&apos;).append(res);</span><br><span class="line">    &#125;</span><br><span class="line">    error:function(err)&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">complete:function(xhr)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function foo(data)&#123;</span><br><span class="line">console.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//服务器http://localhost:3000代码</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const app = express();</span><br><span class="line">const bodyParser = require(&apos;body-parser&apos;);</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended:false&#125;));</span><br><span class="line"></span><br><span class="line">app.use(express.static(&apos;views&apos;));</span><br><span class="line"></span><br><span class="line">app.listen(3000,()=&gt;&#123;</span><br><span class="line">    console.log(&apos;running...&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//服务器http://localhost:8888代码</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const app = express();</span><br><span class="line">const bodyParser = require(&apos;body-parser&apos;);</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended:false&#125;));</span><br><span class="line"></span><br><span class="line">app.get(&apos;/getJsonp&apos;,(req,res)=&gt;&#123;</span><br><span class="line">    res.send(&apos;foo(&quot;你拿到了http://localhost:8888的jsonp&quot;);&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(8888,()=&gt;&#123;</span><br><span class="line">    console.log(&apos;running...&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="8-结束语"><a href="#8-结束语" class="headerlink" title="8.结束语"></a>8.结束语</h2><p>AJAX是通过<code>XMLHttpRequest</code>或者封装后的框架进行网络请求，由于这种方式的配置和调用方式非常混乱，已被Fetch取代</p>]]></content>
    
    <summary type="html">
    
      AJAX
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="AJAX" scheme="http://yoursite.com/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>JS基础知识</title>
    <link href="http://yoursite.com/2019/02/05/js%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/02/05/js基本知识/</id>
    <published>2019-02-05T13:25:25.000Z</published>
    <updated>2020-01-26T13:42:33.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS基础知识"><a href="#JS基础知识" class="headerlink" title="JS基础知识"></a>JS基础知识</h2><h3 id="1-JavaScript-是什么？"><a href="#1-JavaScript-是什么？" class="headerlink" title="1.JavaScript 是什么？"></a>1.JavaScript 是什么？</h3><ul><li>JavaScript 是一种轻量级的编程语言。</li><li>JavaScript 是可插入 HTML 页面的编程代码。</li><li>JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。</li></ul><h3 id="2-js的基本数据类型"><a href="#2-js的基本数据类型" class="headerlink" title="2.js的基本数据类型"></a>2.js的基本数据类型</h3><ol><li>Number</li><li>String</li><li>null</li><li>undefined</li><li>Boolean</li></ol><p>复杂的数据类型：Array  Function  Object</p><h3 id="3-typeof的类型"><a href="#3-typeof的类型" class="headerlink" title="3.typeof的类型"></a>3.typeof的类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typeof &quot;John&quot;                 // 返回 string </span><br><span class="line">typeof 3.14                   // 返回 number</span><br><span class="line">typeof NaN                    // 返回 number</span><br><span class="line">typeof false                  // 返回 boolean</span><br><span class="line">typeof [1,2,3,4]              // 返回 object</span><br><span class="line">typeof &#123;name:&apos;John&apos;, age:34&#125;  // 返回 object</span><br><span class="line">typeof new Date()             // 返回 object</span><br><span class="line">typeof function () &#123;&#125;         // 返回 function</span><br><span class="line">typeof myCar                  // 返回 undefined (如果 myCar 没有声明)</span><br><span class="line">typeof null                   // 返回 object</span><br></pre></td></tr></table></figure><p><code>typeof只能区分值类型，对引用类型无能为力，只能区分函数function</code><br><code>NaN</code>表示特殊的非数字值，<code>null</code>是空指针，并没有指向任何一个地址<br><code>typeof</code>能区分的五种基本类型：<code>string</code>、<code>boolean</code>、<code>number</code>、<code>undefined</code>、<code>symbol</code>和函数<code>function</code></p><h3 id="4-判断一个变量是否为数组"><a href="#4-判断一个变量是否为数组" class="headerlink" title="4.判断一个变量是否为数组"></a>4.判断一个变量是否为数组</h3><ol><li><p>instanceof 判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4];</span><br><span class="line">console.log(arr instanceof Array)//true;</span><br></pre></td></tr></table></figure></li><li><p>原型链方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,23,4];</span><br><span class="line">console.log(arr.__proto__.constructor==Array);//true</span><br><span class="line">console.log(arr.constructor==Array)//true 这两段代码是一样的</span><br></pre></td></tr></table></figure></li><li><p>Object.prototype.toString 的用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function isArray(o)&#123;</span><br><span class="line">return Object.prototype.toString.call(o)==&apos;[object Array]&apos;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(isArray(ary));</span><br></pre></td></tr></table></figure></li><li><p>Array.isArray()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray([1, 2, 3]);  </span><br><span class="line">// true</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-use-strict严格模式"><a href="#5-use-strict严格模式" class="headerlink" title="5.use strict严格模式"></a>5.use strict严格模式</h3><p><code>&quot;use strict&quot;</code> 是 <strong>ES5</strong> 特性，它使我们的代码在函数或整个脚本中处于<strong>严格模式</strong>。<strong>严格模式</strong>帮助我们在代码的早期避免 bug，并为其添加限制。</p><p><strong>严格模式</strong>的一些限制：</p><ol><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用<code>with</code>语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀 0 表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li><li><code>eval</code>不能在它的外层作用域引入变量</li><li><code>eval</code>和<code>arguments</code>不能被重新赋值</li><li><code>arguments</code>不会自动反映函数参数的变化</li><li>不能使用<code>arguments.callee</code></li><li>不能使用<code>arguments.caller</code></li><li>禁止<code>this</code>指向全局对象</li><li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li><li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li></ol><p>设立”严格模式”的目的，主要有以下几个：</p><ol><li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的Javascript做好铺垫。</li></ol><h3 id="6-JS数组方法"><a href="#6-JS数组方法" class="headerlink" title="6.JS数组方法"></a>6.JS数组方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Array.concat( ) 连接数组</span><br><span class="line">Array.join( ) 将数组元素连接起来以构建一个字符串</span><br><span class="line">Array.length 数组的大小</span><br><span class="line">Array.pop( ) 删除并返回数组的最后一个元素</span><br><span class="line">Array.push( ) 给数组添加元素</span><br><span class="line">Array.reverse( ) 颠倒数组中元素的顺序</span><br><span class="line">Array.shift( ) 将元素移出数组</span><br><span class="line">Array.slice( ) 返回数组的一部分</span><br><span class="line">Array.sort( ) 对数组元素进行排序</span><br><span class="line">Array.splice( ) 插入、删除或替换数组的元素</span><br><span class="line">Array.toLocaleString( ) 把数组转换成局部字符串</span><br><span class="line">Array.toString( ) 将数组转换成一个字符串</span><br><span class="line">Array.unshift( ) 在数组头部插入一个元素</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      js基本知识
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/23/Tomcat%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/01/23/Tomcat安装和使用/</id>
    <published>2019-01-23T12:16:30.000Z</published>
    <updated>2020-01-26T08:39:32.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tomcat安装和使用"><a href="#Tomcat安装和使用" class="headerlink" title="Tomcat安装和使用"></a>Tomcat安装和使用</h2><p>安装JDK步骤及配置JDK环境变量步骤省略。</p><h3 id="一下载安装。"><a href="#一下载安装。" class="headerlink" title="一下载安装。"></a>一下载安装。</h3><h4 id="1-官网下载"><a href="#1-官网下载" class="headerlink" title="1.官网下载"></a>1.官网下载</h4><p><img src="https://s2.ax1x.com/2020/01/24/1ZcTtx.png" alt></p><h4 id="2-文件减压"><a href="#2-文件减压" class="headerlink" title="2.文件减压"></a>2.文件减压</h4><p><img src="https://s2.ax1x.com/2020/01/24/1ZgXGV.png" alt></p><h3 id="二使用Tomcat"><a href="#二使用Tomcat" class="headerlink" title="二使用Tomcat"></a>二使用Tomcat</h3><ol><li><p>先解压下载的压缩包、然后在bin目录下找到startup.bat文件、并用鼠标双击此文件</p></li><li><p>然后在浏览器中输入<code>http://localhost:8080</code>回车后，显示如下界面：此时就说明Tomcat服务启动正常了。</p><p><img src="https://s2.ax1x.com/2020/01/26/1mslTI.jpg" alt></p><p>​</p></li><li><p>将打包后的文件放入<code>webapps</code>目录下在此启动Tomcat访问8080端口即可。</p></li></ol>]]></content>
    
    <summary type="html">
    
      Tomcat
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>CSS3动画</title>
    <link href="http://yoursite.com/2019/01/03/CSS3%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/01/03/CSS3动画/</id>
    <published>2019-01-03T12:55:30.000Z</published>
    <updated>2020-01-24T12:18:00.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS3动画"><a href="#CSS3动画" class="headerlink" title="CSS3动画"></a>CSS3动画</h2><p>通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。</p><p>###1.CSS3的@keyframes 规则</p><p>@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。</p><p>@keyframes 中创建动画时，请把它捆绑到某个选择器，否则不会产生动画效果。通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器：</p><ul><li>规定动画的名称</li><li>规定动画的时长</li></ul><h3 id="2-CSS3-中动画的使用"><a href="#2-CSS3-中动画的使用" class="headerlink" title="2.CSS3 中动画的使用"></a>2.CSS3 中动画的使用</h3><p>动画是使元素从一种样式逐渐变化为另一种样式的效果。</p><p>您可以改变任意多的样式任意多的次数。</p><p>请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。</p><p>0% 是动画的开始，100% 是动画的完成。</p><p>为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。</p><p>动画是使元素从一种样式逐渐变化为另一种样式的效果。</p><p>您可以改变任意多的样式任意多的次数。</p><p>请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。</p><p>0% 是动画的开始，100% 是动画的完成。</p><p>为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;style&gt; </span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">width:100px;</span><br><span class="line">height:100px;</span><br><span class="line">background:red;</span><br><span class="line">animation:myfirst 5s;</span><br><span class="line">-moz-animation:myfirst 5s; /* Firefox */</span><br><span class="line">-webkit-animation:myfirst 5s; /* Safari and Chrome */</span><br><span class="line">-o-animation:myfirst 5s; /* Opera */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes myfirst</span><br><span class="line">&#123;</span><br><span class="line">from &#123;background:red;&#125;</span><br><span class="line">to &#123;background:yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes myfirst /* Firefox */</span><br><span class="line">&#123;</span><br><span class="line">from &#123;background:red;&#125;</span><br><span class="line">to &#123;background:yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes myfirst /* Safari and Chrome */</span><br><span class="line">&#123;</span><br><span class="line">from &#123;background:red;&#125;</span><br><span class="line">to &#123;background:yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-o-keyframes myfirst /* Opera */</span><br><span class="line">&#123;</span><br><span class="line">from &#123;background:red;&#125;</span><br><span class="line">to &#123;background:yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;本例在 Internet Explorer 中无效。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="3-CSS3-动画属性"><a href="#3-CSS3-动画属性" class="headerlink" title="3.CSS3 动画属性"></a>3.CSS3 动画属性</h3><ul><li><p>animation (所有动画属性的简写属性，除了 animation-play-state 属性)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">animation: name duration timing-function delay iteration-count direction;</span><br><span class="line">animation: demo 3s liner 0.2 iteration-count direction;</span><br></pre></td></tr></table></figure></li><li><p>animation-name(为 @keyframes 动画指定名称)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation-name: keyframename|none;</span><br></pre></td></tr></table></figure></li><li><p>animation-duration(定义动画完成一个周期需要多少秒或毫秒)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation-duration: time;</span><br></pre></td></tr></table></figure></li><li><p>animation-timing-function(指定动画将如何完成一个周期）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">animation-timing-function: value;</span><br><span class="line"></span><br><span class="line">linear动画从头到尾的速度是相同的。</span><br><span class="line">ease默认。动画以低速开始，然后加快，在结束前变慢。</span><br><span class="line">ease-in动画以低速开始。</span><br><span class="line">ease-out动画以低速结束。</span><br><span class="line">ease-in-out动画以低速开始和结束。</span><br><span class="line">cubic-bezier(n,n,n,n)在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。</span><br></pre></td></tr></table></figure></li><li><p>animation-delay (定义动画什么时候开始)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation-delay: time;</span><br></pre></td></tr></table></figure></li><li><p>animation-iteration-count(定义动画应该播放多少次)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animation-iteration-count: value;</span><br><span class="line"></span><br><span class="line">n一个数字，定义应该播放多少次动画</span><br><span class="line">infinite指定动画应该播放无限次（永远）</span><br></pre></td></tr></table></figure></li><li><p>animation-direction (定义是否循环交替反向播放动画)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">animation-direction: normal|reverse|alternate|alternate-reverse|initial|inherit;</span><br><span class="line"></span><br><span class="line">normal默认值。动画按正常播放。</span><br><span class="line">reverse动画反向播放。</span><br><span class="line">alternate动画在奇数次（1、3、5...）正向播放，在偶数次（2、4、6...）反向播放。</span><br><span class="line">alternate-reverse 动画在奇数次（1、3、5...）反向播放，在偶数次（2、4、6...）正向播放。</span><br><span class="line">initial设置该属性为它的默认值。</span><br><span class="line">inherit从父元素继承该属性。</span><br></pre></td></tr></table></figure></li><li><p>animation–play-state(指定动画是否正在运行或已暂停)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animation-play-state: paused|running;</span><br><span class="line"></span><br><span class="line">paused指定暂停动画</span><br><span class="line">running指定正在运行的动画</span><br></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      CSS3动画
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="css3" scheme="http://yoursite.com/tags/css3/"/>
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>前端兼容性问题小结</title>
    <link href="http://yoursite.com/2018/12/21/%E5%89%8D%E7%AB%AF%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2018/12/21/前端兼容性问题小结/</id>
    <published>2018-12-21T12:45:30.000Z</published>
    <updated>2020-01-24T12:18:06.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端兼容性问题小结"><a href="#前端兼容性问题小结" class="headerlink" title="前端兼容性问题小结"></a>前端兼容性问题小结</h2><h3 id="1-不同浏览器的标签默认的外补丁和内补丁不同"><a href="#1-不同浏览器的标签默认的外补丁和内补丁不同" class="headerlink" title="1.不同浏览器的标签默认的外补丁和内补丁不同"></a>1.不同浏览器的标签默认的外补丁和内补丁不同</h3><p>问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。</p><p>碰到频率:100%</p><p>解决方案：CSS里    *{margin:0;padding:0;}，或使用第三方css文件重置。</p><p>备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。</p><h3 id="2-图片默认有间距"><a href="#2-图片默认有间距" class="headerlink" title="2.图片默认有间距"></a>2.图片默认有间距</h3><p>问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。</p><p>碰到几率：20%</p><p>解决方案：使用float属性为img布局</p><p>备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（我的一个学生使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以我禁止他们使用）</p><p>###3.IE9一下浏览器不能使用opacity</p><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">opacity: 0.5;</span><br><span class="line">filter:alpha(opacity = 50);</span><br><span class="line">filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50);</span><br></pre></td></tr></table></figure><h3 id="4-IE6-背景闪烁的问题"><a href="#4-IE6-背景闪烁的问题" class="headerlink" title="4.IE6 背景闪烁的问题"></a>4.IE6 背景闪烁的问题</h3><p>问题：链接、按钮用 <code>CSSsprites</code> 作为背景，在 <code>ie6</code> 下会有背景图闪烁的现象。原因是 <code>IE6</code> 没有将背景图缓存，每次触发 <code>hover</code> 的时候都会重新加载</p><p>解决：可以用 <code>JavaScript</code> 设置 <code>ie6</code> 缓存这些图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.execCommand(&quot;BackgroundImageCache&quot;, false, true);</span><br></pre></td></tr></table></figure><h3 id="5-键盘事件-keyCode-兼容性写法"><a href="#5-键盘事件-keyCode-兼容性写法" class="headerlink" title="5.键盘事件 keyCode 兼容性写法"></a>5.键盘事件 <code>keyCode</code> 兼容性写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var inp = document.getElementById(&apos;inp&apos;)</span><br><span class="line">var result = document.getElementById(&apos;result&apos;)</span><br><span class="line"></span><br><span class="line">function getKeyCode(e) &#123;</span><br><span class="line">  e = e ? e : (window.event ? window.event : &quot;&quot;)</span><br><span class="line">  return e.keyCode ? e.keyCode : e.which</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inp.onkeypress = function(e) &#123;</span><br><span class="line">  result.innerHTML = getKeyCode(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-DOM-事件处理程序的兼容写法"><a href="#6-DOM-事件处理程序的兼容写法" class="headerlink" title="6.DOM 事件处理程序的兼容写法"></a>6.DOM 事件处理程序的兼容写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">var eventshiv = &#123;</span><br><span class="line">    // event兼容</span><br><span class="line">    getEvent: function(event) &#123;</span><br><span class="line">        return event ? event : window.event;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">// &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;兼容</span><br><span class="line">getType: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(event) &#123;</span><br><span class="line">    &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; event.type;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// target兼容</span><br><span class="line">getTarget: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(event) &#123;</span><br><span class="line">    &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; event.target ? event.target : event.srcelem;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 添加事件句柄</span><br><span class="line">addHandler: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(elem, &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener) &#123;</span><br><span class="line">    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (elem.addEventListener) &#123;</span><br><span class="line">        elem.addEventListener(&lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);</span><br><span class="line">    &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (elem.attachEvent) &#123;</span><br><span class="line">        elem.attachEvent(&lt;span class=&quot;hljs-string&quot;&gt;&apos;on&apos;&lt;/span&gt; + &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener);</span><br><span class="line">    &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &#123;</span><br><span class="line">        // 在这里由于.与&lt;span class=&quot;hljs-string&quot;&gt;&apos;on&apos;&lt;/span&gt;字符串不能链接，只能用 []</span><br><span class="line">        elem[&lt;span class=&quot;hljs-string&quot;&gt;&apos;on&apos;&lt;/span&gt; + &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;] = listener;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 移除事件句柄</span><br><span class="line">removeHandler: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(elem, &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener) &#123;</span><br><span class="line">    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (elem.removeEventListener) &#123;</span><br><span class="line">        elem.removeEventListener(&lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);</span><br><span class="line">    &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (elem.detachEvent) &#123;</span><br><span class="line">        elem.detachEvent(&lt;span class=&quot;hljs-string&quot;&gt;&apos;on&apos;&lt;/span&gt; + &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener);</span><br><span class="line">    &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &#123;</span><br><span class="line">        elem[&lt;span class=&quot;hljs-string&quot;&gt;&apos;on&apos;&lt;/span&gt; + &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;] = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 添加事件代理</span><br><span class="line">addAgent: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (elem, &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, agent, listener) &#123;</span><br><span class="line">    elem.addEventListener(&lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (e) &#123;</span><br><span class="line">        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (e.target.matches(agent)) &#123;</span><br><span class="line">            listener.call(e.target, e); // this 指向 e.target</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 取消默认行为</span><br><span class="line">preventDefault: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(event) &#123;</span><br><span class="line">    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (event.preventDefault) &#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &#123;</span><br><span class="line">        event.returnValue = &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 阻止事件冒泡</span><br><span class="line">stopPropagation: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(event) &#123;</span><br><span class="line">    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (event.stopPropagation) &#123;</span><br><span class="line">        event.stopPropagation();</span><br><span class="line">    &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &#123;</span><br><span class="line">        event.cancelBubble = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      前端兼容性问题小结
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="兼容性" scheme="http://yoursite.com/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>css知识点小结(2)</title>
    <link href="http://yoursite.com/2018/12/13/css%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93-2/"/>
    <id>http://yoursite.com/2018/12/13/css知识点小结-2/</id>
    <published>2018-12-13T12:42:33.000Z</published>
    <updated>2020-01-23T06:01:48.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="css知识点小结-2"><a href="#css知识点小结-2" class="headerlink" title="css知识点小结(2)"></a>css知识点小结(2)</h2><h3 id="1-文本超出部分显示省略号"><a href="#1-文本超出部分显示省略号" class="headerlink" title="1.文本超出部分显示省略号"></a>1.文本超出部分显示省略号</h3><p>单行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">overflow:hidden；</span><br><span class="line">text-overflow:ellipsis;</span><br><span class="line">white-space:nowarp;</span><br></pre></td></tr></table></figure><p>多行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display: -webkit-box;</span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line">-webkit-line-clamp: 3; // 最多显示几行</span><br><span class="line">overflow: hidden;</span><br></pre></td></tr></table></figure><p>###2.优雅降级和渐进增强</p><p><strong>优雅降级：</strong></p><ul><li>Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。</li></ul><p><strong>渐进增强：</strong></p><ul><li><p>从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</p><p>如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；</p></li></ul><h3 id="3-transition和animation的区别"><a href="#3-transition和animation的区别" class="headerlink" title="3.transition和animation的区别"></a>3.transition和animation的区别</h3><ul><li>transition是过渡动画，animation是帧动画。</li><li>transition只能从一种状态过渡到另外一种状态，animation可以定制复杂动画(多个帧)，可以定义动画的区间等。</li><li>transition必须通过一些行为才能触发（js或者伪类来触发），animation的话直接就可以触发。</li></ul><h3 id="4-margin-left-calc-100-100px-代码中calc（）作用"><a href="#4-margin-left-calc-100-100px-代码中calc（）作用" class="headerlink" title="4.margin-left:calc(-100%-100px) 代码中calc（）作用"></a>4.margin-left:calc(-100%-100px) 代码中calc（）作用</h3><ul><li>通过计算来确定CSS属性值。</li><li>calc是英文单词calculate(计算)的缩写，是css3的一个新增的功能，你可以使用calc()给元素的border、margin、pading、font-size和width等属性设置动态值。calc()可以使用数学运算中的简单加（+）、减（-）、乘（）和除（/）来解决问题，而且还可以根据单位如px,em,rem和百分比来转化计算</li></ul><h3 id="5-Sass、Less的区别？"><a href="#5-Sass、Less的区别？" class="headerlink" title="5. Sass、Less的区别？"></a>5. Sass、Less的区别？</h3><p>CSS 预处理，他们是动态的样式语言。他们规定了一种特殊的语法并且内置了编译器，可以将less/sass写的代码通过编译器编译成 CSS。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Less和Sass的区别：</span><br><span class="line">1.变量符不一样，less 是@，而 Sass 是$;</span><br><span class="line">2.Sass支持条件语句，可以使用 if&#123;&#125;else&#123;&#125;,for&#123;&#125;循环等等。而 Less 不支持;</span><br><span class="line">3.Sass是基于Ruby，需要在服务端处理的；而Less是在客户端处理，需要引入less.js</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      css知识点小结
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>css知识点小结(1)</title>
    <link href="http://yoursite.com/2018/12/02/css%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93-1/"/>
    <id>http://yoursite.com/2018/12/02/css知识点小结-1/</id>
    <published>2018-12-02T11:30:30.000Z</published>
    <updated>2020-01-24T12:17:50.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="css知识点小结-1"><a href="#css知识点小结-1" class="headerlink" title="css知识点小结(1)"></a>css知识点小结(1)</h2><h3 id="1-css选择器优先级"><a href="#1-css选择器优先级" class="headerlink" title="1.css选择器优先级"></a>1.css选择器优先级</h3><p><strong>选择器的特殊性值表述为4个部分，用0,0,0,0表示，权重计算规则如下：</strong></p><ul><li>行间样式        1,0,0,0</li><li>ID选择器         0,1,0,0</li><li>类选择器、属性选择器或伪类     0,0,1,0</li><li>元素和伪元素    0,0,0,1</li></ul><p>最后比较特殊的一个标志<strong>!important</strong>（权重），它没有特殊性值，但它的优先级是<strong>最高的</strong></p><h3 id="2块格式化上下文（Block-Formatting-Context）及其工作原理"><a href="#2块格式化上下文（Block-Formatting-Context）及其工作原理" class="headerlink" title="2块格式化上下文（Block Formatting Context）及其工作原理"></a>2块格式化上下文（Block Formatting Context）及其工作原理</h3><p><strong>块格式上下文（BFC）是它是一个独立的渲染区域，容器里面的子元素不会影响到外面的元素。</strong></p><p>BFC特性</p><ol><li>在BFC中，盒子从顶端开始垂直地一个接一个地排列。</li><li>盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠。</li><li>在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。</li><li>BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。</li><li>计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。</li></ol><p><strong>如何触发BFC</strong></p><ul><li><code>float</code>的值不是<code>none</code>.</li><li><code>position</code>的值不是<code>static</code>或<code>relative</code>.</li><li><code>display</code>的值是<code>table-cell</code>、<code>table-caption</code>、<code>inline-block</code>、<code>flex</code>、或<code>inline-flex</code>。</li><li><code>overflow</code>的值不是<code>visible</code>。</li></ul><h3 id="3-如何清除浮动"><a href="#3-如何清除浮动" class="headerlink" title="3.如何清除浮动"></a>3.如何清除浮动</h3><ul><li>空div方法，在父盒子最后加一个空盒子并且加上clear:both<code>&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;</code></li><li>伪元素法，使用伪元素定义一个clearfix的样式类，然后使用<code>&lt;div class=&quot;clearfix&quot;&gt;</code></li><li>给父亲设置<code>overflow: auto</code>或<code>overflow: hidden</code>等方法（触发BFC）。</li><li>给父元素指定高度。</li></ul><h3 id="4-外边距重叠（外边距坍塌）"><a href="#4-外边距重叠（外边距坍塌）" class="headerlink" title="4.外边距重叠（外边距坍塌）"></a>4.外边距重叠（外边距坍塌）</h3><p><strong>在 CSS 当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。</strong></p><p>折叠结果遵循下列计算规则：</p><ol><li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li><li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li><li>两个外边距一正一负时，折叠结果是两者的相加的和。</li></ol><h3 id="5-伪元素及其使用"><a href="#5-伪元素及其使用" class="headerlink" title="5.伪元素及其使用"></a>5.伪元素及其使用</h3><p><strong>伪元素指的是两个冒号的选择器   div::before   div::after    p::first-letter</strong></p><p>伪元素的用途：</p><p>1.用after清除浮动</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class="clear-fix"&gt;</span><br><span class="line">   &lt;div&gt; &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-tag">clear-fix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">        <span class="attribute">clear</span>: both;</span><br><span class="line">        <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">        <span class="attribute">display</span>: block;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">overflow</span>: hidden</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用伪类实现简单图标</li><li>元素 hover 特效</li></ol><h3 id="6-flex布局中的属性"><a href="#6-flex布局中的属性" class="headerlink" title="6.flex布局中的属性"></a>6.flex布局中的属性</h3><p>在容器上可以设置6个属性：</p><ul><li>flex-direction    主轴方向</li><li>flex-wrap         主轴超出范围是否换行</li><li>flex-flow         flex-direction和flex-wrap的复合属性</li><li>justify-content   元素在主轴的对齐方式</li><li>align-items       元素在侧轴的对齐方式</li><li>align-content     元素在侧轴的对齐方式（多行）</li></ul><p>注意：当设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。</p><p>Flex 有六种属性可运用在 item 项目上:</p><ol><li>order            flex-item的排序</li><li>flex-basis       flex-item的宽度</li><li>flex-grow        flex-item占据剩余空间的比例</li><li>flex-shrink      flex-item占据收缩空间的比例</li><li>flex             flex-grow\flex-shrink\flex-basis的复合属性</li><li>align-self       规定flex-item自己的对齐方式</li></ol><h3 id="7-行内元素、块级元素"><a href="#7-行内元素、块级元素" class="headerlink" title="7.行内元素、块级元素"></a>7.行内元素、块级元素</h3><p>行内元素：在一行显示，不可以设置宽高。代表  span   a   input   select  strong</p><p>块级元素：换行显示，可以设置宽高。代表  div  dl  dd  dt  form   p   table  tr  th  td</p><p>行内块级元素：在一行显示，可以设置宽高。代表 img  input</p><h3 id="8-水平垂直居中的方式"><a href="#8-水平垂直居中的方式" class="headerlink" title="8.水平垂直居中的方式"></a>8.水平垂直居中的方式</h3><ol><li>flex布局</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display: flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">align-items: center;</span><br></pre></td></tr></table></figure><ol start="2"><li>position定位</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 父容器</span><br><span class="line">position: relative;</span><br><span class="line"></span><br><span class="line">// 子容器</span><br><span class="line">position:absolute;</span><br><span class="line">margin:auto;</span><br><span class="line">top:0;</span><br><span class="line">bottom:0;</span><br><span class="line">left:0;</span><br><span class="line">right:0;</span><br></pre></td></tr></table></figure><ol start="3"><li>position+transform</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 父容器</span><br><span class="line">position: relative;</span><br><span class="line"></span><br><span class="line">// 子容器</span><br><span class="line">position: absolute;</span><br><span class="line">top: 50%;</span><br><span class="line">left: 50%;</span><br><span class="line">transform: translate(-50%, -50%);</span><br></pre></td></tr></table></figure><ol start="4"><li>position+margin</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 父容器</span><br><span class="line">position: relative;</span><br><span class="line"></span><br><span class="line">// 子容器</span><br><span class="line">height: 50px;</span><br><span class="line">background-color: #21252b;</span><br><span class="line">position: absolute;</span><br><span class="line">margin: auto;</span><br><span class="line">top: 50%;</span><br><span class="line">left: 50%;</span><br><span class="line">margin-left: -25px;</span><br><span class="line">margin-top: -25px;</span><br></pre></td></tr></table></figure><h3 id="9-CSS中link和-import的区别"><a href="#9-CSS中link和-import的区别" class="headerlink" title="9.CSS中link和@import的区别"></a>9.CSS中link和@import的区别</h3><ul><li>link属于HTML标签，而@import是CSS提供的</li><li>页面加载时，link会同时被加载，而@import引用的CSS会等到页面加载完毕后再加载</li><li>import只在IE5以上被识别，存在兼容性问题，link无兼容性问题</li><li>link方式的样式的权重高于@import的权重</li></ul><h3 id="10-CSS的常用选择器"><a href="#10-CSS的常用选择器" class="headerlink" title="10.CSS的常用选择器"></a>10.CSS的常用选择器</h3><p>1.id选择器（#box）<br>2.类选择器（.box）<br>3.标签选择器（div）<br>4.相邻选择器（h1+p）<br>5.子选择器（ul&gt;li）<br>6.后代选择器（li  a）<br>7.通配符选择器（*）<br>8.属性选择器（a[attr=”d1”]）<br>9.伪类选择器（a:hover, li:nth-child）</p>]]></content>
    
    <summary type="html">
    
      css知识点小结
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>html知识点小结</title>
    <link href="http://yoursite.com/2018/11/25/html%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/11/25/html知识点总结/</id>
    <published>2018-11-25T12:15:50.000Z</published>
    <updated>2020-01-21T11:38:17.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="html知识点小结"><a href="#html知识点小结" class="headerlink" title="html知识点小结##"></a>html知识点小结##</h2><h3 id="1-语义化标签"><a href="#1-语义化标签" class="headerlink" title="1.语义化标签"></a>1.语义化标签</h3><p>简单的来说就是用正确的标签做正确的事情。</p><p>优点：</p><ul><li>见名知意，可读性好，方便代码的开发和维护。</li><li>有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。</li><li>方便其他设备解析，如盲人阅读器根据语义渲染网页</li></ul><h3 id="2-CSS-的-lt-link-gt-标签放在-lt-head-gt-lt-head-gt-之间？-JS-的-lt-script-gt-标签放在-lt-body-gt-之前"><a href="#2-CSS-的-lt-link-gt-标签放在-lt-head-gt-lt-head-gt-之间？-JS-的-lt-script-gt-标签放在-lt-body-gt-之前" class="headerlink" title="2. CSS 的&lt;link&gt;标签放在&lt;head&gt;&lt;/head&gt;之间？ JS 的&lt;script&gt;标签放在&lt;/body&gt;之前"></a>2. CSS 的<code>&lt;link&gt;</code>标签放在<code>&lt;head&gt;&lt;/head&gt;</code>之间？ JS 的<code>&lt;script&gt;</code>标签放在<code>&lt;/body&gt;</code>之前</h3><ul><li><p>把<code>&lt;link&gt;</code>放在 <code>&lt;head&gt;</code>中</p><p>这种做法可以让页面逐步呈现，提高了用户体验。如果将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。并且link会阻止页面渲染但是不会组织页面的加载。</p></li><li><p>把<code>&lt;script&gt;</code>标签恰好放在<code>&lt;/body&gt;</code>之前 </p><p>脚本在下载和执行期间会阻止 HTML 解析。把<code>&lt;script&gt;</code>标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户。</p></li></ul><h3 id="3-Reflow和Repaint（重绘和重排）"><a href="#3-Reflow和Repaint（重绘和重排）" class="headerlink" title="3.Reflow和Repaint（重绘和重排）"></a>3.Reflow和Repaint（重绘和重排）</h3><ul><li><p>Reflow：当涉及到DOM节点的布局属性发生变化时，就会重新计算该属性，浏览器会重新描绘相应的元素，此过程叫Reflow（回流或重排）。</p></li><li><p>Repaint：当影响DOM元素可见性的属性发生变化 (如 color) 时, 浏览器会重新描绘相应的元素, 此过程称为Repaint（重绘）。因此重排必然会引起重绘。</p><p>1- 调整窗口大小<br>2- 字体大小<br>3- 样式表变动<br>4- 元素内容变化，尤其是输入控件<br>5- CSS伪类激活，在用户交互过程中发生<br>6- DOM操作，DOM元素增删、修改<br>7- width, clientWidth, scrollTop等布局宽高的计算</p><p>Repaint和Reflow是不可避免的，只能说对性能的影响减到最小，给出下面几条建议：<br>1- 避免逐条更改样式。建议集中修改样式，例如操作className。<br>2- 避免频繁操作DOM。创建一个documentFragment或div，在它上面应用所有DOM操作，最后添加到文档里。设置      display:none的元素上操作，最后显示出来。<br>3- 避免频繁读取元素几何属性（例如scrollTop）。绝对定位具有复杂动画的元素。<br>4- 绝对定位使它脱离文档流，避免引起父元素及后续元素大量的回流</p></li></ul><h3 id="4-href和src区别"><a href="#4-href和src区别" class="headerlink" title="4.href和src区别"></a>4.href和src区别</h3><p><strong>它们之间的主要区别可以用这样一句话来概括：src用于替代这个元素，而href用于建立这个标签与外部资源之间的关系。</strong></p><ul><li>href<br>href标识超文本引用，用在link和a等元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系<br>若在文档中添加href ，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。</li><li>src<br>src表示引用资源，替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分。<br><br>当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。</li></ul><p>使用场景</p><ul><li>引用css文件时：<code>href=&quot;cssfile.css&quot;</code></li><li>引用js文件时：<code>src=&quot;myscript.js&quot;</code></li><li>引用图片：<code>src=&quot;mypic.jpg&quot;</code></li><li>网站链接：<code>href=&quot;http://www.webpage.com&quot;</code></li></ul><h3 id="5-浏览器的渲染过程"><a href="#5-浏览器的渲染过程" class="headerlink" title="5.浏览器的渲染过程"></a>5.浏览器的渲染过程</h3><ol><li>解析HTML生成DOM树。</li><li>解析CSS生成CSSOM规则树。</li><li>将DOM树与CSSOM规则树合并在一起生成渲染树。</li><li>遍历渲染树开始布局，计算每个节点的位置大小信息。</li><li>将渲染树每个节点绘制到屏幕。</li></ol><h3 id="6-doctype有什么用"><a href="#6-doctype有什么用" class="headerlink" title="6.doctype有什么用"></a>6.doctype有什么用</h3><p>DOCTYPE是document type的简写，它并不是 HTML 标签，也没有结束标签，它是一种标记语言的文档类型声明，即告诉浏览器当前 HTML 是用什么版本编写的。</p><p>1.告知浏览器文档使用哪种 HTML 或 XHTML 规范。</p><p>2.告诉浏览器按照何种规范解析页（如果你的页面没有DOCTYPE的声明，那么浏览器会进入Quirks模式）</p><h3 id="7-优化图片加载的方法"><a href="#7-优化图片加载的方法" class="headerlink" title="7.优化图片加载的方法"></a>7.优化图片加载的方法</h3><ol><li>图片懒加载。</li><li>使用icon和精灵图技术。</li><li>使用其他服务器单独存放图片。</li><li>如果图片过大，可以使用特殊编码的图片（base64编码）</li></ol><h3 id="8-常见的浏览器内核有哪些"><a href="#8-常见的浏览器内核有哪些" class="headerlink" title="8.常见的浏览器内核有哪些"></a>8.常见的浏览器内核有哪些</h3><p>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]</p><p>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等</p><p>Presto内核：Opera7及以上。     [Opera内核原为：Presto，现为：Blink;]</p><p>Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]</p><h3 id="9-SEO中的TDK"><a href="#9-SEO中的TDK" class="headerlink" title="9.SEO中的TDK"></a>9.SEO中的TDK</h3><p>网页标题(title)：用于告诉用户和搜索引擎当前页面的核心内容，title是搜索引擎根据用户检索关键词进行排名的核心指标，一般标题中含有搜索的关键词才能获得较好的排名;</p><p>页面描述(description)：显示在搜索结果中，以百度为例如下图，用于告知用户网站页面的主要内容，作为引导用户点击的索引;</p><p>页面关键词(keywords)：告诉搜索引擎当前页面内容的关键词，用户无论在搜索结果还是浏览页面时都看不到页面关键词。</p><p><img src="/.com//html%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%5Ctdk.jpg" alt></p><p><img src="/.com//html%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%5Ctdk2.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      html知识点小结
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>First-Blog</title>
    <link href="http://yoursite.com/2018/11/12/First-Blog/"/>
    <id>http://yoursite.com/2018/11/12/First-Blog/</id>
    <published>2018-11-12T11:32:00.000Z</published>
    <updated>2020-01-19T15:27:15.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个人的第一篇博客"><a href="#个人的第一篇博客" class="headerlink" title="个人的第一篇博客"></a><strong>个人的第一篇博客</strong></h1><p>今天开启了个人博客，打算记录和分享一些关于生活，学习，以及技术方面的内容，也算是一个简单的记录吧。              个人还是希望把日语继续学下去，工作中英语也很重要，还有各种前端技术，所以不能停滞不前，需要保持高度的学习状态，好好加油吧！</p>]]></content>
    
    <summary type="html">
    
      默兽的第一篇博客
    
    </summary>
    
      <category term="随想" scheme="http://yoursite.com/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="第一篇博客" scheme="http://yoursite.com/tags/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
