{"meta":{"title":"Moshou","subtitle":null,"description":null,"author":"Moshou","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"client/index.html","permalink":"http://yoursite.com/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-10-15T00:10:32.000Z","comments":true,"path":"comment/index.html","permalink":"http://yoursite.com/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"donate/index.html","permalink":"http://yoursite.com/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"bangumi/index.html","permalink":"http://yoursite.com/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"lab/index.html","permalink":"http://yoursite.com/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"music/index.html","permalink":"http://yoursite.com/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-10-15T00:10:32.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-10-15T00:10:32.000Z","comments":true,"path":"rss/index.html","permalink":"http://yoursite.com/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"http://yoursite.com/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-10-15T00:10:32.000Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"video/index.html","permalink":"http://yoursite.com/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"RN端和H5双向通讯踩坑小结","slug":"RN端和H5双向通讯踩坑小结","date":"2020-02-04T10:39:56.000Z","updated":"2020-02-16T09:31:50.124Z","comments":true,"path":"2020/02/04/RN端和H5双向通讯踩坑小结/","link":"","permalink":"http://yoursite.com/2020/02/04/RN端和H5双向通讯踩坑小结/","excerpt":"","text":"RN端和H5双向通讯踩坑小结最近在做一个小功能，需要React Native中嵌套Html页面，并且要实现RN端和Html页面的数据交互。 所以利用到React Native 中的webview组件，但是官方将Webview移除了 这需要安装react-native-webview三方插件 问题就在这 采用三方react-native-webview插件的话 实现RN端和H5页面的数据通讯就多了很多坑 网上的各种博客都试了很多次 都会有不同的报错，在此做部分总结。 1.RN向H5页面发送消息1.1RN端注意点： 这里使用ref=&#39;webView&#39;获取 而不是ref={(webview) =&gt; { this.webview= webview }} 虽然React 不建议我们使用ref=&#39;webView&#39;但是这里我们需要使用这种方式，否则报错。 javaScriptEnabled={true}表示webview可识别js的代码 安卓端需要写。 injectJavaScript中是字符。 1234567891011121314151617import &#123; WebView &#125; from \"react-native-webview\";//向H5发送消息的方法postMessageToH5 = (data) =&gt; &#123; this.refs.webView.injectJavaScript(` (function()&#123; window.postMessage($&#123;JSON.stringify(data)&#125;,'*'); &#125;)(); true;`)&#125; &lt;WebView javaScriptEnabled=&#123;true&#125; startInLoadingState=&#123;true&#125; ref='webView' onLoadEnd=&#123;() =&gt; this.postMessageToH5('abc')&#125; //webview加载完毕后将abc发送到h5页面 source=&#123;&#123; uri: \"file:///android_asset/liveMessage.html\" &#125;&#125; /&gt; 1.2H5页面注意点： JSON.stringify(msg.data)需要格式转换 并且msg.data中才能获取到传来的数据。 window.addEventListener(&quot;message&quot;, function(msg) {})这里第一个参数就是message。 123456789window.onload = function() &#123; window.addEventListener(\"message\", function(msg) &#123; let data = JSON.stringify(msg.data); alert(data); var p = document.createElement(\"p\"); p.innerHTML = `&lt;span class=\"join\"&gt;$&#123;data&#125;&lt;/span&gt;`; divobj.appendChild(p); &#125;) &#125; 2.H5向RN页面发送消息 RN Webview onMessage 属性 注意点： 在 webview 内部的网页中调用 window.postMessage方法时可以触发此属性对应的函数，从而实现网页和 RN 之间的数据交换。 设置此属性的同时会在 webview中注入一个 postMessage 的全局函数并覆盖可能已经存在的同名实现。 网页端的window.postMessage只发送一个参数 data，此参数封装在 RN 端的 event 对象中，即 event.nativeEvent.data。data 只能是一个字符串。 webview组件 在被官方放弃之后，react-native-webview作为替换。react-native-webview 5.0 之后需要注入js 需要注入以下这段js 用以替换window.postMessage. H5 使用方法不变。 12345const injectedJavascript = `(function() &#123; window.postMessage = function(data) &#123; window.ReactNativeWebView.postMessage(data); &#125;;&#125;)()`; H5页面 H5发送消息，此时只能传递string类型 1window.postMessage(&apos;网页向rn发送的消息&apos;); RN端 react-native中接收消息 1onMessage=&#123;(event) =&gt; &#123;console.log(event.nativeEvent.data);&#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://yoursite.com/tags/React-Native/"},{"name":"H5","slug":"H5","permalink":"http://yoursite.com/tags/H5/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"React Hooks","slug":"React-Hooks","date":"2020-01-01T11:22:36.000Z","updated":"2020-02-06T12:33:20.003Z","comments":true,"path":"2020/01/01/React-Hooks/","link":"","permalink":"http://yoursite.com/2020/01/01/React-Hooks/","excerpt":"","text":"React Hooks1 简介 Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 2018年底FaceBook的React小组推出Hooks以来，所有的React的开发者都对它大为赞赏。React Hooks就是用函数的形式代替原来的继承类的形式，并且使用预函数的形式管理state，有Hooks可以不再使用类的形式定义组件了。这时候你的认知也要发生变化了，原来把组件分为有状态组件和无状态组件，有状态组件用类的形式声明，无状态组件用函数的形式声明。那现在所有的组件都可以用函数来声明了。 1.1 React Hooks编写形式对比写一个最简单的有状体组件，点我们点击按钮时，点击数量不断增加。 原始写法 123456789101112131415161718192021import React, &#123; Component &#125; from &apos;react&apos;;class Example extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; count:0 &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;this.addCount.bind(this)&#125;&gt;Chlick me&lt;/button&gt; &lt;/div&gt; ); &#125; addCount()&#123; this.setState(&#123;count:this.state.count+1&#125;) &#125;&#125;export default Example; Hooks写法 1234567891011import React, &#123; useState &#125; from &apos;react&apos;;function Example()&#123; const [ count , setCount ] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/button&gt; &lt;/div&gt; )&#125;export default Example; 我们可以看到第二个代码量更少，从这两个程序的对比上可以看出Hooks本质上就是一类特殊的函数，他们可以为你的函数型组件（function component）注入一些特殊的功能。 2 Hook API1.useState useState返回一个数组，第一个值为state，第二个值为状态管理函数 值得注意的是：为了使得状态的操作函数 与其他函数区别开且和其对应的状态联系起来，在命名上有如下约定规则： set + 状态名 如有状态count，则对应状态管理函数命名为 setCount 基本格式 1const [状态名, 状态管理函数] = useState(状态初始值); //结构赋值的形式 使用实例 123456789101112131415import React, &#123; useState &#125; from &apos;react&apos;;function Example() &#123; // 解构赋值获取useState返回的值，并给他们取名为count和setCount const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;&#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 2.useEffect Effect Hook 可以让你在函数组件中执行副作用操作 在用Class制作组件时，经常会用生命周期函数，来处理一些额外的事情（副作用：和函数业务主逻辑关联不大，特定时间或事件中执行的动作，比如Ajax请求后端数据，添加登录监听和取消登录，手动修改DOM等等）。在React Hooks中也需要这样类似的生命周期函数，比如在每次状态（State）更新时执行，它为我们准备了useEffect。 React首次渲染和之后的每次渲染都会调用一遍useEffect函数，而之前我们要用两个生命周期函数分别表示首次渲染(componentDidMonut)和更新导致的重新渲染(componentDidUpdate)。 useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而componentDidMonut和componentDidUpdate中的代码都是同步执行的。个人认为这个有好处也有坏处吧，比如我们要根据页面的大小，然后绘制当前弹出窗口的大小，如果时异步的就不好操作了。 基本格式 1234567891011121314//1 组件初次渲染后执行一次，依赖项每次改变时执行一次useEffect(()=&gt;&#123; //副作用动作&#125;,[依赖项])//2 组件初次渲染后执行一次useEffect(()=&gt;&#123; //副作用动作 数组为空&#125;,[])//3 组件初次渲染后执行一次，组件每次更新后执行一次useEffect(()=&gt;&#123; //副作用动作&#125;) 使用实例 123456789101112131415161718192021222324import React, &#123; useState, useEffect, useRef &#125; from &apos;react&apos;export default function Example() &#123; const [count, setCount] = useState(0); const [val, setVal] = useState(0); const num = useRef(0); useEffect(()=&gt;&#123; console.log(&apos;1&apos;) &#125;,[count]); useEffect(()=&gt;&#123; console.log(&apos;2&apos;) &#125;,[]); useEffect(()=&gt;&#123; console.log(&apos;3&apos;) &#125;); return &lt;div&gt; &lt;button onClick=&#123;()=&gt;&#123;setCount(count + 1)&#125;&#125;&gt;COUNT&lt;/button&gt; &lt;button onClick=&#123;()=&gt;&#123;setVal(val + 1)&#125;&#125;&gt;VAL&lt;/button&gt; &lt;button onClick=&#123;()=&gt;&#123;num.current += 1&#125;&#125;&gt;NUM&lt;/button&gt; &lt;/div&gt;&#125; 12345678910111213//该组件初次渲染后的执行结果123//点击一次 COUNT按钮 后的执行结果13//点击一次 VAL按钮 后的执行结果3//点击一次 NUM按钮 后的执行结果 12345678910function Index() &#123; useEffect(()=&gt;&#123; console.log(&apos;come-index&apos;); return ()=&gt; &#123; console.log(&apos;out-index&apos;); &#125; &#125;,[]) //useEffect 第一个参数箭头函数 第二个参数是个数组 // 数组为空时表示当组件销毁时才会执行useEffect中的return的箭头函数 return &lt;h2&gt;Index&lt;/h2&gt;&#125; 3. useMemo与useCallback 当组件state被修改时就会触发组件的重新渲染，无论前后state是否一致 父组件更新，子组件会自动更新 组件更新时，会卸载所有function，并重新创建function 这就出现了性能问题，当更新前后状态一致时，是无需更新的。 在之前使用生命周期时，我们通常的解决方案是调用生命周期钩子函数shouldComponentUpdate来判断新老props、states是否发生变化来决定当前组件是否需要更新（原理可参见 React 的 Diff） Hooks出现后，我们可以直接使用function的形式来创建组件状态，但function自身并没有shouldComponentUpdate判断前后状态的能力。并且，每当函数组件被调用都会执行内部的所有的逻辑，其性能损耗显而易见。 useMemo 与 useCallback 的区别与联系 实际上useCallback是基于useMemo实现的 123function useCallback(callback, args) &#123; return useMemo(() =&gt; callback, args);&#125; useMemo是返回callback执行后的结果 useCallback 是直接返回被useMemo修饰的callback函数 （1）useMemo123456789101112131415161718192021import React from &apos;react&apos;;export default function WithoutMemo() &#123; const [count, setCount] = useState(1); const [val, setValue] = useState(&apos;&apos;); function expensive() &#123; console.log(&apos;compute&apos;); let sum = 0; for (let i = 0; i &lt; count * 100; i++) &#123; sum += i; &#125; return sum; &#125; return &lt;div&gt; &lt;h4&gt;&#123;count&#125;-&#123;val&#125;-&#123;expensive()&#125;&lt;/h4&gt; &lt;div&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+c1&lt;/button&gt; &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.target.value)&#125;/&gt; &lt;/div&gt; &lt;/div&gt;;&#125; 在这个组件中含有一个计算量很大的函数expensive，当我们修改 conut val任意一个状态时，expensive都会被触发，尽管val与expensive的计算毫无关系。 使用useMemo来解决该问题 1234567891011121314151617181920212223import React from &apos;react&apos;;export default function WithoutMemo() &#123; const [count, setCount] = useState(1); const [val, setValue] = useState(&apos;&apos;); //使用useMemo const expensive = useMemo(() &#123; console.log(&apos;compute&apos;); let sum = 0; for (let i = 0; i &lt; count * 100; i++) &#123; sum += i; &#125; return sum; &#125;,[count]) return &lt;div&gt; &lt;h4&gt;&#123;count&#125;-&#123;val&#125;-&#123;expensive&#125;&lt;/h4&gt; &lt;div&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+c1&lt;/button&gt; &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.target.value)&#125;/&gt; &lt;/div&gt; &lt;/div&gt;;&#125; 我们可知，expensive的计算只与count相关，则可使用useMome添加依赖值count 当且仅当count发生有效改变时才会执行相应函数，并返回缓存值给expensive （2）useCallbackuseCallback的特点、作用和用法与useMemo类似，但是他返回一个缓存的函数。 除了利用useMemo和useCallback的缓存特性以达到 ”减少某函数不必要的计算“ 外，还可以利用这特性实现 “避免子组件不必要的更新”，这里以useCallback为例 1234567891011121314151617181920212223import React, &#123; useState, useCallback, useEffect &#125; from &apos;react&apos;;function Parent() &#123; const [count, setCount] = useState(1); const [val, setVal] = useState(&apos;&apos;); const callback = useCallback(() =&gt; &#123; return count; &#125;, [count]); return &lt;div&gt; &lt;h4&gt;&#123;count&#125;- &#123;val&#125;&lt;/h4&gt; &lt;Child callback=&#123;callback&#125;/&gt; &lt;/div&gt;;&#125; function Child(&#123; callback &#125;) &#123; const [count, setCount] = useState(() =&gt; callback()); useEffect(() =&gt; &#123; setCount(callback()); &#125;, [callback]); return &lt;div&gt; &#123;count&#125; &lt;/div&gt;&#125; 例子中的Child组件中 是依赖于父组件传递来的callback来创建的函数，一旦父组件中的callback发生改变则Child组件就会发生更新，若父组件中的callback不使用useCallback来封装，则父组件中的任意变量发生改变都会导致callback的变化进而导致子组件不必要的更新。 此外，所有依赖state或props来创建的函数，需要用到缓存函数的地方都是useCallback的使用场景。 踩坑记录 使用lodash中的debounced 123456789101112131415161718192021import React, &#123; useState &#125; from &apos;react&apos;import &#123; debounce &#125; from &apos;lodash&apos;const Example = () =&gt; &#123; const [value, setValue] = useState(&apos;&apos;); const _debounce = debounce((value)=&gt;&#123; console.log(value) &#125;,3000); const _onChange = (e) =&gt; &#123; let value = e.target.value; setValue(value) _debounce(value); &#125; return &lt;div&gt; &lt;input type=&quot;text&quot; onChange=&#123;_onChange&#125; value=&#123;value&#125; /&gt; &lt;/div&gt;&#125;export default Example 每当onChange被触发一次，都会执行setValue，进而导致刷新组件，使得每次都生成新的debounce，这就失去了函数防抖的效果。而此处的矛盾点就是“函数刷新导致生成了新的debounce”，这里就可以使用useCallback来解决。 123456789101112131415161718192021import React, &#123; useState, useCallback &#125; from &apos;react&apos;import &#123; debounce &#125; from &apos;lodash&apos;const Example = () =&gt; &#123; const [value, setValue] = useState(&apos;&apos;); const _debounce = useCallback(debounce((value)=&gt;&#123; console.log(value); &#125;,3000),[]); const _onChange = (e) =&gt; &#123; let value = e.target.value; setValue(value); _debounce(value); &#125; return &lt;div&gt; &lt;input type=&quot;text&quot; onChange=&#123;_onChange&#125; value=&#123;value&#125; /&gt; &lt;/div&gt;&#125;export default Example 这样每次组件刷新后执行的debounce都是同一个函数，进而使得debounce的防抖效果生效。 4、useContext与useReducer（1）useContext 实现同一子树下所有节点可统一共享子树根节点的数据 函数签名 1const value = useContext(MyContext); 接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定。 当组件上层最近的 &lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值。 别忘记 useContext 的参数必须是 context 对象本身： 正确： useContext(MyContext) 错误： useContext(MyContext.Consumer) 错误： useContext(MyContext.Provider) 调用了 useContext 的组件总会在 context 值变化时重新渲染。 使用实例： 12345678910111213141516171819202122232425import React, &#123; useContext &#125; from &apos;react&apos;//创建Context对象，并附默认值 &#123;count: 1&#125;const MyContext = React.createContext(&#123; count: 1 &#125;)const [count, setState] = useState(1)export default function Example() &#123; const Son = () =&gt; &#123; return &lt;div&gt; &lt;Grandson&gt;&lt;/Grandson&gt; &lt;/div&gt; &#125; const Grandson = () =&gt; &#123; //使用useContext获取Context对象 const obj = useContext(MyContext); return &lt;div&gt; Grandson---&#123;obj.count&#125; &lt;/div&gt; &#125; return &lt;MyContext.Provider value=&#123;&#123; count: count &#125;&#125;&gt; &lt;button onClick=&#123;() =&gt; &#123; setState(count + 1) &#125;&#125;&gt;ADD&lt;/button&gt; &lt;Son&gt;&lt;/Son&gt; &lt;/MyContext.Provider&gt;&#125; 当点击按钮改变count时，所有消费者组件都会随之发生更新，这也就达到了跨层级组件直接共享数据的目的。 （2）useReducer函数签名 1234// reducer就是平时redux那种reducer函数// initialState 初始化的state状态// init 一个函数用于惰性计算state初始值const [state, dispatch] = useReducer(reducer, initialArg, init); useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。（统一管理数据，并对action加以限制） 在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 。 initialArg作为state的初始值，若存在init,则init会将initalArg处理后的值作为state的初始值 reducer对应于dispatch,使用dispatch所传入的实参对应于reducer的action 使用实例 123456789101112131415161718192021222324252627282930313233import React, &#123; useReducer &#125; from &apos;react&apos;const initialState = 0;const init = (initialCount) =&gt; &#123; return &#123; count: initialCount &#125;&#125;function reducer(state, action) &#123; switch (action.type) &#123; case &apos;increment&apos;: return &#123; count: state.count + 1 &#125;; case &apos;decrement&apos;: return &#123; count: state.count - 1 &#125;; case &apos;RESET&apos;: return init(action.payload) default: throw new Error(); &#125;&#125;export default props =&gt; &#123; const [state, dispatch] = useReducer(reducer, initialState, init); return &lt;div&gt; Count: &#123;state.count&#125; &lt;br /&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &apos;decrement&apos; &#125;)&#125;&gt;SUB&lt;/button&gt; &lt;br /&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &apos;increment&apos; &#125;)&#125;&gt;ADD&lt;/button&gt; &lt;br /&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &apos;RESET&apos;, payload: initialState &#125;)&#125;&gt;RESET&lt;/button&gt; &lt;/div&gt;&#125; （3）useContext与useReducer结合使用 结合使用useContext和useReducer以实现共享数据的统一管理和共享数据安全性保证 使用实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import React, &#123; useContext, useReducer &#125; from &apos;react&apos;export default props =&gt; &#123; const MyContext = React.createContext(&#123; count: 1 &#125;); const init = (initalCount) =&gt; &#123; return &#123; count: initalCount &#125; &#125; function reducer(state, action) &#123; switch (action.type) &#123; case &apos;increment&apos;: return &#123; count: state.count + 1 &#125;; case &apos;decrement&apos;: return &#123; count: state.count - 1 &#125;; case &apos;RESET&apos;: return init(action.payload) default: throw new Error(); &#125; &#125; const initialCount = 0; const [state, dispatch] = useReducer(reducer, initialCount, init); const Son1 = () =&gt; &#123; return &lt;Grandson1&gt;&lt;/Grandson1&gt; &#125; const Son2 = () =&gt; &#123; const obj = useContext(MyContext); return &lt;div&gt; Son2---&#123;obj.count&#125; &lt;/div&gt; &#125; const Grandson1 = () =&gt; &#123; const obj = useContext(MyContext); return &lt;div&gt; Grandson1---&#123;obj.count&#125; &lt;/div&gt; &#125; return &lt;MyContext.Provider value=&#123;&#123; count: state.count &#125;&#125;&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &apos;decrement&apos; &#125;)&#125;&gt;SUB&lt;/button&gt; &lt;br /&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &apos;increment&apos; &#125;)&#125;&gt;ADD&lt;/button&gt; &lt;br /&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &apos;RESET&apos;, payload: initialCount &#125;)&#125;&gt;RESET&lt;/button&gt; &lt;Son1&gt;&lt;/Son1&gt; &lt;Son2&gt;&lt;/Son2&gt; &lt;/MyContext.Provider&gt;&#125; 我们现在已经完成了useContext与useReducer的配合使用，我们现在将代码抽离出来，使其可以在任何组件中都可以快速调用 目录结构 12345678910-example -components -Son -index.js -Grandson -index.js -store -index.js -reducer.js -index.js 使用实例 123456789101112131415161718192021222324// example\\store\\index.jsimport React, &#123; useReducer, useContext &#125; from &apos;react&apos;import &#123; defaultState, reducer, init &#125; from &apos;./reducer&apos;const MyContext = React.createContext();const Context = props =&gt; &#123; //将useReducer的返回值 [state,dispatch] 作为参数 const contextValue = useReducer(reducer, defaultState, init); return &lt;MyContext.Provider value=&#123;contextValue&#125;&gt; &#123;props.children&#125; &lt;/MyContext.Provider&gt;&#125;const useMyContext = () =&gt; &#123; return useContext(MyContext)&#125;export &#123; Context, useMyContext&#125; 123456789101112131415161718192021222324252627282930// example\\store\\reducer.jsexport const defaultState = &#123; count: 0&#125;export const init = (initalState) =&gt; &#123; return &#123; ...initalState, count: initalState.count &#125;&#125;export const reducer = (state, action) =&gt; &#123; switch (action.type) &#123; case &apos;increment&apos;: return &#123; ...state, count: state.count + 1 &#125;; case &apos;decrement&apos;: return &#123; ...state, count: state.count - 1 &#125;; case &apos;RESET&apos;: return init(defaultState) default: throw new Error(); &#125;&#125; 12345678910111213141516171819202122232425262728// example\\components\\Grandson\\index.jsimport React from &apos;react&apos;import &#123; useMyContext &#125; from &apos;../../store&apos;export default props =&gt; &#123; const [state, dispatch] = useMyContext(); return &lt;div&gt; Grandson --- &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; &#123; dispatch(&#123; type: &apos;increment&apos; &#125;) &#125;&#125;&gt;Grandson ADD&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123; dispatch(&#123; type: &apos;decrement&apos; &#125;) &#125;&#125;&gt;Grandson SUB&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123; dispatch(&#123; type: &apos;RESET&apos; &#125;) &#125;&#125;&gt;Grandson RESET&lt;/button&gt; &lt;/div&gt;&#125;// example\\components\\Son\\index.jsimport React from &apos;react&apos;import Grandson from &apos;../Grandson&apos;export default props =&gt; &#123; return &lt;Grandson&gt;&lt;/Grandson&gt;&#125;//example\\index.jsimport React from &apos;react&apos;import Son from &apos;./components/Son&apos;import &#123; Context &#125; from &apos;./store&apos;export default props =&gt; &#123; return &lt;Context&gt; &lt;Son&gt;&lt;/Son&gt; &lt;/Context&gt;&#125; 5、useRef函数签名 1const refContainer = useRef(initialValue); useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。 使用实例 123456import React from &apos;react&apos;export default props =&gt; &#123; const refContainer = useRef(null); return &lt;div ref=&#123;refContainer&#125;&gt;&lt;/div&gt;&#125; 除此之外，我们可以使子组件接受父组件的ref，让父组件有控制组件的能力，这里要借助forwardRef 使用实例 1234567891011121314// fatherimport React, &#123; useRef &#125; from &apos;react&apos;import Son from &apos;./components/Son&apos;export default props =&gt; &#123; const refContainer = useRef(null); const changeInput = () =&gt; &#123; refContainer.current.value = &apos;啊，我被改了！&apos; &#125; return &lt;div &gt; &lt;button onClick=&#123;changeInput&#125;&gt;changeInput&lt;/button&gt; &lt;Son ref=&#123;refContainer&#125;&gt;&lt;/Son&gt; &lt;/div&gt;&#125; 12345678// Sonimport React, &#123; forwardRef &#125; from &apos;react&apos;const Son = (props,ref) =&gt; &#123; return &lt;div &gt; &lt;input ref=&#123;ref&#125;&gt;&lt;/input&gt; &lt;/div&gt;&#125;export default forwardRef(Son) useRef 声明常量以保存可变值 除了使用useRef绑定DOM，它另一个重要作用就是声明一个常量保存可变值，绕开React的Capture Value特性 保存常量这一功能实际上是基于useMemo实现的 12345&gt; &gt; function useRef (initialValue) &#123;&gt; &gt; return useMemo (() =&gt; (&#123; current : initialValue &#125;), []);&gt; &gt; &#125;&gt; &gt;&gt; 可见 就是初始化的时候创建一个{current:initialValue}，不依赖任何数据，需要手动赋值修改 使用实例 123456789101112import React, &#123; useRef &#125; from &apos;react&apos;export default props =&gt; &#123; const count = useRef(0); const add = () =&gt; &#123; count.current += 1; &#125; return &lt;div &gt; &lt;h1&gt;&#123;count.current&#125;&lt;/h1&gt; &lt;button onClick=&#123;add&#125;&gt;ADD&lt;/button&gt; &lt;/div&gt;&#125; 踩坑记录 注意与useState的区别与联系 6、useImperativeHandle useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle 应当与 forwardRef 一起使用 使用实例 123456789101112131415//fatherimport React, &#123; useRef &#125; from &apos;react&apos;import Son from &apos;./components/Son&apos;export default props =&gt; &#123; const refContainer = useRef(null); const changeInput = () =&gt; &#123; refContainer.current.focus() // console.log(refContainer) &#125; return &lt;div &gt; &lt;button onClick=&#123;changeInput&#125;&gt;changeInput&lt;/button&gt; &lt;Son ref=&#123;refContainer&#125;&gt;&lt;/Son&gt; &lt;/div&gt;&#125; 12345678910111213141516// Sonimport React, &#123; useRef, forwardRef, useImperativeHandle &#125; from &apos;react&apos;function Son(props, ref) &#123; //新建一个ref 将此ref绑定在本组建内的input上 const inputRef = useRef(); //将 使得本组件input获取焦点的方法赋给父组件传递来的ref上 useImperativeHandle(ref, () =&gt; (&#123; focus: () =&gt; &#123; inputRef.current.focus(); &#125; &#125;)); return &lt;input ref=&#123;inputRef&#125; /&gt;;&#125;export default forwardRef(Son); 7、useLayoutEffect1useLayoutEffect( () =&gt; &#123; &#125;, [ 依赖项 ] ); 其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。 尽可能使用标准的 useEffect 以避免阻塞视觉更新。 8、useDebugValue1useDebugValue(value) useDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。 12345678910111213&gt; &gt; function useFriendStatus(friendID) &#123;&gt; &gt; const [isOnline, setIsOnline] = useState(null);&gt; &gt; &gt; &gt; // ...&gt; &gt; &gt; &gt; // 在开发者工具中的这个 Hook 旁边显示标签&gt; &gt; // e.g. &quot;FriendStatus: Online&quot;&gt; &gt; useDebugValue(isOnline ? &apos;Online&apos; : &apos;Offline&apos;);&gt; &gt; &gt; &gt; return isOnline;&gt; &gt; &#125;&gt; &gt;&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"Hooks","slug":"Hooks","permalink":"http://yoursite.com/tags/Hooks/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"React Native项目问题小结","slug":"React-Native项目问题小结","date":"2019-11-25T09:58:58.000Z","updated":"2020-02-05T12:55:49.843Z","comments":true,"path":"2019/11/25/React-Native项目问题小结/","link":"","permalink":"http://yoursite.com/2019/11/25/React-Native项目问题小结/","excerpt":"","text":"React Native项目问题小结 最近在弄React Native的东西 做一个仿哔哩哔哩的小项目，不得不说React Native的坑真的太多太多了！ 1.react-native-router-flux修改物理返回键 引入BackHandler 从react-native中 1import &#123; View, StyleSheet, BackHandler &#125; from &apos;react-native&apos; 在componentDidMount加下面那行监听代码 1this.backHandler = BackHandler.addEventListener(&apos;hardwareBackPress&apos;, this.handleBackPress); 在componentWillUnmount添加代码 123componentWillUnmount() &#123; this.backHandler.remove()&#125; 在handleBackPress 函数中写相关返回逻辑 123456handleBackPress = () =&gt; &#123; Actions.pop(); // 跳转，可以跳转到想去的页面或位置，根据react-native-router-flux组件的方法 console.log(&quot;wo handle back press detail&quot;) // //this.goBack(); // works best when the goBack is async return true;&#125; 双击退出应用程序 12345678910111213handleBackPress = () =&gt; &#123; if (this.lastBackPressed &amp;&amp; this.lastBackPressed + 2000 &gt;= Date.now()) &#123; //最近2秒内按过back键，可以退出应用。 BackHandler.exitApp();//退出整个应用 return false &#125; this.lastBackPressed = Date.now(); console.log(&apos;再按一次要退出了&apos;) ToastAndroid.show(&apos;再按一次退出应用&apos;, ToastAndroid.SHORT); return true;&#125; 2react-native-tab-navigator Android键盘将底部导航tab顶起 app有个功能页面最上边是个搜索框，一点击输入的时候，键盘就自动弹出来，并且将底部的四个导航tab按钮也顶起来了，非常难看 React-native-tab-navigator,是一个很常用的第三方库，在Android上选择一个TextInput，然后会发现在首次渲染的时候，tab navigator这个组件是没问题的，可是当某些情况下在回到页面，发现 tab navigator浮到键盘上了。iOS上没有这个问题。 解决办法： 打开android工程，在AndroidManifest.xml中配置 配置代码如下 1android:windowSoftInputMode=&quot;stateAlwaysHidden|adjustPan&quot; 重启项目后，效果如下： ​","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://yoursite.com/tags/React-Native/"},{"name":"问题小结","slug":"问题小结","permalink":"http://yoursite.com/tags/问题小结/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"bilibi部分Api接口整理","slug":"bilibi部分Api接口整理","date":"2019-11-08T14:10:07.000Z","updated":"2020-02-05T11:55:59.054Z","comments":true,"path":"2019/11/08/bilibi部分Api接口整理/","link":"","permalink":"http://yoursite.com/2019/11/08/bilibi部分Api接口整理/","excerpt":"","text":"bilibi部分Api接口整理 偶然的机会发现哔哩哔哩很早之前暴露过一次api，虽然后来哔哩哔哩官方整改过，但是还是留下了一些api，本着对哔哩哔哩的兴趣，打算把部分api整理出来，后期利用这些api做一个React Native的小项目。 整理的过程是真的困难，从github以及别的项目源码中，还要结合抓包工具，以及appkey，和sign的破解弄得头大。 两个哔哩哔哩接口网站12https://github.com/lovelyyoshino/Bilibili-Live-APIhttps://github.com/fython/BilibiliAPIDocs appkey可以二选一12appkey:1d8b6e7d45233436appkey:c1b107428d337928 1 首页推荐 每次10条1https://app.bilibili.com/x/feed/index?appkey=1d8b6e7d45233436&amp;build=508000&amp;login_event=0&amp;mobi_app=android 2 首页热们视频(idx是offset，默认每次返回10条)1https://app.bilibili.com/x/v2/show/popular/index?build=5470400&amp;mobi_app=android&amp;idx=10 3 推荐页轮播图1https://api.bilibili.com/x/web-show/res/loc?pf=7&amp;id=1695 4 视频详情(破解版，信息更多)12https://comment.bilibili.com/recommendnew,id//相关推荐视频http://api.bilibili.cn/view?id=51639674&amp;appkey=1d8b6e7d45233436 //普通版 aid是哔哩哔哩av号，是上一级参数中的param 123456789101112131415161718192021222324252627282930313233343536 &lt;script type=\"text/javascript\" src=\"http://static.hdslb.com/js/md5.js\"&gt;&lt;/script&gt; //视频详情(破解版）function get_sign(params, key) &#123; var s_keys = []; for (var i in params) &#123; s_keys.push(i); &#125; s_keys.sort(); var data = \"\"; for (var i = 0; i &lt; s_keys.length; i++) &#123; // encodeURIComponent 返回的转义数字必须为大写( 如 %2F ) data += (data ? \"&amp;\" : \"\") + s_keys[i] + \"=\" + encodeURIComponent(params[s_keys[i]]); &#125; return &#123; \"sign\": hex_md5(data + key), \"params\": data &#125;; &#125;let paramsObj = &#123; aid: \"78126101\", //aid是哔哩哔哩av号，是上一级参数中的param appkey: \"1d8b6e7d45233436\", build: \"5480400\", ts: new Date().getTime() &#125; let appserct = \"560c52ccd288fed045859ed18bffd973\"; let signObj = get_sign(paramsObj, appserct); console.log(signObj); let path = \"https://app.bilibili.com/x/v2/view\"; let data = signObj.params; let sign = signObj.sign; let url = `$&#123;path&#125;?$&#123;data&#125;&amp;sign=$&#123;sign&#125;`; console.log(url);//详情页的url接口//使用https://motrix.app/软件 测试base_url是否能下载 5 热搜词列表(2选1，建议1)12https://app.bilibili.com/x/v2/search/hot?build=5370000&amp;limit=10 //limit 返回的条数https://s.search.bilibili.com/main/hotword 6 搜索时推荐关键字1http://api.bilibili.cn/suggest?term=哔哩哔哩 //term参数 搜索时的关键字 7 搜索结果列表(pn为第几页,ps为页的数据)1234567https://app.bilibili.com/x/v2/search?appkey=1d8b6e7d45233436&amp;build=5370000&amp;pn=1&amp;ps=15&amp;keyword=&amp;order= //order排序方式说明： //default：综合排序 //pubdate：按发布日期倒序排序 //senddate：按修改日期倒序排序 //damku：按弹幕数从高至低排序 //click：按点击从高至低排序 8 会员购列表(每次请求会刷新)1https://mall.bilibili.com/mall-c/home/index/v2?mVersion=17 9 视频评论(三选一，建议选一)12https://api.bilibili.com/x/v2/reply?type=1&amp;oid=51639674&amp;pn=5&amp;ps=10//（pn为第几页,ps为页的数据）https://api.bilibili.com/x/v2/reply?jsonp=jsonp&amp;type=1&amp;oid=51639674 10 频道列表(别人解析过的,返回数据中的tid应该会有用吧)1&quot;https://app.bilibili.com/x/channel/square?appkey=1d8b6e7d45233436&amp;build=5370000&amp;channel=huawei&amp;login_event=1&amp;mobi_app=android&amp;platform=android&amp;ts=1557534415&amp;sign=1f43ef46c4bf2d4d738ab7af0f809b3d&quot; 11 视频播放解析123456789101112131415161718192021//v1版本 返回flv格式 进度条audio标签可能不可以控制（后验证react-native-video可以控制拖动）//将data的参数拆分成v2的vedioParamsObj格式 然后操作同v2//qn 参数为清晰度 qn=32 是720p qn=64 是1080p let appserctV2 = \"aHRmhWMLkdeMuILqORnYZocwMBpMEOdt\"; let vedioParamsObjV2 = &#123; appkey: \"iVGUTjsxvpLeuDCf\", build: \"500001\", buvid: \"C0928256-085D-4722-A38F-2E343710C8B3155817infoc\", cid: \"133673197\", device: \"android\", otype: \"json\", platform: \"android\", qn: '64' &#125; let vedioSignObjV2 = get_sign(vedioParamsObjV2, appserctV2); console.log(vedioSignObj); let vedioPathV2 = \"https://app.bilibili.com/playurl\"; let vedioV2Data = vedioSignObjV2.params; let vedioV2Sign = vedioSignObjV2.sign; let vedioV2Url = `$&#123;vedioPathV2&#125;?$&#123;vedioV2Data&#125;&amp;sign=$&#123;vedioV2Sign&#125;`; console.log(vedioV2Url); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//v2版本 音频和视频的文件分开，做进度条拖动比较麻烦 &lt;script type=\"text/javascript\" src=\"http://static.hdslb.com/js/md5.js\"&gt;&lt;/script&gt;function get_sign(params, key) &#123; var s_keys = []; for (var i in params) &#123; s_keys.push(i); &#125; s_keys.sort(); var data = \"\"; for (var i = 0; i &lt; s_keys.length; i++) &#123; // encodeURIComponent 返回的转义数字必须为大写( 如 %2F ) data += (data ? \"&amp;\" : \"\") + s_keys[i] + \"=\" + encodeURIComponent(params[s_keys[i]]); &#125; return &#123; \"sign\": hex_md5(data + key), \"params\": data &#125;; &#125; let vedioParamsObj = &#123; actionkey: \"appkey\", aid: \"78126101\", appkey: \"iVGUTjsxvpLeuDCf\", build: \"5480400\", buvid: \"XZF9F55FE566C57599024A397F5F160E74DBE\", cid: \"133673197\", device: \"android\", expire: 0, fnval: 16, fnver: 0, force_host: 0, fourk: 0, from_spmid: \"tm.recommend.0.0\", mid: 0, mobi_app: \"android\", otype: \"json\", qn: 64, spmid: \"main.ugc-video-detail.0.0\", ts: new Date().getTime() &#125; let vedioAppserct = \"aHRmhWMLkdeMuILqORnYZocwMBpMEOdt\" let vedioSignObj = get_sign(vedioParamsObj, vedioAppserct); console.log(vedioSignObj); let vedioPath = \"https://app.bilibili.com/x/playurl\"; let vedioData = vedioSignObj.params; let vedioSign = vedioSignObj.sign; let vedioUrl = `$&#123;vedioPath&#125;?$&#123;vedioData&#125;&amp;sign=$&#123;vedioSign&#125;`; console.log(vedioUrl); react-native中 npm install –save react-native-video插件，将返回的数据中的baseurl 放入即可 具体操作访问https://blog.csdn.net/yeputi1015/article/details/82964314 12345678910111213141516import Video from &apos;react-native-video&apos;;//V2方式解析 视频音频分开 （url会根据时间跟新，所以下面的不一定能用）let adressV2 = &quot;http://27.221.127.9/upgcxcode/97/31/133673197/133673197-1-31090.m4s?expires=1575733800&amp;platform=android&amp;ssig=x9UvHgh8gmEpkI9S4Ds87w&amp;oi=989069014&amp;trid=81501fdc0efd411bb7892a757d489946u&amp;nfc=1&amp;nfb=maPYqpoel5MI3qOUX6YpRA==&amp;mid=0&quot;;//v1方式解析 有视频和音频let adressV1 =&quot;http://upos-hz-mirrorhw.acgvideo.com/upgcxcode/97/31/133673197/133673197_nb2-1-64.flv?e=ig8euxZM2rNcNbNahwdVhoMg7zdVhwdEto8g5X10ugNcXBlqNCNEto8g5gNvNE3DN0B5tZlqNxTEto8BTrNvN05fqx6S5ahE9IMvXBvE2ENvNCImNEVEK9GVqJIwqa80WXIekXRE9IB5QK==&amp;deadline=1576136875&amp;gen=playurl&amp;nbs=1&amp;oi=3737122042&amp;os=hw&amp;platform=android&amp;trid=2d2bad64398648bdbe4a16bba9e0774c&amp;uipk=5&amp;upsig=76034536ffedda65074af6147bb76b5d&amp;uparams=e,deadline,gen,nbs,oi,os,platform,trid,uipk&amp;mid=0&quot; &lt;Video source=&#123;&#123; uri: adressV1 &#125;&#125; // Can be a URL or a local file. ref=&#123;(ref) =&gt; &#123; // this.player = ref &#125;&#125; // Store reference // onBuffer=&#123;this.onBuffer&#125; // Callback when remote video is // buffering // onError=&#123;this.videoError&#125; // Callback when video cannot be //loaded style=&#123;styles.backgroundVideo&#125; /&gt; &lt;/View&gt; js中可以尝试flv.js(哔哩哔哩官方的视频播放器 github可下载) 12 直播首页(platform可以为ios或者android，推荐android)1https://api.live.bilibili.com/room/v2/AppIndex/getAllList?device=phone&amp;platform=ios&amp;scale=3 13 推荐直播1https://api.live.bilibili.com/room/v1/AppIndex/getAllList?device=android&amp;platform=android&amp;scale=xhdpi 14 直播分类图标1https://api.live.bilibili.com/room/v1/AppIndex/getAreas?device=phone&amp;platform=ios&amp;scale=3&amp;build=1000 15 直播url地址(！)1https://api.live.bilibili.com/room/v1/Room/playUrl?build=5470400&amp;device=android&amp;cid=8643223 //cid为上一级的roomid 16 直播信息(3选1，建议3)12345https://api.live.bilibili.com/room/v1/Room/get_info?id=$roomidhttps://api.live.bilibili.com/room/v1/Room/get_info?device=phone&amp;platform=ios&amp;scale=3&amp;build=10000&amp;room_id=https://api.live.bilibili.com/xlive/web-room/v1/index/getInfoByRoom?room_id=3971680 17 直播房间列表123456https://api.live.bilibili.com/room/v3/area/getRoomList//对应首页每项的点击查看更多后的页面//parent_area_id GET int [0-6] （1-6对应区号，0为全站）//page GET int 页数//page_size GET int [1-99] 每页显示数量//sort_type GET string online 18 番剧推荐123456http://bangumi.bilibili.com/api/get_season_by_tag?build=425000&amp;mobi_app=android&amp;page=2&amp;pagesize=8&amp;platform=android&amp;tag_id=109&amp;ts=1473084707000//tag_id=109 最新194 应该是每个季度的动漫//以下参数先尝试 不一定有效btype false int 番剧类型 2:二次元新番 3:三次元新番 默认:所有weekday false int 周日:0 周一:1 周二:2 周三:3 依此类推 19 全区排行 //这之后的接口不一定能用123https://api.bilibili.com/pgc/web/rank/list?day=3&amp;season_type=5 //1-5 对应番剧 影视 电视剧等//day 3 或者 7 表示最近3日或最近一周的排行 20连载动画12345//ps 返回条数https://api.bilibili.com/x/web-interface/dynamic/region?ps=20&amp;rid=33 //连载动画 https://api.bilibili.com/x/web-interface/dynamic/region?ps=20&amp;rid=32 //完结动画 https://api.bilibili.com/x/web-interface/dynamic/region?ps=15&amp;rid=51 //动画资讯https://api.bilibili.com/x/web-interface/dynamic/region?ps=15&amp;rid=152 //官方延伸 静态资源1直播页面一些图片资源1234567891011121314151617181920&quot;http://i0.hdslb.com/bfs/vc/dcfb14f14ec83e503147a262e7607858b05d7ac0.png&quot;, &quot;英雄联盟&quot;,&quot;http://i0.hdslb.com/bfs/vc/c666c6dc2d5346e0d3cfda7162914d84d16964dd.png&quot;, &quot;lol云顶之弈&quot;,&quot;http://i0.hdslb.com/bfs/vc/8f7134aa4942b544c4630be3e042f013cc778ea2.png&quot;, &quot;王者荣耀&quot;,&quot;http://i0.hdslb.com/bfs/live/8fd5339dac84ec34e72f707f4c3b665d0aa41905.png&quot;, &quot;娱乐&quot; &quot;http://i0.hdslb.com/bfs/live/827033eb0ac50db3d9f849abe8e39a5d3b1ecd53.png&quot;, &quot;单机&quot;&quot;http://i0.hdslb.com/bfs/live/a7adae1f7571a97f51d60f685823acc610d00a7e.png&quot;, &quot;电台&quot;&quot;http://i0.hdslb.com/bfs/vc/9bfde767eae7769bcaf9156d3a7c4df86632bd03.png&quot;, &quot;怪物猎人:世界&quot; &quot;http://i0.hdslb.com/bfs/vc/973d2fe12c771207d49f6dff1440f73d153aa2b2.png&quot;, &quot;无主之地3&quot; &quot;http://i0.hdslb.com/bfs/vc/976be38da68267cab88f92f0ed78e057995798d6.png&quot;, &quot;第五人格&quot; &quot;https://i0.hdslb.com/bfs/vc/ff03528785fc8c91491d79e440398484811d6d87.png&quot;, &quot;全部标签&quot; 2 70周年轮播图资源123&quot;http://i0.hdslb.com/bfs/archive/fc523c90d05bade49143294262a3a297da2a5d55.jpg&quot;&quot;http://i0.hdslb.com/bfs/archive/77da52bb418a4d7f959805d68779cc677c0cb71c.jpg&quot;&quot;http://i0.hdslb.com/bfs/archive/02127e444fd82aab723c7747f57d5c903c602605.jpg&quot; 3 70周年静态视频页面1234567891011121314151617181920212223242526272829303132333435363738 70年背景图资源&quot;http://i0.hdslb.com/bfs/archive/2e92d79c8a2a5a87f0d91ab1d493d09f5c1b2ec6.jpg&quot;, &#123;&quot;15500607&quot;,&quot;http://i1.hdslb.com/bfs/archive/69b341351180227d90b54cd61297177b643642c5.jpg&quot;,&quot;91岁仍坚守方桌，剪艺宗师袁秀莹与她的剪纸人生&quot;,&quot;趣味科普人文&quot;,&quot;4.6万&quot;,&quot;163&quot;,&quot;3:23&quot;&#125;&#123;&quot;10146180&quot;,&quot;http://i0.hdslb.com/bfs/archive/0baf3c2bc01200caecffdefd1eb9908d474aa4ac.jpg&quot;,&quot;被称为中国三宝之一的它，却不及日本，面临失传&quot;,&quot;趣味科普人文&quot;,&quot;14.4万&quot;,&quot;296&quot;,&quot;4:17&quot;&#125;&#123;&quot;13963830&quot;,&quot;http://i0.hdslb.com/bfs/archive/2356a444ee4dd26bb830fe834dd3d1dddb4af955.jpg&quot;,&quot;从一根青竹变成一摞纸，都发生了什么？&quot;,&quot;趣味科普人文&quot;,&quot;9万&quot;,&quot;546&quot;,&quot;3:02&quot;&#125;&#123;&quot;15902489&quot;,&quot;http://i2.hdslb.com/bfs/archive/2d21750c9cd9a3707c583a98e4a8fff3000c1c3e.jpg&quot;,&quot;他用编竹子的手艺，编出了年收108亿的传奇&quot;,&quot;趣味科普人文&quot;,&quot;7.1万&quot;,&quot;362&quot;,&quot;4:25&quot;&#125; 4 70周年静态资源123456789101112131415161718192021&#123;&quot;http://i1.hdslb.com/bfs/archive/685562c7df25a391723490d36354fd1440c0e2d4.jpg&quot;,&quot;68129825&quot;,&quot;外交高手”大熊猫：为国卖萌，应该的&quot;,&quot;9968&quot;,&quot;412&quot;&#125;&#123;&quot;http://i0.hdslb.com/bfs/archive/ee5829877e348ca9b69e7fb88dd72e3925514dce.jpg&quot;,&quot;68098480&quot;,&quot;黄河亮了！“人民红”点亮黄河沿岸 向祖国表白&quot;,&quot;2381&quot;,&quot;259&quot;&#125;&#123;&quot;http://i2.hdslb.com/bfs/archive/05d92363b590b1bf013dd6f9d3377d16e5557740.png&quot;,&quot;3924328&quot;,&quot;我在故宫修文物（2016）&quot;,&quot;532.4万&quot;,&quot;10万&quot;&#125; 5 追番轮播图静态资源1234567891011&quot;http://i0.hdslb.com/bfs/bangumi/a085f60bda7f18226accf3993b328e17f419c00d.jpg&quot;,&quot;FGO动画专题页&quot; &quot;http://i0.hdslb.com/bfs/bangumi/8c39135d5191acbe0f0108ede3dbc76b6342cd36.jpg&quot;,&quot;少女前线 人形小剧场：第9话&quot;&quot;http://i0.hdslb.com/bfs/bangumi/105c45fa8538c897e85e44f3811eda2de2d79b85.jpg&quot;,&quot;风起绿林&quot;&quot;http://i0.hdslb.com/bfs/bangumi/20429c37693f67e5310f3b4d02f96c2b7403a6ec.jpg&quot;,&quot;【一周资讯】第37期&quot; 6 追番图标资源1234567891011121314&quot;http://i0.hdslb.com/bfs/bangumi/125ba229db0dcc3b5a9fe110ba3f4984ddc2c775.png&quot;,&quot;番剧&quot;&quot;http://i0.hdslb.com/bfs/bangumi/2c782d7a8127d0de8667321d4071eebff01ea977.png&quot;,&quot;国创&quot;&quot;http://i0.hdslb.com/bfs/bangumi/7a7d9db1911b7cbfdad44ae953dd5acc49ef5187.png&quot;,&quot;时间表&quot;&quot;http://i0.hdslb.com/bfs/bangumi/76c03a7ca20815765c7f5bc17d320e0676e15a20.png&quot;,&quot;索引&quot;&quot;http://i0.hdslb.com/bfs/bangumi/e713a764f9146b73673ba9b126d963aa50f4fc3b.png&quot;,&quot;热门榜单&quot; 7 追番 番剧推荐静态资源(以下自行改成json文件)(4个一组，可做换一换功能，也可以自己通过抓包网站获取封面)1234567891011121314151617181920212223&quot;猎兽神兵&quot;, &quot;全12话&quot;, &quot;会员抢先&quot;, &quot;69.1万追番&quot;,&quot;http://i0.hdslb.com/bfs/archive/81385f895a48a1c27a0e701218781908fb9d5dd2.jpg&quot;&quot;鬼灭之刃&quot;, &quot;更新至第24话&quot;, &quot;会员抢先&quot;, &quot;476.9万追番&quot;,&quot;http://i0.hdslb.com/bfs/archive/efc989798673c8c374cad6e2b4fc555a8f0f3c2c.jpg&quot;&quot;女高中生的虚度日常&quot;, &quot;更新至第11话&quot;, &quot;会员抢先&quot;, &quot;171.1万追番&quot;,&quot;http://i0.hdslb.com/bfs/archive/1c277223735cfe18a32f8130855a20c1a699f706.jpg&quot;&quot;某科学的一方通行&quot;, &quot;更新至第10话&quot;, &quot;会员抢先&quot;, &quot;217.2万追番&quot;,&quot;http://i0.hdslb.com/bfs/archive/def29a30113e96248830b2a984c8feb6749252f4.jpg&quot;&quot;爱书的下克上：为了成为图书管理员不择手段！&quot;,&quot;更新至第10话&quot;,&quot;会员抢先&quot;,&quot;36万追番&quot;&quot;https://i2.hdslb.com/bfs/archive/b6e413bef190422a10f6c5da448b29bafc272509.jpg&quot;&quot;喜欢本大爷的竟然就你一个？&quot;,&quot;更新至第9.5话&quot;,&quot;会员抢先&quot;,&quot; 159.9万追番&quot;&quot;https://i0.hdslb.com/bfs/archive/6a40cf23518888c0aa5346ba9ca659771463d2df.jpg&quot;&quot;碧蓝航线&quot;,&quot;更新至第9话&quot;,&quot;会员抢先&quot;,&quot;116.8万追番&quot;&quot;https://i1.hdslb.com/bfs/archive/ba2cb324e57b917e2bd46794540203ff76a7ba52.jpg&quot;&quot;刺客守则&quot;,&quot;全12话&quot;,&quot;会员抢先&quot;,&quot;114.6万追番&quot;&quot;https://i0.hdslb.com/bfs/archive/e7a0b9d006fe345dabd0fffe45e636a27bba7be9.jpg&quot; 8 追番 国创推荐静态资源(4个一组，可做换一换功能)1234567891011121314151617181920212223&quot;画江湖之不良人 第三季&quot;, &quot;更新至第36话&quot;, &quot;会员抢先&quot;, &quot;132.8万系列追番&quot;,&quot;http://i0.hdslb.com/bfs/archive/ad8fe0bbc56b951a57e02142b79b4e9e7137b2e3.jpg&quot;&quot;阴阳师·平安物语&quot;, &quot;全12话&quot;, &quot;会员抢先&quot;, &quot;140.8万系列追番&quot;,&quot;http://i0.hdslb.com/bfs/archive/2e2198e297e98fe77b007710a3cefa9683e31898.jpg&quot;&quot;我家大师兄脑子有坑 特别篇&quot;, &quot;更新至第48话&quot;, &quot;会员抢先&quot;, &quot;196.8万系列追番&quot;,&quot;http://i0.hdslb.com/bfs/archive/55cd9010e59c310b3ccf6281b4ec57bf44967054.jpg&quot;&quot;更新至第9话&quot;, &quot;斩兽之刃&quot;, &quot;会员抢先&quot;, &quot;43.9万系列追番&quot;,&quot;http://i0.hdslb.com/bfs/archive/148be0d6209c7a7538998467f50dae3c6f21f322.jpg&quot;&quot;更新至第6话&quot;，&quot;伍六七之最强发现师&quot;，&quot;会员抢先&quot;，&quot;526.1万系列追番&quot;，&quot;https://i1.hdslb.com/bfs/archive/5ac5302075abf6bc7ba0efe076f6050499ea3715.jpg&quot;&quot;更新至第9话&quot;,&quot;少女前线 人形小剧场&quot;,&quot;会员抢先&quot;,&quot;48.1万系列追番&quot;&quot;https://i2.hdslb.com/bfs/archive/6a3fcb2d057598b03883762205b8d5723a73e2d0.jpg&quot;&quot;全12话&quot;,&quot;餐桌上的世说新语&quot;,&quot;&quot;,&quot;18.4万系列追番&quot;&quot;https://i0.hdslb.com/bfs/archive/7c481c3b86e2a2c3729e6d47419d83888473b0bd.jpg&quot;&quot;更新至第3话&quot;,&quot;驸马不要啊 动态漫 第三季&quot;,&quot;国创连载中&quot;,&quot;2.1万系列追番&quot;&quot;https://i0.hdslb.com/bfs/archive/e8044696aabbdfaad302980cc27aedc374c5a74e.jpg&quot; 9 影视轮播资源1234567891011121314&quot;http://i0.hdslb.com/bfs/bangumi/6a11174b96970c2239f9f5064c57e59af70171a6.jpg&quot;,&quot;吴青峰：怼粉这种事，都是靠灵感&quot; &quot;http://i0.hdslb.com/bfs/bangumi/4c58a6e3d6c9901251250ee4ef9ff5696e3c1db0.jpg&quot;,&quot;中国千年的礼乐智慧&quot; &quot;http://i0.hdslb.com/bfs/bangumi/98182d952ce44c6d378be97264e7bda0b0fd4c88.jpg&quot;,&quot;一群有能力、有怪癖又可爱的退休警察们&quot; &quot;http://i0.hdslb.com/bfs/bangumi/923bfb36c57cd643afb6a6c48594695372ff4a72.jpg&quot;,&quot;破解冻土难题，改写国际预言&quot; &quot;http://i0.hdslb.com/bfs/bangumi/5afd0231d665fd2ee29c376c292a8b3f0203384b.jpg&quot;,&quot;实拍战机空中机油~&quot; 10 影视图标1234567891011121314&quot;http://i0.hdslb.com/bfs/bangumi/85e80d8bb430e76eb3e55bbf93d8a62a51e2a774.png&quot;,&quot;纪录片&quot;&quot;http://i0.hdslb.com/bfs/bangumi/a1901aedc680a77c808787cb2cf8e22c7b9c359b.png&quot;,&quot;电影&quot;&quot;http://i0.hdslb.com/bfs/bangumi/21bd3247c745e3f1eb489bf637215f8cc8aa86ca.png&quot;,&quot;电视剧&quot;&quot;http://i0.hdslb.com/bfs/bangumi/76c03a7ca20815765c7f5bc17d320e0676e15a20.png&quot;,&quot;索引&quot;&quot;http://i0.hdslb.com/bfs/bangumi/e713a764f9146b73673ba9b126d963aa50f4fc3b.png&quot;,&quot;热门榜单&quot; 11 纪录片热播资源1234567891011121314151617181920212223&quot;守护解放西&quot;, &quot;9月14日，警动全城&quot;, &quot;14.2万追剧&quot;,&quot;http://i0.hdslb.com/bfs/bangumi/29e7ea9cf0a619618841caeca1a61032e4f0a2c6.jpg&quot;&quot;真实的残酷宫斗&quot;,&quot;亨利八世6位皇后&quot;,&quot;&quot;,&quot;http://i0.hdslb.com/bfs/bangumi/5a95404be7ecacc69167c3eb5e4d3b5383bef25b.png&quot;&quot;人生一串2&quot;, &quot;上串开吃！&quot;,&quot;限时免费&quot;,&quot;236.4万系列追剧&quot;,&quot;http://i0.hdslb.com/bfs/bangumi/7db272b2e887bb3615a8aee29cf4ed839dc54e82.png&quot;&quot;糟糕的历史&quot;,&quot;最魔性历史纪录片&quot;,&quot;22.6万系列追剧&quot;,&quot;http://i0.hdslb.com/bfs/bangumi/f3091de24e5ff374ae3920513fecce70a63dc039.jpg&quot;&quot;FOX的北极之旅&quot;,&quot;感受北欧极致壮美&quot;,&quot;&quot;,&quot;http://i0.hdslb.com/bfs/bangumi/2a2b86986e3e4fcb183f0a282c439bc5f130e9e6.jpg&quot;&quot;我们该玩电子游戏吗&quot;,&quot;游戏有助身心健康？&quot;,&quot;26.2万系列追剧&quot;,&quot;http://i0.hdslb.com/bfs/bangumi/acda1d7fd8565706b5fd0cb9c0f7b40813467fcc.jpg&quot;&quot;【纪录】中国古建筑 (2012)&quot;,&quot;中国古建筑之“大势&quot;,&quot;21.1万系列追剧&quot;&quot;https://i0.hdslb.com/bfs/archive/ad068ea233ef0f4e43158bac020a92c9bd0724dc.jpg&quot;&quot;未至之境（英配版）&quot;,&quot;一起探索无人之境&quot;,&quot;31.8万系列追剧&quot;&quot;https://i0.hdslb.com/bfs/archive/ffd662bc2eb4959574180187155c80b4a1a087be.png&quot; 12电影热播资源1234567891011121314151617181920212223242526&quot;哈利·波特与死亡圣器(下)&quot;, &quot;终极之战打响&quot;, &quot;71万系列追剧&quot;,&quot;http://i0.hdslb.com/bfs/bangumi/abcafcf95a0853f709d735f10561b993d0fc05bd.jpg&quot;,badge: &quot;会员专享&quot;&quot;哈利·波特与死亡圣器(上)&quot;, &quot;三人组寻找魂器&quot;, &quot;71万系列追剧&quot;,&quot;http://i0.hdslb.com/bfs/bangumi/d435abc79671d66ce826eea03911b3d3074d27b7.jpg&quot;,badge: &quot;会员专享&quot;&quot;蜘蛛侠：英雄远征&quot;, &quot;小蜘蛛登陆B站！&quot;, &quot;14.6万追剧&quot;,&quot;http://i0.hdslb.com/bfs/bangumi/37ecc29ada354bc61b9e237203fff3f4f358f731.jpg&quot;,badge: &quot;会员半价&quot;&quot;罗生门&quot;, &quot;黑泽明经典悬疑神作&quot;, &quot;2.6万追剧&quot;,&quot;http://i0.hdslb.com/bfs/bangumi/9050447827d4c7fd88f6a8c536b84e3a0e1b6912.jpg&quot;&quot;我想吃掉你的胰脏&quot;, &quot;免费首播！&quot;, &quot;73.6万追剧&quot;,&quot;http://i0.hdslb.com/bfs/bangumi/fd5891a000ecdf6e76fdfea1fc204776f728c9ba.jpg&quot;&quot;东京物语&quot;, &quot;东京真的太远了&quot;, &quot;9992追剧&quot;,&quot;http://i0.hdslb.com/bfs/bangumi/42af0d04487472725d24ff3bfa01a347f87e7248.jpg&quot;&quot;毒战&quot;,&quot;【古天乐/孙红雷】&quot;,&quot;2.8万追剧&quot;&quot;https://i0.hdslb.com/bfs/archive/9ca6b32956a8abbcae1cb9db17ddaa71509446f8.jpg&quot;&quot;怦然心动&quot;,&quot;重温心动初恋&quot;,13.2万追剧&quot;&quot;https://i1.hdslb.com/bfs/archive/94b509c59ceb8ad29f47fa39630367b860e96d48.jpg&quot; 13 电视剧热播资源123456789101112131415161718192021222324252627&quot;大恋爱&quot;, &quot;和喜欢的人一起吃饭&quot;, &quot;1.9万追剧&quot;,&quot;http://i0.hdslb.com/bfs/bangumi/29e7ea9cf0a619618841caeca1a61032e4f0a2c6.jpg&quot;&quot;万福&quot;, &quot;你醒啦&quot;, &quot;1.3万追剧&quot;&quot;http://i0.hdslb.com/bfs/bangumi/4c6748f24b0cee23fe71d387a820e7b1e651ccb3.jpg&quot;,&quot;会员抢先&quot;&quot;双姝 第二季&quot;,&quot;即将上线&quot;,&quot;15.6万系列追剧&quot;,&quot;http://i0.hdslb.com/bfs/bangumi/5c104fc023c5a6f9b6f59cd83d276a8c86f4d21d.jpg&quot;&quot;警察之家&quot;, &quot;是兔子还是螃蟹&quot;, &quot;9520追剧&quot;,&quot;http://i0.hdslb.com/bfs/bangumi/2bf8fb89f3a386e37e08556d89842590655f3647.png&quot;,&quot;会员抢先&quot;&quot;警察之家&quot;, &quot;是兔子还是螃蟹&quot;, &quot;9520追剧&quot;,&quot;http://i0.hdslb.com/bfs/bangumi/2bf8fb89f3a386e37e08556d89842590655f3647.png&quot;,&quot;会员抢先&quot;&quot;萤之光 第一季&quot;, &quot;情侣同款睡姿&quot;, &quot;4.9万追剧&quot;,&quot;http://i0.hdslb.com/bfs/bangumi/4a28a26cf87a1f9f4c5a5392b3c69a2f39d64a5c.jpg&quot;,&quot;限时免费&quot;&quot;原以为命中注定的恋爱&quot;, &quot;不会发生在我身上&quot;, &quot;1.6万追剧&quot;,&quot;http://i0.hdslb.com/bfs/bangumi/9c6401a78ee23cadb7c8338af517e0b1be489535.jpg&quot;,&quot;会员专享&quot;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"bilibi","slug":"bilibi","permalink":"http://yoursite.com/tags/bilibi/"},{"name":"Api接口","slug":"Api接口","permalink":"http://yoursite.com/tags/Api接口/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"Cookie、Session、Token","slug":"Cookie、Session、Token","date":"2019-10-07T10:52:44.000Z","updated":"2020-02-06T12:12:58.780Z","comments":true,"path":"2019/10/07/Cookie、Session、Token/","link":"","permalink":"http://yoursite.com/2019/10/07/Cookie、Session、Token/","excerpt":"","text":"Cookie、Session、Token1 Cookie HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。 cookie 存储在客户端： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。 cookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。 cookie 重要的属性 属性 说明 name=value 键值对，设置 Cookie 的名称及相对应的值，都必须是字符串类型- 如果值为 Unicode 字符，需要为字符编码。- 如果值为二进制数据，则需要使用 BASE64 编码。 domain 指定 cookie 所属域名，默认是当前域名 path 指定 cookie 在哪个路径（路由）下生效，默认是 ‘/‘。如果设置为 /abc，则只有 /abc 下的路由可以访问到该 cookie，如：/abc/read。 maxAge cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。- 比 expires 好用。 expires 过期时间，在设置的某个时间点后该 cookie 就会失效。一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除 secure 该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。 httpOnly 如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全 2 Session session 是另一种记录服务器和客户端会话状态的机制 session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中 session 认证流程： 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session 请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。 根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。 Cookie 和 Session 的区别 安全性： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。 存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。 有效期不同： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。 存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。 什么是 Token（令牌）Acesss Token 访问资源接口（API）时所需要的资源凭证 简单 token 的组成： uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串） 特点： 服务端无状态化、可扩展性好 支持移动端设备 安全 支持跨程序调用 token 的身份验证流程： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 token 服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据 每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里 基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库 token 完全由应用管理，所以它可以避开同源策略 转自https://juejin.im/post/5e055d9ef265da33997a42cc","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Cookie","slug":"Cookie","permalink":"http://yoursite.com/tags/Cookie/"},{"name":"Session","slug":"Session","permalink":"http://yoursite.com/tags/Session/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"前端代码题小结","slug":"前端代码题小结","date":"2019-08-31T11:44:25.000Z","updated":"2020-02-11T05:55:01.541Z","comments":true,"path":"2019/08/31/前端代码题小结/","link":"","permalink":"http://yoursite.com/2019/08/31/前端代码题小结/","excerpt":"","text":"前端代码题小结1.用一行代码实现下面数组以num的值的大小重新排列,并返回一个新的数组123456let arr = [ &#123;num: 23,name: &apos;xiao&apos;&#125;, &#123;num: 100,name: &apos;wang&apos;&#125;, &#123;num: 3,name: &apos;li&apos;&#125;, &#123;num: 56,name: &apos;huang&apos;&#125; ] 12arr.sort((v1, v2) =&gt; v1.num - v2.num)console.log(arr); 2.async / await 的串行和并行123456789101112131415161718192021222324252627282930function getName() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('tom') &#125;, 2000); &#125;) &#125; function getId() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('001') &#125;, 3000); &#125;) &#125; //串行 共5s打印id和name const todo1 = async() =&gt; &#123; let name = await getName(); let id = await getId(); console.log(name, id); &#125; todo1(); //并行 等到3s后打印 const todo2 = async() =&gt; &#123; let [id, name] = await Promise.all([getId(), getName()]) console.log(name, id); &#125; todo2(); 3.几种深拷贝的方法 JSON方法实现 12345let deepClone = function (obj) &#123; let _tmp = JSON.stringify(obj);//将对象转换为json字符串形式 let result = JSON.parse(tmp);//将转换而来的字符串转换为原生js对象 return result;&#125;; ES6扩展运算符（对数组） 1234567891011let arr = [ &#123;a: &apos;name&apos;&#125;, [1, 2, 3], &apos;hahah3&apos; ] let cloneArr = [...arr] cloneArr.push(4) console.log(arr); // &#123;a: &quot;name&quot;&#125;,[1, 2, 3],&quot;hahah3&quot; console.log(cloneArr);// &#123;a: &quot;name&quot;&#125;,[1, 2, 3],&quot;hahah3&quot;,4 递归实现深拷贝 12345678910111213141516171819202122//通过函数实现,把对象a中的所有的数据深拷贝到对象b中function extend(a,b) &#123; for(var key in a)&#123; //先获取a对象中每个属性的值 var item=a[key]; //判断这个属性的值是不是数组 if(item instanceof Array)&#123; //如果是数组,那么在b对象中添加一个新的属性,并且这个属性值也是数组 b[key]=[]; //调用这个方法，把a对象中这个数组的属性值一个一个的复制到b对象的这个数组属性中 extend(item,b[key]); &#125;else if(item instanceof Object)&#123;//判断这个值是不是对象类型的 //如果是对象类型的,那么在b对象中添加一个属性,是一个空对象 b[key]=&#123;&#125;; //再次调用这个函数,把a对象中的属性对象的值一个一个的复制到b对象的这个属性对象中 extend(item,b[key]); &#125;else&#123; //如果值是普通的数据,直接复制到b对象的这个属性中 b[key]=item; &#125; &#125;&#125; 4.将数组[999,88,777,409,7862,1045,3987,4679,56]进行排序12345678910111213141516171819202122//方法一var arr = [999, 88, 777, 409, 7862, 1045, 3987, 4679, 56] arr.sort((a, b) =&gt; a - b) console.log(arr); //方法二 冒泡排序 function mySort(data) &#123; let temp = null; let arr = data; let flag = true; for (let i = 0; i &lt; arr.length - 1; i++) &#123; for (let j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1] arr[j + 1] = temp; &#125; &#125; &#125; return arr; &#125; console.log(mySort(arr)); 5.数组求最大值 ：var arr=[45,2,3,4,10,8],用es6求最大值?123456789var arr = [45,2,3,4,10,8];//方法一var max = arr.reduce(function(a , b)&#123; return b &gt; a ? b : a; &#125;);console.log(max); // 方法二var max = Math.max(...arr)console.log(max); 6.前端模块化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#requirejs AMD前台模块化规范//定义模块define(id?,dependencies?,factory); - id: 定义中模块的名字;可选；如果没有提供该参数,模块的名字应该默认为模块加载器请求的指定脚本的名字. - 依赖dependencies：是一个当前模块依赖的,已被模块定义的模块标识的数组字面量 - 工厂方法factory,模块初始化要执行的函数或对象.如果为函数,它应该只被执行一次.如果是对象,此对象应该为模块的输出值. - 默认情况下文件名即为模块名 //引入模块require([dependencies],function()&#123;&#125;); - 第一个参数是一个数组,表示所依赖的模块- 第二个参数是一个回调函数,当前面指定的模块都加载成功后,它将被调用.加载的模块会以参数形式传入该函数,从而在回调函数内部就可以使用这些模块#seajs CMD前台模块化规范//声明模块define(id?,d?,factory)- id : 因为CMD推崇一个文件一个模块,所以经常就用文件名作为模块id- d : CMD推崇依赖就近,所以一般不在define的参数中写依赖- factory :函数 function(require,exports,module) require 是一个方法,用来获取其他模块提供的接口 exports 是一个对象,用来向外提供模块接口 module 是一个对象,上面存储了与当前模块相关联的一些属性和方法//使用模块seajs.use(&apos;mymodel.js&apos;,function(mymodel)&#123;&#125;);#commonjs 后台模块化规范//1.模块的引入const modu = require(‘./b.js’)//2.模块的导出//导出单个成员exports.foo = “变量”exports.add = function()&#123;&#125;//导出多个成员module.exports = &#123;&#125;#ES6模块化规范//1.导出//导出单个成员export let name = &apos;leo&apos;;export let age= 30;let name= &apos;leo&apos;;let age= 30;let kk = &quot;abc&quot;//导出多个成员export &#123;name, age&#125;;//导出默认成员export default kk;//2.引入import kk,&#123;name,age&#125; from &apos;a.js&apos; 7.下面代码输出结果是？1234567891011var x = new boolean(false);//x是一个对象 对象总是trueif(x)&#123; alert(&apos;hi&apos;);&#125;//y是一个值类型，y就是falsevar y = Boolean(0);if(y)&#123; alert(&apos;hello&apos;)&#125; 8.写一个JS函数，从一个key=&gt;value的数组，得到一个value=&gt;key的数组12345678910111213141516171819202122var arr = [ &#123; &quot;0&quot;: &quot;第零&quot;, &quot;10&quot;: &quot;第一零&quot; &#125;, &#123; &quot;1&quot;: &quot;第一&quot;, &quot;11&quot;: &quot;第一一&quot; &#125;, &#123; &quot;2&quot;: &quot;第二&quot;, &quot;12&quot;: &quot;第一二&quot; &#125;, &#123; &quot;3&quot;: &quot;第三&quot;, &quot;13&quot;: &quot;第一三&quot; &#125;, &#123; &quot;4&quot;: &quot;第四&quot;, &quot;14&quot;: &quot;第一四&quot; &#125;, &#123; &quot;5&quot;: &quot;第五&quot;, &quot;15&quot;: &quot;第一五&quot; &#125;, &#123; &quot;6&quot;: &quot;第六&quot;, &quot;16&quot;: &quot;第一六&quot; &#125;, &#123; &quot;7&quot;: &quot;第七&quot;, &quot;17&quot;: &quot;第一七&quot; &#125;, &#123; &quot;8&quot;: &quot;第八&quot;, &quot;18&quot;: &quot;第一八&quot; &#125;, &#123; &quot;9&quot;: &quot;第九&quot;, &quot;19&quot;: &quot;第一九&quot; &#125;];let invertKeyValues = (obj,curItem) =&gt;Object.keys(obj).map((key) =&gt; &#123; curItem[obj[key]] = key; //返回一个变化了key和value的新对象 return curItem; &#125;);//当前元素const newArr = arr.map(item =&gt; invertKeyValues(item,&#123;&#125;));console.log(newArr); 9.数组去重 利用数组的indexOf下标属性来查询。 1234567891011function unique(arr) &#123; var newArr = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (newArr.indexOf(arr[i])===-1) &#123; newArr.push(arr[i]) &#125; &#125; return newArr&#125;console.log(unique([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));// 结果是[1, 2, 3, 5, 6, 7, 4] 利用数组原型对象上的includes方法。 1234567891011function unique(arr) &#123; var newArr = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (!newArr.includes(arr[i])) &#123; newArr.push(arr[i]) &#125; &#125; return newArr&#125;console.log(unique([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));// 结果是[1, 2, 3, 5, 6, 7, 4] 利用 ES6的set 方法。 123456function unique(arr) &#123; //Set数据结构，它类似于数组，其成员的值都是唯一的 return Array.from(new Set(arr)); // 利用Array.from将Set结构转换成数组&#125;console.log(unique10([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));// 结果是[1, 2, 3, 5, 6, 7, 4]","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"移动端键盘弹出顶起fixed定位问题","slug":"移动端键盘弹出顶起fixed定位问题","date":"2019-07-10T11:19:19.000Z","updated":"2020-02-04T13:51:02.226Z","comments":true,"path":"2019/07/10/移动端键盘弹出顶起fixed定位问题/","link":"","permalink":"http://yoursite.com/2019/07/10/移动端键盘弹出顶起fixed定位问题/","excerpt":"","text":"移动端键盘弹出顶起fixed定位问题 移动端页面的底部菜单栏，通常会使用fixed定位在底部。在安卓手机上经常会出现软键盘弹出时，底部定位被顶上去，下面提供vue和jQuery两种解决办法。 1vue.js代码12&lt;!--html部分--&gt;&lt;div class=&quot;footer&quot; v-show=&quot;hideshow&quot;&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526// js 部分data()&#123; return &#123; docmHeight: document.documentElement.clientHeight, //默认屏幕高度 showHeight: document.documentElement.clientHeight, //实时屏幕高度 hideshow:true, //显示或者隐藏footer &#125;&#125;,mounted() &#123; // window.onresize监听页面高度的变化 window.onresize = ()=&gt;&#123; return(()=&gt;&#123; this.showHeight = document.body.clientHeight; &#125;)() &#125;&#125;,//监听watch:&#123; showHeight:function() &#123; if(this.docmHeight &gt; this.showHeight)&#123; this.hideshow=false &#125;else&#123; this.hideshow=true &#125; &#125;&#125;, 2 jQuery代码123456789101112var winHeight = $(window).height(); //获取当前页面高度$(window).resize(function () &#123; var thisHeight = $(this).height(); if ( winHeight - thisHeight &gt; 140 ) &#123; //键盘弹出 $('.footer').css('position','static'); &#125; else &#123; //键盘收起 $('.footer').css(&#123;'position':'fixed','bottom':'0'&#125;); &#125;&#125;) 原文链接：https://blog.csdn.net/Tessa_zzl/article/details/89680315","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"},{"name":"fixed定位","slug":"fixed定位","permalink":"http://yoursite.com/tags/fixed定位/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"git study","slug":"git-study","date":"2019-06-28T10:06:19.000Z","updated":"2020-02-04T08:37:38.312Z","comments":true,"path":"2019/06/28/git-study/","link":"","permalink":"http://yoursite.com/2019/06/28/git-study/","excerpt":"","text":"git一 git介绍1 什么是git？ Git是目前世界上最先进的分布式版本控制系统。 Git 是 Linus Torvalds(林纳斯·托瓦兹) 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 工作流程： Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 理解工作区，暂存区，版本库的区别？ 工作区：就是你在电脑上看到的目录，比如目录下某个里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。 版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。 使用Git提交文件到版本库有两步： 第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。 第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。 2 什么又是版本控制系统？ 如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：想删除一个段落，又怕将来想恢复找 不回 来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去…… 结果就是保存的文件非常多，回头想找到某一次修改后的文件也十分麻烦 3 都是用于版本控制 svn和git有什么区别？ SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就麻烦… Git就是分布式版本控制系统，对应的是集中式的版本控制如SVN。简单的说，分布式的版本控制就是每个人都可以创建一个独立的代码仓库用于管理，各种版本控制的操作都可以在本地完成。每个人修改的代码都可以推送合并到另外一个代码仓库中。 二 基本使用1 创建版本库 新建一个文件夹 通过命令 *git init *把这个目录变成git可以管理的仓库 123Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo$ git initInitialized empty Git repository in C:/Users/Shinelon/Desktop/git/gitDemo/.git/ 目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的 把文件添加到版本库中 目录下新建一个记事本文件 readme.txt 内容如下：11111111 添加指定目录到暂存区，包括子目录 使用命令 git add 添加到暂存区(stage)里面去 git add [dir] 添加指定文件 git add . 添加所有文件 12345Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)$ git add readme.txtShinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)$ 如果和上面一样，没有任何提示，说明已经添加成功了。 用命令 git commit 把文件提交到仓库。 12345Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)$ git commit -m &apos;第一次提交&apos; //这里相当于注释[master (root-commit) 94c85ed] 第一次提交 1 file changed, 1 insertion(+) create mode 100644 readme.txt 通过命令git status来查看是否还有文件未提交 当我们将readme.txt 稍作修改时 123456789Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txt //此处表示 readme.txt文件被修改了no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 上面的命令告诉我们 readme.txt文件已被修改，但是未被提交的修改。 通过git diff 查看文件到底改了什么内容 123456789101112Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)$ git diff readme.txtdiff --git a/readme.txt b/readme.txtindex 748099d..1ae13e4 100644--- a/readme.txt+++ b/readme.txt@@ -1 +1,2 @@-11111111\\ No newline at end of file+11111111+22222222\\ No newline at end of file readme.txt文件内容从一行11111111改成 二行 添加了一行22222222内容。 然后再次 第一步:git add 第二步：git commit 后可以再次提交 2 版本回退 使用 git log 命令查看下历史记录 123456789101112$ git logcommit a387d6c1e2da74df7f00e34867cadec472c2eebe (HEAD -&gt; master)Author: e &lt;752625566@qq.com&gt;Date: Mon Nov 25 18:55:52 2019 +0800 第二次提交commit 94c85ed50a6ad9c8b0075fa0f38abbdc719d01d8Author: e &lt;752625566@qq.com&gt;Date: Mon Nov 25 18:29:47 2019 +0800 第一次提交 版本回退操作 第一种：git reset –hard HEAD^，回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推 ， git reset –hard HEAD~10 回退10个版本 123Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)$ git reset --hard HEAD^HEAD is now at 94c85ed 第一次提交 此时文件内容变为原来的 1111111 第二种：可以通过 git reflog 命令即可获取到版本号: 12345Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)$ git reflog94c85ed (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD^a387d6c HEAD@&#123;1&#125;: commit: 第二次提交94c85ed (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): 第一次提交 再通过git reset –hard 版本号名 来恢复 123Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)$ git reset --hard a387d6cHEAD is now at a387d6c 第二次提交 此时readme.txt文件又恢复到第二次提交时的内容 11111111 22222222 3 Git撤销修改和删除文件操作 Git撤销修改 ，未提交之前，我发现添加的内容有误，需要恢复以前的版本 git checkout – file可以丢弃工作区的修改 git checkout –文件名可以对单个文件撤销修改 命令 git checkout意思就是，把文件在工作区做的修改全部撤销 我们先对readme.txt文件进行修改 加内容 3333333 再 123Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)$ git checkout -- readme.txt//此时readme.txt添加的3333333没有了 readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。 另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。 删除文件 一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm readme.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉 4 远程仓库 在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置： 第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令： ssh-keygen -t rsa –C “youremail@example.com” id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。 如何添加远程仓库 现在的情景是：本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。 登录github上，然后在右上角找到“create a new repo”创建一个新的仓库 我们根据GitHub的提示，在本地的testgit仓库下运行命令 git remote add origin https://github.com/Zmoshou/testgit.git 把本地库的内容推送到远程，使用 git push命令git push -u origin master，实际上是把当前分支master推送到远程 由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 1234567891011121314Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)$ git remote add origin https://github.com/Zmoshou/testgit.gitShinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)$ git push -u origin masterEnumerating objects: 6, done.Counting objects: 100% (6/6), done.Delta compression using up to 4 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (6/6), 445 bytes | 222.00 KiB/s, done.Total 6 (delta 0), reused 0 (delta 0)To https://github.com/Zmoshou/testgit.git * [new branch] master -&gt; masterBranch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;. 完成以上操作后，只要本地作了提交，就可以通过如下命令：git push origin master 把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。 如何从远程库克隆？ 使用命令git clone从远程仓库克隆一个本地库 12345678Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/新建文件夹$ git clone https://github.com/Zmoshou/testgit.gitCloning into &apos;testgit&apos;...remote: Enumerating objects: 6, done.remote: Counting objects: 100% (6/6), done.remote: Compressing objects: 100% (2/2), done.remote: Total 6 (delta 0), reused 6 (delta 0), pack-reused 0Unpacking objects: 100% (6/6), done. 三 多人协作开发 首先创建一个git服务器，被多个人所操作(Github或者Gitlab) 1 多人协助实现分为如下几个步骤： 创建一个git裸服务器 （git init –bare） 由负责人来完成的。服务器新建一个项目目录 从裸服务器将版本库克隆至本地（git clone ） 使用命令 git clone git版本服务器地址 本地常规操作(日常开发) 推送版本至服务器 （git remote + git push origin master） 在这之前需要git add 和 git commit操作 123Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)$ git remoteorigin 12345678910Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)$ git push origin masterEnumerating objects: 4, done.Counting objects: 100% (4/4), done.Delta compression using up to 4 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 262 bytes | 131.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To https://github.com/Zmoshou/testgit.git a387d6c..bad13db master -&gt; master ​ 从远程服务器拉取版本（git pull） 在多人协助开发时，每个开发人员在推送自己的最新版本时，都需要确保当前版本是最新的，所以就需要先获取最新版本，也就是说需要从服务器拉取最新版本到本地。 需要使用 git pull命令 对很多开发人员而言，一打开电脑，马上先git pull，拉取最新的。然后进行常规开发， 开发完毕之后，在git push之前，还需要使用git pull再拉取一遍 如果有新的开发人员加入进来，重复25过程。如果不是新的开发人员，重复35过程 在整个协作开发时，有时候会出现冲突。通常都是由于开发人员分工不明确导致的，所以如果出现这种情况，需要两个程序员协商解决.。 2 分支 什么是分支 在版本回退里已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长 当我们创建新的分支， 例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上 从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 什么时候会用到分支 假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险，怎么办？ 你可以创建一个属于自己的分支，别人看不见，还继续在原来的分支上工作，而你在自己的分支上进行开发，等开发完毕，合并即可。 在开源世界中，需用大量的程序员共同维护一个项目。也是需要使用分支，如Jquery 分支的基本操作 基本操作有如下几个： 查看当前分支 （git branch） 123Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)$ git branch* master ​ 创建分支 （git branch 分支名） 切换分支（git checkout 分支名） 1234Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (dev)$ git branch* dev master 1234$ git checkout -b[自定义分支名]一般都使用与远程对应开发分支相同的名字，这里就是用上述中的 plugin-20190622 分支$ git checkout -b plugin-20190622 关联 12$ git branch --set-upstream-to=[远程分支名] [本地分支名] //命令$ git branch --set-upstream-to=origin/plugin-20190930 plugin-20190622 ​ 分支上的常规操作 日常开发 然后使用git add 和git commit提交。 可以使用git log查看 分支的合并 （git checkout master + git merge 分支名） 分支的合并，一定是在 主分支上进行的。 只能在主分支合并其它分支。 需要两步： 1） 切换到主分支git checkout master 2） 使用git merge 分支名 进行合并 git merge dev 123456Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)$ git merge devUpdating bad13db..334a0e7Fast-forward gittest.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 此时我们再次查看master的一个log情况 ​ 分支的删除（git branch -d 分支名） 123Shinelon@DESKTOP-9IDM32E MINGW64 ~/Desktop/git/gitDemo (master)$ git branch -d devDeleted branch dev (was 334a0e7). ​","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"节流防抖","slug":"节流防抖","date":"2019-06-01T08:49:33.000Z","updated":"2020-02-04T05:21:16.077Z","comments":true,"path":"2019/06/01/节流防抖/","link":"","permalink":"http://yoursite.com/2019/06/01/节流防抖/","excerpt":"","text":"防抖节流防抖、节流https://segmentfault.com/a/1190000016261602这个写的很好，平时键盘抬起就会搜索，防抖后，间隔一段时间不输入才会搜索，节流后，可以做到不管是否停止打字，间隔一段时间都会搜索。 函数防抖(debounce) 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 1234567891011/模拟一段ajax请求,只要按下键盘，就会触发这次ajax请求。/* ajax函数用来输出传入的参数*/function ajax(content) &#123; console.log(&apos;ajax request &apos; + content)&#125;/* 通过id值获取到DOM标签*/let inputa = document.getElementById(&apos;unDebounce&apos;)inputa.addEventListener(&apos;keyup&apos;, function (e) &#123; ajax(e.target.value)&#125;) 优化后： 123456789101112131415161718192021222324/ 延迟执行ajax请求后，当你在频繁的输入时，并不会发送请求，只有当你在指定间隔内没有输入时，才会执行函数//* ajax函数用来输出传入的参数*/function ajax(content) &#123; console.log(&apos;ajax request &apos; + content)&#125;/这里定义一个debounce函数，将传入的函数延迟5秒执行，如果间隔小于5秒，就会重新计时/function debounce(fun, delay) &#123; return function (args) &#123; let that = this let _args = args clearTimeout(fun.id) fun.id = setTimeout(function () &#123; fun.call(that, _args) &#125;, delay) &#125;&#125;/* 通过id值获取到DOM标签*/ let inputb = document.getElementById(&apos;debounce&apos;);/这是个函数，是debounce返回的函数/let debounceAjax = debounce(ajax, 500)/* 添加监听键盘抬起事件，每次弹起就执行后面的回调函数，即将输入内容传值给debounceAjax函数延迟执行ajax*/inputb.addEventListener(&apos;keyup&apos;, function (e) &#123; debounceAjax(e.target.value)&#125;) 函数节流(throttle)规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。【性能优化】 1234567891011let biu = function () &#123; console.log(&apos;biu biu biu&apos;,new Date().Format(&apos;HH:mm:ss&apos;))&#125;setInterval(debounce(biu,500),1000)/*biu这个函数在第一次1.5s后执行，然后每隔1s执行一次*/let boom = function () &#123; console.log(&apos;boom boom boom&apos;,new Date().Format(&apos;HH:mm:ss&apos;))&#125;setInterval(debounce(boom,2000),1000)/*boom这个函数，一次都不会执行，函数执行事件是1s，但是函数间隔2s才会执行，每次2s还没到，就重新计时了*/ 优化后 1234567891011121314151617181920212223242526272829303132333435 /在不断输入时，ajax会按照我们设定的时间，每1s执行一次function throttle(fun, delay) &#123; let last, deferTimer return function (args) &#123; let that = this let _args = arguments let now = +new Date() if (last &amp;&amp; now &lt; last + delay) &#123; clearTimeout(deferTimer) deferTimer = setTimeout(function () &#123; last = now fun.apply(that, _args) &#125;, delay) &#125;else &#123; /如果现在=上一次的时间+延迟时间，那么就马上执行fun函数 last = now fun.apply(that,_args) &#125; &#125; &#125;/*throttleAjax是个函数，*/ let throttleAjax = throttle(ajax, 1000);/* 获取当前的DOM元素，并添加键盘抬起的监听事件，每次抬起就调用函数throttleAjax*/ let inputc = document.getElementById(&apos;throttle&apos;) inputc.addEventListener(&apos;keyup&apos;, function(e) &#123; throttleAjax(e.target.value) &#125;);/不管我们设定的执行时间间隔多小，总是1s内只执行一次。let biubiu = function () &#123; console.log(&apos;biu biu biu&apos;, new Date().Format(&apos;HH:mm:ss&apos;)) &#125;; setInterval(throttle(biubiu,1000),10); 总结：函数防抖，类似法师技能读条，还没读完条再按技能，就会重新读条，但是会出现一直读条不能放技能的状况；函数节流，就是一直按着技能键，也能在规定时间内发技能。 函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。 函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。 debounce search搜索联想，用户在不断输入值时，用防抖来节约请求资源。 window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 throttle 鼠标不断点击触发，mousedown(单位时间内只触发一次) 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"节流防抖","slug":"节流防抖","permalink":"http://yoursite.com/tags/节流防抖/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"Vue相关问题","slug":"Vue相关问题","date":"2019-05-17T10:59:24.000Z","updated":"2020-02-03T04:54:34.731Z","comments":true,"path":"2019/05/17/Vue相关问题/","link":"","permalink":"http://yoursite.com/2019/05/17/Vue相关问题/","excerpt":"","text":"vue相关问题1. vue实现双向绑定的原理？MVVM 模式在于数据与视图的保持同步，意思是说数据改变时会自动更新视图，视图发生变化时会更新数据。 所以我们需要做的就是如何检测到数据的变化然后通知我们去更新视图，如何检测到视图的变化然后去更新数据。检测视图这个比较简单，无非就是我们利用事件的监听即可。那么如何才能知道数据属性发生变化呢？这个就是利用我们上面说到的 Object.defineProperty 当我们的属性发生变化时，它会自动触发 set 函数从而能够通知我们去更新视图。 数据双向绑定作为 Vue 核心功能之一，Vue 则采用的是数据劫持与发布订阅相结合的方式实现双向绑定。 其中数据劫持是利用了 Object.defineProperty() 方法重新定义了对象获取属性值get和设置属性值set的操作来实现的； 劫持了数据之后，我们就需要一个监听器 Observer 来监听属性的变化。得知属性发生变化之后我们需要一个 Watcher 订阅者来更新视图，我们还需要一个 compile 指令解析器，用于解析我们的节点元素的指令与初始化视图。 Observer 监听器：用来监听属性的变化通知订阅者 Watcher 订阅者：收到属性的变化，然后更新视图（这个过程中我们可能会有很多个订阅者 Watcher 所以我们要创建一个容器 Dep 去做一个统一的管理） Compile 解析器：解析指令，初始化模版，绑定订阅者 语法 Object.defineProperty(obj,prop,descriptor) 参数：obj：目标对象；prop：需要定义的属性或方法的名称；descriptor：目标属性所拥有的特性 可供定义的特性列表 可供定义的特性 value 属性的值 writable 如果为false，属性的值就不能被重写 get 一旦目标属性被访问就会调回此方法，并将此方法的运算结果返回用户 set 一旦目标属性被赋值，就会调回此方法 configurable 如果为false，则任何尝试删除目标属性或修改属性性以下特性（writable, configurable, enumerable）的行为将被无效化。 enumerable 是否能在for…in循环中遍历出来或在Object.keys中列举出来 12345678910var obj = &#123; &#125;;var name;Object.defineProperty(obj, &quot;data&quot;, &#123; //获取值 get:function () &#123;return name;&#125;, //设置值 set:function (val) &#123;name = val;console.log(val);&#125;&#125;) obj.data = &apos;aaa&apos;;//赋值调用set console.log(obj.data); //取值调用get 当我们访问或设置对象的属性的时候，都会触发相对应的函数，然后在这个函数里返回或设置属性的值。既然如此，我们当然可以在触发函数的时候动一些手脚做点我们自己想做的事情，这也就是“劫持”操作。 在Vue中其实就是通过Object.defineProperty来劫持对象属性的setter和getter操作，并“种下”一个监听器，当数据发生变化的时候发出通知。 注意： 该方法每次只能设置一个属性，那么就需要遍历对象来完成其属性的配置： 1Object.keys(student).forEach(key =&gt; defineReactive(student, key)) 另外还必须是一个具体的属性，这也非常的致命。假如后续需要扩展该对象，那么就必须手动为新属性设置 setter 和 getter 方法，这就是为什么不在 data 中声明的属性无法自动拥有双向绑定效果的原因 。这时需要调用 Vue.set()手动设置。 针对 Array 类型的劫持 数组是一种特殊的对象，其下标实际上就是对象的属性，所以理论上是可以采用 Object.defineProperty() 方法处理数组对象。 但是 Vue 并没有采用上述方法劫持数组对象，原因分析：1、特殊的 length 属性，相比较对象的属性，数组下标变化地相对频繁，并且改变数组长度的方法也比较灵活，一旦数组的长度发生变化，那么在无法自动感知的情况下，开发者只能手动更新新增的数组下标，这可是一个很繁琐的工作。2、数组主要的操作场景还是遍历，而对于每一个元素都挂载一个 get 和 set 方法，恐怕也是不小的性能负担。 数组方法的劫持：最终 Vue 选择劫持一些常用的数组操作方法，从而知晓数组的变化情况：push&#39;, &#39;pop&#39;, &#39;shift&#39;, &#39;unshift&#39;, &#39;sort&#39;, &#39;reverse&#39;, &#39;splice&#39;。数组方法的劫持涉及到原型相关的知识，首先数组实例大部分方法都是来源于 Array.prototype 对象。顺便提一下，采用 Vue.set() 方法设置数组元素时，Vue 内部实际上是调用劫持后的 splice() 方法来触发更新。 总结：由上述内容可知，Vue 中的数据劫持分为两大部分： 针对 Object 类型，采用 Object.defineProperty()方法劫持属性的读取和设置方法； 针对 Array 类型，采用原型相关的知识劫持常用的函数，从而知晓当前数组发生变化。 并且 Object.defineProperty() 方法存在以下缺陷：每次只能设置一个具体的属性，导致需要遍历对象来设置属性，同时也导致了无法探测新增属性；属性描述符 configurable 对其的影响是致命的。 1.1发布订阅模式在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。 在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。 观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）。 1.2 数据无法双向绑定的情况Object.freeze(); 或者 数据未在实例中进行初始化 123var obj = &#123; foo: &apos;bar&apos;&#125;Object.freeze(obj)new Vue(&#123; el: &apos;#app&apos;, data: obj&#125;) Object.freeze()方法有三个特点： 1.使对象不可扩展，无法向其添加新属性。 2.为对象的所有属性将 configurable 特性设置为 false。在 configurable 为 false 时，无法更改属性的特性且无法删除属性。 3.为对象的所有数据属性将 writable 特性设置为 false。当 writable 为 false 时，无法更改数据属性值。 数据未在实例中进行初始化 只有当实例被创建时 data 中存在的属性才是响应式的。也就是说如果你添加一个新的属性在created生命周期完成后，那么数据将无法进行绑定，如直接使用vm.a=”xxx”，虽然a成了实例的一个属性，但是对它的任何修改将不是响应式的 2. vue组件之间的传值？ 父传子： 先在父组件中绑定变量，parent是定义在父组件中的变量/值； 再在子组件中添加props属性接收父组件传递过来的变量props:[&#39;msg&#39;]； 最后就可以在子组件中使用``来表示父组件中parent变量中的值了。 子传父： 先在子组件中绑定事件@change=”sendChild”，触发的时候在setChild事件中用$emit()触发父组件中的函数，并将子组件中的变量作为参数传递； 12345methods：&#123; sendChild:function()&#123; this.$emit(&apos;transparent&apos;,this.msg) &#125;&#125; 在父组件中绑定事件&lt;child @transparent=&quot;getChild&quot;&gt;&lt;/child&gt;，当子组件触发这个事件的时候，就可以调用getChild方法获取到传递过来的参数； 12345methods:&#123; getChild(msg)&#123; this.user=msg; &#125;&#125; 1.兄弟组件互相传值，通过Vuex状态管理传值： 先通过npm加载vuex，创建store.js文件 1234567891011//store.js import Vue from &apos;vue&apos; import Vuex from &apos;vuex&apos; Vue.use(Vuex); const state=&#123;name:&apos;Alice&apos;&#125;; const mutations=&#123; newName(state,message)&#123; state.name=message &#125; &#125; export default new Vuex.Store(&#123;state,mutations&#125;) 2.兄弟组件互相传值，引入bus.js文件，发布者订阅者模式： 1import Bus from &apos;./bus.js&apos; 1234//一个子组件触发methods:&#123; Bus.$emit(&apos;触发的方法名&apos;，需要传递的值);&#125; 1234//一个子组件监听 mounted:&#123; bus.$on(&quot;方法名&quot;,(传递的值)=&gt;&#123; &#125;) &#125; 3.兄弟组件互相传值$root 12345//一个子组件触发this.$root.$emit(&apos;触发的方法名&apos;，需要传递的值);//一个子组件监听this.$root.$off(&quot;方法名&quot;);//每次进入先关闭一下this.$root.$on(&quot;方法名&quot;,(传递的值)=&gt;&#123; &#125;) 3.vue的生命周期有哪些？它们有什么不同？ 生命周期钩子 组件状态 响应类型 最佳实践 beforeCreate 实例初始化之后，this指向创建的实例，不能访问到data、computed、watch、methods（都不存在）上的方法和数据 拿不到任何信息，无法篡改数据，一般做loding，这个时候的vue实例还什么都没有，但是$route对象是存在的，可以根据路由信息进行重定向之类的操作。 常用于初始化非响应式变量 created 实例创建完成，可访问data、computed、watch、methods上的方法和数据，还未挂载到DOM，不能访问到$el属性，$ref属性内容为空数组 $el,没有初始化，数据已加载完成，可以篡改数据，并更新，不会触发beforeUpdate，updated，在这结束loading，还做一些初始化，实现函数自执行 ，$ref属性内容为空数组；定义getter、setter存储器属性，在实例创建之后被调用，该阶段可以访问data，可以使用this。该阶段允许执行http请求操作。 常用于简单的ajax请求，页面的初始化 beforeMount 在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数 $el已被初始化，数据已加载完成，阔以篡改数据，并更新，不会触发beforeUpdate，updated。将HTML解析生成AST节点，再根据AST节点动态生成渲染函数。相关render函数首次被调用(划重点)。 - mounted 实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问 $el已被初始化，数据已加载完成，阔以篡改数据，并更新，并且触发beforeUpdate，updated，在这发起后端请求，拿回数据，配合路由钩子做一些事情；在挂载完成之后被调用，执行render函数生成虚拟dom，创建真实dom替换虚拟dom，并挂载到实例。可以操作dom，比如事件监听 常用于获取信息和操作，ajax请求 beforeUpdate 响应式数据更新时调用，发生在虚拟DOM打补丁之前 $vm.data更新之后，虚拟dom重新渲染之前被调用。在这个钩子可以修改$vm.data，并不会触发附加的重渲染过程。 适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器 updated 虚拟DOM重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作 虚拟dom重新渲染后调用，若再次修改$vm.data，会再次触发beforeUpdate、updated，进入死循环 避免在这个钩子函数中操作数据，可能陷入死循环 beforeDestroy 实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例 常用于销毁定时器、解绑全局事件、销毁插件对象等操作 destroyed 实例销毁后调用，调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 - 注： created和mounted之间的区别： created和mounted中ajax请求的区别：created的时候视图未出现，请求较多的情况下，会出现白屏； created 是在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图，比如初始化、获取屏幕高度调整、赋值等等； 而mounted是在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作； 初始化组件的时候，仅执行beforeCreated/created/beforeMount/mounted四个钩子函数； 当改变data中定义的响应式变量时，会执行beforeUpadate/updated； 初始化和销毁时的钩子函数只会执行一次，beforeUpadate/updated可执行多次； 挂载的时候，子组件完成挂载后，父组件才会挂载； 当子组件完成挂载后，父组件会主动执行一次beforeUpdate/updated钩子函数（仅首次）； 销毁父组件时，先将子组件销毁后，才会销毁父组件； 总结来说，虚拟dom开始渲染是在beforeMount时，dom实例挂载完成在mounted阶段显示。那么接下来了解就是render函数。render函数最终返回的是createNodeDescription(节点描述)，即俗称virtual node(虚拟节点)。 4. vuex的功能？能否进行兄弟组件之间的传值？vuex专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 主要用于管理vue中的数据，可以兄弟组件互相传值； 上图的解释： ① Vue Components 是我们的 vue 组件，组件会触发（dispatch）一些事件或动作( Actions); ② 我们在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，我们不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中； ③ 然后 Mutations 就去改变（Mutate）State 中的数据； ④ 当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components (组件)中去， Vue Components (组件)展示更新后的数据，完成一个流程。 Vuex 的核心是 Store（仓库），相当于是一个容器，一个Store实例中包含以下属性的方法： state 定义属性（状态 、数据） getters 用来获取属性【就像计算属性，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算；getter 接受 state 作为其第一个参数；】 actions 定义方法（动作）【也可以直接修改state，通过提交 mutation 的方式，而非直接改变 this.$store.state.count，是因为我们想要更明确地追踪到状态的变化；】 commit 提交变化，修改数据的唯一方式就是显示的提交 mutations mutations 定义变化，处理状态（数据）的改变【操作state中的数据store.commit(&#39;increment&#39;)；】 mapGetters 用来获取属性（数据） mapActions 用来获取方法（动作）state：管理项目的数据（进行数据初始化）； mutation和action之间有什么区别？怎么写代码修改vuex中的数据？ 12345Vuex.Store(&#123; state, actions, mutation&#125;); action可以包含任意异步操作，提交的是mutation，而不是直接变更状态； mutation是同步的。使用this.$store.commit(&#39;xxx&#39;) 来提交mutation。 （下文来自尤大大） 区分 actions 和 mutations 并不是为了解决竞态问题，而是为了能用 devtools 追踪状态变化。 事实上在 vuex 里面 actions 只是一个架构性的概念，并不是必须的，说到底只是一个函数，你在里面想干嘛都可以，只要最后触发 mutation 就行。异步竞态怎么处理那是用户自己的事情。vuex 真正限制你的只有 mutation 必须是同步的这一点（在 redux 里面就好像 reducer 必须同步返回下一个状态一样）。 同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。 如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态。 123&lt;div id=&quot;app1&quot;&gt; 8&lt;/div&gt; 123456789101112131415161718192021//store.jsimport Vue from &apos;vue&apos;;import Vuex from &apos;vuex&apos;;Vue.use(Vuex);const store = new Vuex.Store(&#123; state:&#123; count:0 &#125;&#125;);new Vue(&#123; el:&apos;#app1&apos;, store, computed:&#123; count()&#123; return this.$store.state.count &#125; &#125;&#125;) 4.1vuex的使用需要在根实例main.js中传入store 1234567891011121314151617import store from &apos;./store&apos;import &apos;styles/reset.css&apos;import &apos;styles/border.css&apos;import &apos;styles/iconfont.css&apos;import &apos;swiper/dist/css/swiper.css&apos;Vue.config.productionTip = falsefastClick.attach(document.body)Vue.use(VueAwesomeSwiper)new Vue(&#123; el: &apos;#app&apos;, router, store, components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;&#125;) 写在一个页面上的话，需要判断本地是否已经有这个数据了 在src–store–index.js中声明state、mutations 1234567891011import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;import state from &apos;./state&apos;import mutations from &apos;./mutations&apos;Vue.use(Vuex)export default new Vuex.Store(&#123; state, mutations&#125;) 然后在src–store–state.js中声明公共使用的数据 12345678910let defaultCity = &apos;上海&apos;try &#123; if (localStorage.city) &#123; defaultCity = localStorage.city &#125;&#125; catch (e) &#123;&#125;export default &#123; city: defaultCity //调用的时候，调用city就可以了&#125; 在src–store–mutations.js中声明改变公共变量的方法 12345678export default &#123; changeCity (state, city) &#123; //调用的时候使用changeCity就可以了 state.city = city try &#123; localStorage.city = city &#125; catch (e) &#123;&#125; &#125;&#125; 在实际使用的页面中，就可以直接使用了 123456// 调用数据this.$store.state.city//修改store中的内容this.$store.dispatch(&apos;name&apos;,value)//或者直接使用commit进行修改this.$store.commit(&apos;name&apos;,value) 5. Axios调取数据？[页面直接引用 &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;] 5.1 axios的特性1.可以从浏览器中创建XHR对象 2、可以从nodeJS中创建HTTP请求 3、支持Promise 4、可以拦截请求和响应 5、可以转换请求数据和响应数据 6、可以取消请求 7、可以自动转换JSON数据 8、客户端支持防御XSRF axios get 方法：仅仅请求后台数据 1234567axios.get(&apos;index.php&apos;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); aixos post方法：post请求更多的是要提交数据，params属性里的数据会出现在请求主体中。 12345678910axios.post(&apos;/user&apos;, &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 多并发请求,一次性发几个请求 123456789101112function getUserAccount() &#123; return axios.get(&apos;/user/12345&apos;);&#125;function getUserPermissions() &#123; return axios.get(&apos;/user/12345/permissions&apos;);&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // acct为第一个请求的结果，perms为第二个请求的结果 &#125;)); 设置拦截器： 12345678910//请求拦截器 axios.interceptors.request.use( config =&gt; &#123; btn.innerHTML=&apos;请求数据中&apos;; return config; &#125;, // 错误时发生的事情 err =&gt; &#123; console.log(err) &#125;); 12345678910// 响应应拦截器 axios.interceptors.response.use( config =&gt; &#123; btn.innerHTML=&apos;请求数据成功&apos;; return config; &#125;, // 错误时发生的事情 err =&gt; &#123; console.log(err) &#125;); 设置自定义请求头： 先安装Axios：npm install axios --save 再在main.js中引入Axios： 12import axios from &apos;axios&apos;Vue.prototype.$http = axios; 即可在组件中调用Axios： 123456this.$axios.get(&apos;index.php/url&apos;) .then(response =&gt; &#123; console.log(response) &#125;).catch(error =&gt; &#123; console.log(error) &#125;); 然后设置自定义的头请求： axios.defaults.timeout = 5000;//请求超时的时间设定 axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/json&#39;; //axios默认的请求方式 axios.defaults.baseURL = &#39;http://localhost:8008&#39;;//axios默认的请求地址 axios.defaults.headers.common[&quot;token&quot;] = &quot;noname&quot;;//有些接口必须登录才可以调用，而登陆注册并未写好，后台给了一个故固定的token，写在了头里面 6. vue使用的UI框架？animate.css是一款前端动画库，相似的有velocity-animate； （element ui框架的按钮组件； iView 是一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品 Vuetify.js根据材料设计规格提供 UI 布局； 基于 Vue.js 的 Bootstrap 组件； cube-ui 是滴滴团队开发的基于 Vue.js 实现的精致移动端组件库； vue-beauty 是一套基于 vue.js 和 ant-design样式 的PC端 UI 组件库； AT-UI 是一个模块化的前端 UI 框架，基于Vue.js 的快速和强大的 Web 界面；专门为桌面应用程序构建； Vue-Blu是基于Vue.js和Bulma开发的开源UI组件库。旨在为PC端的前端开发(特别是中后台产品)提供一个快速且灵活的解决方案。） 使用步骤： 首先npm install animate.css –save； 然后在vue文件的script中引入import animate from ‘animate.css’； 最后绑定元素使用，如下： 12345&lt;template&gt; &lt;div class=&quot;song&quot;&gt; &lt;p id=&quot;f&quot; @click=&apos;fade&apos;&gt;hello&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 12345methods:&#123; fade:function()&#123; $(&apos;#f&apos;).addClass(&apos;animated bounceOutLeft&apos;) &#125;&#125; 部分api常见： 12345678910111213141516171819202122232425262728fade: &#123; title: &apos;淡入淡出&apos;, fadeIn: &apos;淡入&apos;, fadeOut: &apos;淡出&apos;, &#125;, bounce: &#123; title: &apos;弹跳类&apos;, bounceIn: &apos;弹跳进入&apos;, bounceOut: &apos;弹跳退出&apos;, &#125;, zoom: &#123; title: &apos;缩放类&apos;, zoomIn: &apos;放大进入&apos;, zoomOut: &apos;缩小退出&apos;, &#125;, rotate: &#123; title: &apos;旋转类&apos;, rotateIn: &apos;顺时针旋转进入&apos;, &#125;, flip: &#123; title: &apos;翻转类&apos;, &#125;, strong: &#123; title: &apos;强调类&apos;, bounce: &apos;弹跳&apos;, flash: &apos;闪烁&apos;, &#125; 7.v-if和v-show之间的区别？ 相同点：v-if与v-show都可以动态控制dom元素显示隐藏 不同点： 实现本质方法区别 vue-show本质就是标签display:为none;，控制隐藏，DOM结构是一直存在的 vue-if是动态的向DOM树内添加或者删除DOM元素 编译的区别 v-show其实就是在控制css v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件 编译的条件 v-show都会编译，初始值为false，只是将display设为none，但它也编译了 v-if初始值为false，就不会编译了 性能 v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，故v-show性能更好一点。 8.v-for中key值的作用？ key的作用主要是为了高效的更新虚拟DOM。另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。 在用v-for更新已渲染的元素列表的时候，会使用就地复用的策略；这就是说列表数据修改的时候，他会根据key值去判断某个值是否修改，如果修改了就重新渲染，不然就复用之前的元素。 9.vue中插槽的作用？ 插槽就是Vue实现的一套内容分发的API，将&lt;slot&gt;&lt;/slot&gt;元素作为承载分发内容的出口，没有插槽的情况下在组件标签内些一些内容是不起任何作用的。 插槽内可以是任意内容。在&lt;child-component&gt;你好&lt;/child-component&gt;内放置一些内容，输出内容还是在组件中的内容，直接在父组件的&lt;child-component&gt;标签中定义的内容不会被渲染。在子组件template中加入元素占位，便能渲染父组件标签下的内容。 具名插槽，当需要多个插槽时，可以使用&lt;slot&gt;的特性：name。这个特性可以用来定义额外的插槽。 123456&lt;div id=&quot;root&quot;&gt; &lt;child&gt; &lt;header slot=&quot;header&quot;&gt;header&lt;/header&gt; &lt;footer slot=&quot;footer&quot;&gt;footer&lt;/footer&gt; &lt;/child&gt; &lt;/div&gt; 123456789101112 Vue.component(&apos;child&apos;,&#123; template:`&lt;div&gt; &lt;slot name=&quot;header&quot;&gt;default header&lt;/slot&gt; &lt;div&gt;content&lt;/div&gt; &lt;slot name=&quot;footer&quot;&gt;default footer&lt;/slot&gt; &lt;/div&gt;` &#125; ) var vm=new Vue(&#123; el:&apos;#root&apos; &#125;)//输出结果是 header content footer 插槽默认内容 ，插槽可以提供一个默认内容，如果如果父组件没有为这个插槽提供了内容，会显示默认的内容。如果父组件为这个插槽提供了内容，则默认的内容会被替换掉。 作用域插槽，作用域插槽就是父组件在调用子组件的时候给子组件传了一个插槽，这个插槽为作用域插槽，该插槽必须放在template标签里面，同时声明从子组件接收的数据放在一个自定义属性内，并定义该数据的渲染方式。（解决的问题：调用了两次child组件，因为调用的是同一个子组件，所以显示的内容完全一样。如何在每次调用时能有各自的渲染效果？） 123456789101112&lt;div id=&quot;root&quot;&gt; &lt;child&gt; &lt;template slot-scope=&quot;props&quot;&gt;&lt;!--该插槽必须放在template标签内--&gt; &lt;li&gt;&lt;/li&gt; &lt;!--定义渲染方式--&gt; &lt;/template&gt; &lt;/child&gt; &lt;child&gt; &lt;template slot-scope=&quot;props&quot;&gt; &lt;h1&gt;&lt;/h1&gt;&lt;!--定义渲染方式--&gt; &lt;/template&gt; &lt;/child&gt; &lt;/div&gt; 12345678910111213141516Vue.component(&apos;child&apos;,&#123; data: function()&#123; return &#123; list:[1,2,3,4] &#125; &#125;, template: `&lt;div&gt; &lt;ul&gt; &lt;slot v-for=&quot;value in list&quot; :value=value&gt;//使用slot占位 &lt;/slot&gt; &lt;/ul&gt; &lt;/div&gt;` &#125;) var vm=new Vue(&#123; el: &apos;#root&apos; &#125;) 10.vue中watch和computed有什么区别？分别在哪种场合下使用？监听的是data里面的值吗？ computed 计算属性 watch 观察的动作 methods 1. 数据会被缓存，只要依赖不发生改变，即使页面重新渲染，该方法也不会被调用 2.computed中的函数必须用return返回 1. 直接监测一个值的变化，监测值不发生变化，该方法就不会调用； 2. watch只会监听数据的值是否发生改变，而不会去监听数据的地址是否发生改变。也就是说，watch想要监听引用类型数据的变化，需要进行深度监听。 3.watch中的函数有两个参数，前者是newVal，后者是oldVal。 每次页面发生渲染，都会被重新调用 在computed中不要对data中的属性进行赋值操作。如果对data中的属性进行赋值操作了，就是data中的属性发生改变，从而触发computed中的函数，形成死循环了。 监听复杂数据类型需用深度监听（在被监听对象中使用handler）；特殊情况下，watch无法监听到数组的变化，特殊情况就是说更改数组中的数据时，数组已经更改，但是视图没有更新。更改数组必须要用splice()或者$set。 使用场景：当一个值受多个属性影响的时候————购物车商品结算 使用场景：当一条数据的更改影响到多条数据的时候———搜索框 computed和watch区别： 1、 功能上：computed是计算属性，也就是依赖其它的属性计算所得出最后的值，是用于定义基于数据之上的数据。watch是监听一个值的变化，然后执行对应的回调，是在某个数据变化时做一些事情。 2、 是否调用缓存：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调。 3、 是否调用return：computed中的函数必须要用return返回，watch中的函数不是必须要用return。 4、 如果一个值依赖多个属性（多对一），用computed肯定是更加方便的。如果一个值变化后会引起一系列操作，或者一个值变化会引起一系列值的变化（一对多），用watch更加方便一些。 11.数据请求应该添加在生命周期的哪里？ 看实际情况，一般在 created（或beforeRouter） 里面就可以，如果涉及到需要页面加载完成之后的话就用 mounted。主要的区分在于是否需要操作DOM结构。 1.在created的时候，视图中的html并没有渲染出来，所以此时如果直接去操作html的dom节点，一定找不到相关的元素； 2.而在mounted中，由于此时html已经渲染出来了，所以可以直接操作dom节点，（此时document.getelementById 即可生效了）； 12.vue组件中data为什么是函数是因为js本身的特性带来的，跟vue本身设计无关。类比引用数据类型：Object是引用数据类型,如果不用function 返回,每个组件的data 都是内存的同一个地址,一个数据改变了其他也改变了; 123456789101112131415//如果直接赋值，两个实例同时引用一个对象，那么当你修改其中一个属性的时候，另外一个实例也会跟着改var MyComponent = function() &#123;&#125;MyComponent.prototype.data = &#123; a: 1, b: 2,&#125;// 上面是一个虚拟的组件构造器，真实的组件构造器方法很多var component1 = new MyComponent()var component2 = new MyComponent()// 上面实例化出来两个组件实例，也就是通过&lt;my-component&gt;调用，创建的两个实例component1.data.a === component2.data.a // truecomponent1.data.b = 5;component2.data.b // 5 123456Vue.component(&apos;my-component&apos;, &#123; template: &apos;&lt;div&gt;OK&lt;/div&gt;&apos;, data() &#123; return &#123;&#125; // 返回一个唯一的对象，不要和其他组件共用一个对象进行返回 &#125;,&#125;) data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立,不会相互影响； 13.多页应用与单页应用的区别？以及优缺点多页应用： 定义：每一次页面的跳转，后端都会返回一个新的html文件。 优点：1. 首屏事件快（只请求 html 文件就可以展示页面了，只经历了一个http请求）；2. SEO（搜索引擎优化，可以识别 html 内的内容）效果好。 缺点：页面切换慢（每次跳转都要发送一个http请求） 单页应用： 定义：每一次页面的跳转，都是使用JS渲染。页面跳转不使用 a 标签，而是使用&lt;router-link to=&quot;./list&quot;&gt;&lt;/router-link&gt;，不请求html文件，通过JS感知到URL的变化，可以用JS动态得把当前页面清除掉，再把下一个页面挂载到当前页面上。 优点：页面切换快。不需要http请求。 缺点：首屏时间稍慢（除了请求一个html文件，还要请求一个 JS 文件）; SEO差（不认识JS文件中的内容） 13.vue router[路由守卫]有哪些钩子函数，哪一个是可以在全局使用的主要用来作用是拦截导航，让他完成跳转或取消。 完整的导航解析流程 导航被触发。 在失活的组件里调用离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 有三种方式可以植入路由导航过程中：全局的；单个路由独享的；组件级的 ①.全局导航钩子 router.beforeEach 全局前置守卫 进入路由之前 router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用 router.afterEach 全局后置钩子 进入路由之后 1234567891011// main.js 入口文件import router from &apos;./router&apos;; // 引入路由router.beforeEach((to, from, next) =&gt; &#123; next();&#125;);router.beforeResolve((to, from, next) =&gt; &#123; next();&#125;);router.afterEach((to, from) =&gt; &#123; console.log(&apos;afterEach 全局后置钩子&apos;);&#125;); 这三个参数 to 、from 、next 分别的作用： to: Route，代表要进入的目标，它是一个路由对象；路由对象指的是平时通过this.$route获取到的路由对象。 from: Route，代表当前正要离开的路由，同样也是一个路由对象 next: Function，这是一个必须需要调用的方法，而具体的执行效果则依赖 next 方法调用的参数 next()：进入该路由。进入管道中的下一个钩子，如果全部的钩子执行完了，则导航的状态就是 confirmed（确认的） next(false)：取消进入路由，这代表中断掉当前的导航，即 to 代表的路由对象不会进入，被中断，此时该表 URL 地址会被重置到 from 路由对应的地址(也就是将要离开的路由地址)。 next(‘/’) 和 next({path: ‘/’})：在中断掉当前导航的同时，跳转到一个不同的地址 next(error)：如果传入参数是一个 Error 实例，那么导航被终止的同时会将错误传递给 router.onError() 注册过的回调 注意：next 方法必须要调用，否则钩子函数无法 resolved 不同于前置守卫，后置钩子并没有 next 函数，也不会改变导航本身 ②.路由独享的钩子：即单个路由独享的导航钩子，它是在路由配置上直接进行定义的 1234567const router = new VueRouter(&#123; routes: [&#123; path: &apos;/file&apos;, component: File, beforeEnter: (to, from ,next) =&gt; &#123;/*do someting*/&#125; &#125;]&#125;); ③.组件内的导航钩子：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。直接在路由组件内部直接进行定义的 123456789101112131415const File = &#123; template: `&lt;div&gt;This is file&lt;/div&gt;`, beforeRouteEnter(to, from, next) &#123; // do someting // 在渲染该组件的对应路由被 confirm 前调用 &#125;, beforeRouteUpdate(to, from, next) &#123; // do someting // 在当前路由改变，但是依然渲染该组件是调用 &#125;, beforeRouteLeave(to, from ,next) &#123; // do someting // 导航离开该组件的对应路由时被调用 &#125;&#125; 注意：beforeRouteEnter 不能获取组件实例 this，因为当守卫执行前，组件实例被没有被创建出来，剩下两个钩子则可以正常获取组件实例 this；但是并不意味着在beforeRouteEnter中无法访问组件实例，我们可以通过给 next 传入一个回调来访问组件实例。在导航被确认是，会执行这个回调，这时就可以访问组件实例了： 1234//注意，仅仅是 beforRouteEnter 支持给 next 传递回调，其他两个并不支持。因为归根结底，支持回调是为了解决 this 问题，而其他两个钩子的 this 可以正确访问到组件实例，所有没有必要使用回调beforeRouteEnter(to, from, next) &#123; next (vm =&gt; &#123;/*这里通过 vm 来访问组件实例解决了没有 this 的问题*/&#125;)&#125; 14.data为什么要用return？不是为了使每个组件有独立的数据？（摘自vue官方文档）当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。 15.vue中的定时器，一般在哪个生命周期中清除在beforeDestroy（）里面清除定时器， 1234beforeDestroy() &#123; clearInterval(this.timer); this.timer = null;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"vue中生成二维码","slug":"vue中生成二维码","date":"2019-04-26T13:18:32.000Z","updated":"2020-02-03T04:09:06.118Z","comments":true,"path":"2019/04/26/vue中生成二维码/","link":"","permalink":"http://yoursite.com/2019/04/26/vue中生成二维码/","excerpt":"","text":"动态创建二维码相关问题1. 动态生成二维码先在终端中安装 1npm install qrcodejs2 然后在要生成二维码的页面中调用 1import QRCode from &apos;qrcodejs2&apos; 然后在要展示二维码的结构处，为结构添加class属性 1&lt;div class=&quot;qrcode&quot; ref=&quot;qrCodeUrl&quot;&gt;&lt;/div&gt; 然后在script标签中添加方法 1234567creatQrCode() &#123; // 创建一个实例对象 var qrcode = new QRCode(this.$refs.qrCodeUrl, &#123; text: &apos;https://www.qtshe.com&apos;, width: 100,height: 100,colorDark: &apos;#000000&apos;,colorLight: &apos;#ffffff&apos;, correctLevel: QRCode.CorrectLevel.H &#125;)&#125;, 到此为止，二维码的功能代码已经写完，但是最后一个方法是需要调用的，否则就没有效果。 如果是在页面点击进来就要显示的话，就去mounted(){}钩子里面调用一下this.creatQrCode();， 如果是点击某个按钮等触发事件出现二维码的，只要在触发事件中绑定该方法即可。 2.在二级弹窗中显示二维码①如果使用对话框显示二维码，有时会由于html元素还没有创建，导致生成二维码时报对象不存在或者appenchild方法未定义的错误。这时可以使用nextTick来处理。 12345678910showQRCode()&#123; this.$nextTick(()=&gt;&#123;/* 使用了nextTick之后，会在生成DOM元素之后绑定*/ var qrcode = new QRCode(this.$refs.qrcodeContainer, &#123; text: &apos;https://wallimn.iteye.com&apos;, width: 100, height: 100, colorDark: &apos;#000000&apos;, colorLight: &apos;#ffffff&apos;, correctLevel: QRCode.CorrectLevel.H &#125;) &#125; &#125; ②定义完方法后，只在点击出现对话框的时候，调用showQRCode的方法即可；可以不用在mounted里面进行调用。 ③多次点击会出现多个二维码，这个时候要设置this.$refs.qrCodeUrl.innerHTML=&#39;&#39;;，保证每一次点击重新生成二维码之前，都已经将之前的清除了； ④在跳转前的页面 设置的地址如下text:&quot;&#39;/qrcode/&#39; + id &quot;, 到了跳转到的页面，可以通过this.$route.params.id 获取到url中的id值","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"二维码","slug":"二维码","permalink":"http://yoursite.com/tags/二维码/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"Vue学习","slug":"Vue学习","date":"2019-04-07T13:48:13.000Z","updated":"2020-01-30T14:35:16.521Z","comments":true,"path":"2019/04/07/Vue学习/","link":"","permalink":"http://yoursite.com/2019/04/07/Vue学习/","excerpt":"","text":"Vue学习1基本介绍1.1为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱； 企业中，使用框架，能够提高开发的效率； 提高开发效率的发展历程： 原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率） 1.2什么是Vue.jshttps://cn.vuejs.org/v2/api/ ue.js是是一套用于构建用户界面的渐进式框架，是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 1.3.MVC和MVVM MVC M - Model ：数据保存 V - View : 用户界面 C - Controller ： 业务逻辑 用户操作–&gt; View (负责接受用户的输入操作)–&gt;Controller（业务逻辑处理）–&gt;Model（数据持久化）–&gt;View（将结果通过View反馈给用户） MVC有两个很明显的问题： m层和v层直接打交道，导致这两层耦合度高 因为所有逻辑都写在c层，导致c层特别臃肿 MVC 前端应用的复杂程度已不同往日，暴露出了三个痛点问题： 开发者在代码中大量调用相同的DOM API, 处理繁琐，操作冗余，使得代码难以维护。 大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。 当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致Model发生变化，开发者同样需要将变化的数据同步到Model中， 这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。 MVVM 的出现，完美解决了以上三个问题，MVVM 包含的三部分： Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑； View 代表UI 组件，它负责将数据模型转化成UI 展现出来 ViewModel 是一个同步View 和 Model的对象。View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互。ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图： 2.Vue使用2.1基本使用123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 1. 导入Vue的包 --&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- id=&quot;app&quot; : app指的是将来 new 的Vue实例，会控制这个元素中的所有内容 --&gt; &lt;!-- Vue 实例所控制的这个元素区域，就是我们的 View --&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 2. 创建一个Vue的实例，就是我们 MVVM中的 ViewModel // 当我们导入包之后，在浏览器的内存中，就多了一个 Vue 构造函数 var vm = new Vue(&#123; // 表示当前我们 new 的这个 Vue 实例，要控制页面上的哪个区域 el: &apos;#app&apos;, // 这里的 data 就是 MVVM中的 Model，专门用来保存每个页面的数据的 data: &#123; // data 属性中，存放的是el中要用到的数据 msg: &apos;欢迎学习Vue&apos; // 通过 Vue 提供的指令，很方便的就能把数据渲染到页面上， 程序员不再手动操作DOM元素了【前端的Vue之类的框架，不提倡我们去手动操作DOM元素了】 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.2 常用指令 v-cloak v-text v-html v-bind v-on v-model 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; [v-cloak] &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 使用 v-cloak 能够解决 插值表达式闪烁的问题 vue-2.4.0.js的加载需要时间，在vue-2.4.0.js没有成功加载之前， 页面会显示&#123; &#123;msg&#125;&#125;文本信息 --&gt; &lt;p v-cloak&gt;++++++++ &#123;&#123; msg &#125;&#125; ----------&lt;/p&gt; &lt;h4 v-text=&quot;msg&quot;&gt;==================&lt;/h4&gt; &lt;!-- 默认 v-text 是没有闪烁问题的 --&gt; &lt;!-- v-text会覆盖元素中原本的内容，但是插值表达式只会替换自己的这个占位符， 不会把整个元素的内容清空 --&gt; &lt;div&gt;&#123;&#123;msg2&#125;&#125;&lt;/div&gt; &lt;div v-text=&quot;msg2&quot;&gt;&lt;/div&gt; &lt;!-- v-html会覆盖元素中原本的内容，只不过会将msg2当做html文本进行解析 --&gt; &lt;div v-html=&quot;msg2&quot;&gt;1212112&lt;/div&gt; &lt;!-- v-bind: 是Vue中提供的用于绑定属性的指令，v-bind 中，可以写合法的JS表达式 --&gt; &lt;input type=&quot;button&quot; value=&quot;按钮1&quot; v-bind:title=&quot;mytitle + &apos;123&apos;&quot;&gt; &lt;!-- 注意： v-bind: 指令可以被简写为 :要绑定的属性 --&gt; &lt;input type=&quot;button&quot; value=&quot;按钮2&quot; :title=&quot;mytitle + &apos;3455&apos;&quot;&gt; &lt;!-- Vue 中提供了 v-on: 事件绑定机制 下面代码错误：因为vue会将alert理解为一个变量，而在Vue中我们并没有定义alert变量， 所以找不到 --&gt; &lt;!-- &lt;input type=&quot;button&quot; value=&quot;按钮3&quot; :title=&quot;mytitle + &apos;888&apos;&quot; v-on:click=&quot;alert(&apos;hello&apos;)&quot;&gt;--&gt; &lt;!--v-on:click可以简写成@click--&gt; &lt;input type=&quot;button&quot; value=&quot;按钮4&quot; @click=&quot;show&quot;&gt; &lt;/div&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg: &apos;123&apos;, msg2: &apos;&lt;h1&gt;哈哈，我是一个大大的H1， 我大，我骄傲&lt;/h1&gt;&apos;, mytitle: &apos;这是一个自己定义的title&apos; &#125;, methods: &#123; // 这个 methods属性中定义了当前Vue实例所有可用的方法 show: function () &#123; alert(&apos;Hello&apos;) &#125; &#125; &#125;) /* //在vue中不推荐我们再去使用dom操作的方法 document.getElementById(&apos;btn&apos;).onclick = function()&#123; alert(&apos;Hello&apos;) &#125; */ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.3事件修饰符 .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 2.4 v-model和双向绑定 只有v-model指令实现了双向绑定， v-model 只能运用在表单元素中。如： input(radio, text, address, email….) select checkbox textarea 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form id=&quot;app&quot; action=&quot;#&quot;&gt; &lt;p&gt;&lt;input v-model=&quot;email&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input v-model=&quot;name&quot;&gt;&lt;/p&gt; &lt;button @click=&quot;modify&quot;&gt;点我修改数据源&lt;/button&gt; &lt;button @click=&quot;show&quot;&gt;改完表单再点我&lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;&lt;script src=&quot;lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; email: &apos;zhangsan@qq.com&apos;, name: &apos;zhangsan&apos; &#125;, methods:&#123; modify:function()&#123; this.email = &apos;lisi@.qq.com&apos;; &#125;, show:function()&#123; alert(this.email); &#125; &#125; &#125;)&lt;/script&gt; 2.5 双向绑定的原理2.5.1页面–&gt;数据view更新data只需要添加DOM事件监听即可，比如input标签监听 ‘input’ 事件就可以实现 2.5.2数据–&gt;页面是通过数据劫持 + 发布者-订阅者模式的方式来实现的 2.5.3数据劫持1vue是通过Object.defineProperty()来实现数据劫持的 1234567891011121314var book = &#123;&#125;Object.defineProperty(book, &apos;name&apos;, &#123; set: function (value) &#123; name = value; console.log(&apos;你取了一个书名叫做&apos; + value); &#125;, get: function () &#123; return &apos;《&apos; + name + &apos;》&apos; &#125;&#125;)book.name = &apos;vue权威指南&apos;; // 你取了一个书名叫做vue权威指南book.name = &apos;vue权威指南2&apos;; // 你取了一个书名叫做vue权威指南console.log(book.name); // 《vue权威指南》 2.5.4发布订阅模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546//1.消息订阅器，内部维护了所有订阅者的列表function Dep () &#123; this.subs = [];&#125;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub); &#125;, notify: function(value) &#123; this.subs.forEach(function(sub) &#123; sub.update(value); &#125;); &#125;&#125;;var dep = new Dep();//2.订阅者function Watcher() &#123;&#125;Watcher.prototype = &#123; update: function(value)&#123; console.log(&quot;数据源已经变动，新的数据是&quot;+value) &#125;&#125;var w1 = new Watcher();var w2 = new Watcher();dep.addSub(w1);dep.addSub(w2);//3.数据源，通过defineProperty监听数据源的变化var book = &#123;&#125;Object.defineProperty(book, &apos;name&apos;, &#123; set: function (value) &#123; name = value; //一旦数据源发生变化了，通知所有的订阅者更新数据 dep.notify(value); &#125;, get: function () &#123; return &apos;《&apos; + name + &apos;》&apos; &#125;&#125;)book.name = &apos;vue权威指南&apos;; // 你取了一个书名叫做vue权威指南book.name = &apos;vue权威指南2&apos;; // 你取了一个书名叫做vue权威指南console.log(book.name); // 《vue权威指南》 2.5.5数据绑定的实现流程 首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。 因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。 接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。 1.监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知所有订阅者。 2.订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。 3.解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅者 2.6vue样式操作2.6.1 class操作 普通css &lt;h1 class=&quot;red thin&quot;&gt;这是一个很大很大的H1&lt;/h1&gt; vue第一种使用方式，直接传递一个数组,class需要使用 v-bind 做数据绑定 &lt;h1 :class=&quot;[&#39;thin&#39;, &#39;italic&#39;]&quot;&gt;这是一个很大很大的H1，&lt;/h1&gt; 在数组中使用三元表达式 &lt;h1 :class=&quot;[&#39;thin&#39;, &#39;italic&#39;, flag?&#39;active&#39;:&#39;&#39;]&quot;&gt;这是一个很大很大的H1&lt;/h1&gt; 在数组中使用对象来代替三元表达式，提高代码的可读性 &lt;h1 :class=&quot;[&#39;thin&#39;, &#39;italic&#39;, {&#39;active&#39;:flag} ]&quot;&gt;这是一个很大很大的H1&lt;/h1&gt; 2.6.2 style操作​ &lt;h1 :style=&quot;styleObj1&quot;&gt;标题1&lt;/h1&gt; ​ &lt;h1 :style=&quot;[styleObj1,styleObj2]&quot;&gt;标题2&lt;/h1&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"Vue结合webpack的使用","slug":"Vue结合webpack的使用","date":"2019-03-19T11:18:44.000Z","updated":"2020-01-28T14:45:09.921Z","comments":true,"path":"2019/03/19/Vue结合webpack的使用/","link":"","permalink":"http://yoursite.com/2019/03/19/Vue结合webpack的使用/","excerpt":"","text":"Vue结合webpack的使用1.基本使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#1.安装vue 运行npm i vue@2.3.4将vue安装为运行依赖 #2.main.js/* 注意：在webpack中使用 import Vue from &apos;vue&apos;导入的Vue构造函数功能不完整，只提供了runtime-only的方式，并没有提供像网页中那样的使用方式； import Vue from &apos;vue&apos; 导入包的规则： 1. 找项目根目录中有没有 node_modules 的文件夹 2. 在node_modules中根据包名，找对应的vue文件夹 3. 在vue文件夹中，找一个叫做 package.json 的包配置文件 4. 在package.json文件中，查找一个 main 属性【main属性指定了这个包在被加载时候的入口文件】，这里我们发现入口文件为vue.runtime.common.js，并不是vue.js文件 解决方案有两种： 1.在webpack.config.js下新增配置： resolve: &#123; alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.js&apos; &#125; &#125; 然后使用 import Vue from &apos;vue&apos; 就可以了 2.手动修改导包的路径为：import Vue from &apos;vue/dist/vue&apos;&apos;，此时无需修改配置文件*/import Vue from &apos;vue&apos;var login = &#123; template: &apos;&lt;h1&gt;这是login组件，是使用网页中形式创建出来的组件&lt;/h1&gt;&apos;&#125;var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg: &apos;123&apos; &#125;, components:&#123; login &#125;&#125;)#3.index.html&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;login&gt;&lt;/login&gt;&lt;/div&gt;#4.webpack.config.jsresolve: &#123; alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.js&apos; &#125;&#125;#5.package.json、.babelrc还有webpack的所需要安装的内容和之前一致 2.使用.vue的方式生成组件1vscode中安装vetur插件，可以格式化html、标准css（有分号 、大括号的那种）、标准js（有分号 、双引号的那种）、vue文件webstorm中支持vue文件的提示，需要安装插件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#1. 新建login.vue文件&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是登录组件，使用 .vue 文件定义出来的 &lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;#2.main.js引入.vue文件，并使用import Vue from &apos;vue&apos;import login from &apos;./login.vue&apos;var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg: &apos;123&apos; &#125;, components:&#123; login &#125;&#125;)#3. index.html&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;login&gt;&lt;/login&gt;&lt;/div&gt;#4.安装vue-loader和 vue-template-compiler(默认情况下不支持import方式引入.vue文件，需要安装下面两个文件)npm i vue-loader@15.4.2 vue-template-compiler@2.3.4//注意：这里vue-template-compiler版本需要和当前使用的vue版本一致#5.webpack.config.jsconst path = require(&apos;path&apos;)var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);//1.引入VueLoaderPlugin插件(在vue-loader15版本以后需要配置这个)const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin&apos;);module.exports = &#123; entry: path.join(__dirname, &apos;./src/main.js&apos;), output: &#123; path: path.join(__dirname, &apos;./dist&apos;), filename: &apos;bundle.js&apos; &#125;, plugins: [ new htmlWebpackPlugin(&#123; template:path.resolve(__dirname, &apos;src/index.html&apos;),//模板路径 filename:&apos;index.html&apos;//自动生成的HTML文件的名称 &#125;), // 2.配置VueLoaderPlugin插件 new VueLoaderPlugin() ], module: &#123; rules: [ &#123; test: /\\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;, &#123; test: /\\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125;, &#123; test: /\\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125;, &#123; test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: &apos;url-loader?limit=1024&amp;name=[hash:8]-[name].[ext]&apos; &#125;, &#123; test: /\\.(ttf|eot|svg|woff|woff2)$/, use: &apos;url-loader&apos; &#125;, &#123; test: /\\.js$/, use: &apos;babel-loader&apos;, exclude: /node_modules/ &#125;, //3.处理 .vue 文件的 loader &#123; test: /\\.vue$/, use: &apos;vue-loader&apos; &#125; ] &#125;, resolve: &#123; alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.js&apos; &#125; &#125;&#125; 3.render渲染组件123456789101112131415#main.jsimport Vue from &apos;vue&apos;import login from &apos;./login.vue&apos;var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg: &apos;123&apos; &#125;, render: c =&gt; c(login)&#125;)//注意：此种方式会替换页面内容 4.vue组件中的数据2.4.1 模块的导出 ES6语法： 在ES6中使用 export default 和 export 导出模块中的成员; (Node中使用 module.exports 和 export导出成员) 使用 import ** from ** 和 import ‘路径’ 还有 import {a, b} from ‘模块标识’ 导入其他模块 123456789101112131415161718192021222324252627282930#1. 新建test.js// 在 ES6 中，使用 export default 和 export 向外暴露成员：var info = &#123; name: 'zs', age: 20&#125;export default info/* 注意： export default 向外暴露的成员，可以使用任意的变量来接收 在一个模块中，export default 只允许向外暴露1次 在一个模块中，可以同时使用 export default 和 export 向外暴露成员*/export var title = '小星星'export var content = '哈哈哈'/*注意： 使用 export 向外暴露的成员，只能使用 &#123; &#125; 的形式来接收，这种形式叫做 【按需导出】 export 可以向外暴露多个成员， 同时如果某些成员在我们import 的时候不需要，则可以不在 &#123;&#125; 中定义 使用 export 导出的成员，必须严格按照导出时候的名称来使用 &#123;&#125; 按需接收； 使用 export 导出的成员，如果想换个名称来接收，可以使用 as 来起别名；*/#2. main.jsimport minfo3, &#123; title as title123, content &#125; from './test.js'console.log(minfo3) //这里的minfo3就是test.js中所暴露出来的default infoconsole.log(title123 + ' --- ' + content) 2.4.2 .vue中的数据导出123456789101112131415161718192021222324#login.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是登录组件，使用 .vue 文件定义出来的 --- &#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;button @click=\"show\"&gt;点我&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; // 注意：组件中的 data 必须是 function return &#123; msg: \"123321\" &#125;; &#125;, methods: &#123; show() &#123; console.log(\"调用了 login.vue 中的 show 方法\"); &#125; &#125; &#125;;&lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"ES6基础知识","slug":"ES6基础知识","date":"2019-03-19T11:18:44.000Z","updated":"2020-01-29T06:23:44.262Z","comments":true,"path":"2019/03/19/ES6基础知识/","link":"","permalink":"http://yoursite.com/2019/03/19/ES6基础知识/","excerpt":"","text":"ES6基础知识1.let 和 const在ES6之前，js只有全局作用域和函数作用域，ES6中let关键字为其引入了块级作用域。 1234567//&#123;&#125;代码块&#123;var a = 5;let b = 6;&#125;console.log(a); //5console.log(b); //b is undefined let声明的变量只能在其所在的代码块内才能访问，var声明的变量由于是全局变量，因此可以在代码块外访问 const用来定义常量，相当于java中的final关键字。并且const声明常量之后就必须立即初始化！ et声明的变量一旦用let声明，那么在声明之前，此变量都是不可用的，术语称为“暂时性死区”。 12345console.log(a); //undefinedvar a=8;console.log(&quot;----------&quot;);console.log(b); //控制台报错let b=9; 2.解构赋值 ES6允许按照一定的模式从数组和对象中提取值，对变量进行赋值，这被称为解构。 (1)、基本用法 1234567//新的定义方法let [name,age,sex] = [&quot;李四&quot;,20,&quot;女&quot;];//以前的定义方法let name = &quot;李四&quot;;let age = 20;let sex = &quot;女&quot; (2)、对象的解构赋值 123//前面的key值和后面的key值相对应的let &#123;name,age,friends&#125; = &#123;name:&quot;zhangsan&quot;,age:12,friends:[&quot;lulu&quot;,&quot;女&quot;]&#125;;console.log(name); //zhangsan (3)、嵌套数组的解构赋值 123//只要一一对应就可以let [a1,[a2,a3,[a4,a5]]] = [1,[2,3,[4,5]]];console.log(a1,a2,a3,a4,a5); //1，2，3，4，5 (4)、字符串的解构赋值 123456let [a,b,c,d,e] = &quot;我是中国人&quot;;console.log(a); //我console.log(b); //是console.log(c); //中console.log(d); //国console.log(e); //人 (5)、空缺变量 1let [a,b,,e]=[&apos;a&apos;,&apos;b&apos;,[1,2],4] (6)、多余变量 1let [a,b,,e,f]=[&apos;a&apos;,&apos;b&apos;,[3,4],5] 注意：因为字符串有构造器，所以可以解析出来。 3.字符串的扩展1234567891011121314151617//Unicode表示法&quot;\\u&#123;码点&#125;&quot;&quot;\\u&#123;41&#125;\\u&#123;42&#125;\\u&#123;43&#125;&quot; //&quot;ABC&quot;let str = &quot;書剑恩仇录&quot;;str.codePointAt(0).toString(16); //返回字符的码点并由十进制转到16进制---66f8String.fromCodePoint(0x66f8); //返回码点对应的字符---書for (let a of str)&#123; console.log(a);&#125; //for...of循环遍历字符串中每个字符挨个输出字符str.at(0); //返回指定位置的字符，目前只是提案str.startsWith(&apos;書&apos;,0); //从指定位置往后开始检查，是否以“書”开始，位置参数可省略，默认为0str.endsWith(&apos;剑&apos;,1); //从指定位置向前检查，是否以“剑”结束str.includes(&apos;恩&apos;,1); //同上，不再啰嗦str.repeat(2); //字符串重复指定次数“書剑恩仇录書剑恩仇录”，小数取整，Infinity和负数报错str.padStart(8,&apos;ab&apos;); //指定字符从前开始补直到字符串长度符合要求，&quot;aba書剑恩仇录&quot;str.padEnd(8,&apos;ab&apos;); //指定字符从后开始补直到字符串长度符合要求，&quot;書剑恩仇录aba&quot;，若长度小于原长度，返回原字符串，上同 4.模版字符串使用``包裹字符串 ${}包裹变量 12345678910111213// 普通字符串`In JavaScript &apos;\\n&apos; is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1 string text line 2`);// 字符串中嵌入变量let name = &quot;Bob&quot;, time = &quot;today&quot;;`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 5.函数的扩展1.参数默认值12345678910111213141516ES5中的写法function log(x, y) &#123; //y = y || &apos;World&apos;; --&gt; 这种写法如果y是false则不起作用，所以用下面的方式复制 if (typeof y === &apos;undefined&apos;) &#123; y = &apos;World&apos;; &#125; console.log(x, y);&#125;log(&apos;Hello&apos;) // Hello WorldES6中的写法function log(x, y = &apos;World&apos;) &#123; console.log(x, y);&#125;log(&apos;Hello&apos;) // Hello World 2.箭头函数12345678910var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;;//如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;; 3.rest参数（剩余参数）1234function foo(a,b,...param)&#123; //...param会以数组的形式存储剩余的参数 console.log(param);&#125;foo(1,2,3,4,5,6,7);//[3,4,5,6,7] 6.数组的扩展1.Array.from1234let list = document.querySelectorAll(&quot;li&quot;) console.log(Array.isArray(list)); //false Array.from(list); //将非数组list转为数组 console.log(Array.isArray(Array.from(list))); //true 1Array.from(arrayLike[, mapFn[, thisArg]]) 返回值为转换后的数组。 arrayLike 想要转换的类数组对象或可迭代对象。 console.log(Array.from([1, 2, 3])); // [1, 2, 3] mapFn 可选，map 函数，用于对每个元素进行处理，放入数组的是处理后的元素。 1console.log(Array.from([1, 2, 3], (n) =&gt; n * 2)); // [2, 4, 6] thisArg 可选，用于指定 map 函数执行时的 this 对象。 12345let map = &#123;do: function(n) &#123;return n * 2;&#125;&#125;let arrayLike = [1, 2, 3];console.log(Array.from(arrayLike, function (n)&#123; return this.do(n);&#125;, map)); // [2, 4, 6] 2.Array.of12Array.of(1,2,3,4); //将零散元素转为数组console.log(Array.isArray(Array.of(1, 2, 3, 4))); //true 3. ES6 的合并数组1[...arr1, ...arr2, ...arr3] 4.新增数组方法1.find() 1234567//查找数组中符合条件的元素,若有多个符合条件的元素，则返回第一个元素。let arr = Array.of(1, 2, 3, 4);console.log(arr.find(item =&gt; item &gt; 2)); // 3 // 数组空位处理为 undefinedconsole.log([, 1].find(n =&gt; true)); // undefined 2.findIndex() 123456789查找数组中符合条件的元素索引，若有多个符合条件的元素，则返回第一个元素索引。let arr = Array.of(1, 2, 1, 3);// 参数1：回调函数// 参数2(可选)：指定回调函数中的 this 值console.log(arr.findIndex(item =&gt; item = 1)); // 0 // 数组空位处理为 undefinedconsole.log([, 1].findIndex(n =&gt; true)); //0 3.fill() 1234567将一定范围索引的数组元素内容填充为单个指定的值。let arr = Array.of(1, 2, 3, 4);// 参数1：用来填充的值// 参数2：被填充的起始索引// 参数3(可选)：被填充的结束索引，默认为数组末尾console.log(arr.fill(0,1,2)); // [1, 0, 3, 4] 4.copyWithin() 1234567891011将一定范围索引的数组元素修改为此数组另一指定范围索引的元素。// 参数1：被修改的起始索引// 参数2：被用来覆盖的数据的起始索引// 参数3(可选)：被用来覆盖的数据的结束索引，默认为数组末尾console.log([1, 2, 3, 4].copyWithin(0,2,4)); // [3, 4, 3, 4] // 参数1为负数表示倒数console.log([1, 2, 3, 4].copyWithin(-2, 0)); // [1, 2, 1, 2] console.log([1, 2, ,4].copyWithin(0, 2, 4)); // [, 4, , 4] 5.includes() 1234567891011121314includes()数组是否包含指定值。注意：与 Set 和 Map 的 has 方法区分；Set 的 has 方法用于查找值；Map 的 has 方法用于查找键名。// 参数1：包含的指定值[1, 2, 3].includes(1); // true // 参数2：可选，搜索的起始索引，默认为0[1, 2, 3].includes(1, 2); // false // NaN 的包含判断[1, NaN, 3].includes(NaN); // true 6.flat() 12345678910console.log([1 ,[2, 3]].flat()); // [1, 2, 3] // 指定转换的嵌套层数console.log([1, [2, [3, [4, 5]]]].flat(2)); // [1, 2, 3, [4, 5]] // 不管嵌套多少层console.log([1, [2, [3, [4, 5]]]].flat(Infinity)); // [1, 2, 3, 4, 5] // 自动跳过空位console.log([1, [2, , 3]].flat());&lt;p&gt; // [1, 2, 3] 7.flatMap() 12345先对数组中每个元素进行了的处理，再对数组执行 flat() 方法。// 参数1：遍历函数，该遍历函数可接受3个参数：当前元素、当前元素索引、原数组// 参数2：指定遍历函数中 this 的指向console.log([1, 2, 3].flatMap(n =&gt; [n * 2])); // [2, 4, 6] 7.SymbolES6新增数据类型 属于基本数据类型，Symbol不可以new Symbol声明的变量是唯一的，意义在于减少命名冲突； 1234567891011121314151617&#123; //Symbol的变量是唯一的，所以a1和a2永远不相等 let a1 = Symbol(); let a2 = Symbol(); console.log(a1 === a2); //Symbol.for(key) //在使用Symbol时 会生成一个全局注册表，其中的数据以键值对的形式存在；能根据key来拿到对应的value //若 a3 a4的key是相同的 那么a3 a4是相同的 let a3 = Symbol.for(&quot;a3&quot;); let a4 = Symbol.for(&quot;a3&quot;); console.log(a3 === a4); //true //问题 若改变a3的值 a4的值会改变吗？ //是值复制 还是指针 &#125; 8.ES6中的数据结构8.1MapES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 123456789const m = new Map();const o = &#123;p: 'Hello World'&#125;;m.set(o, 'content') m.get(o) // \"content\"m.has(o) // truem.delete(o) // truem.has(o) // false 8.2SetES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 12345set.add(ele) 向set集合中追加ele元素set.has(ele) 判断set集合中是否存在ele元素set.delete(ele) 从集合中删除ele元素set.clear() 清空set集合set.forEach( (ele) =&gt;&#123;&#125; ) 遍历集和 9. ES6 Reflect 与 Proxy9.1 Proxy一个 Proxy 对象由两个部分组成： target 、 handler 。在通过 Proxy 构造函数生成实例对象时，需要提供这两个参数。 target 即目标对象， handler 是一个对象，声明了代理 target 的指定行为。 123456789101112131415161718192021222324252627282930313233343536373839404142434445let target = &#123; name: 'Tom', age: 24&#125;let handler = &#123; get: function(target, key) &#123; console.log('getting '+key); return target[key]; // 不是target.key &#125;, set: function(target, key, value) &#123; console.log('setting '+key); target[key] = value; &#125;&#125;let proxy = new Proxy(target, handler)proxy.name // 实际执行 handler.getproxy.age = 25 // 实际执行 handler.set// getting name// setting age// 25 // target 可以为空对象let targetEpt = &#123;&#125;let proxyEpt = new Proxy(targetEpt, handler)// 调用 get 方法，此时目标对象为空，没有 name 属性proxyEpt.name // getting name// 调用 set 方法，向目标对象中添加了 name 属性proxyEpt.name = 'Tom'// setting name// \"Tom\"// 再次调用 get ，此时已经存在 name 属性proxyEpt.name// getting name// \"Tom\" // 通过构造函数新建实例时其实是对目标对象进行了浅拷贝，因此目标对象与代理对象会互相// 影响targetEpt)// &#123;name: \"Tom\"&#125; // handler 对象也可以为空，相当于不设置拦截操作，直接访问目标对象let targetEmpty = &#123;&#125;let proxyEmpty = new Proxy(targetEmpty,&#123;&#125;)proxyEmpty.name = \"Tom\"targetEmpty) // &#123;name: \"Tom\"&#125; 9.2 ReflectES6 中将 Object 的一些明显属于语言内部的方法移植到了 Reflect 对象上（当前某些方法会同时存在于 Object 和 Reflect 对象上），未来的新方法会只部署在 Reflect 对象上。 Reflect 对象对某些方法的返回结果进行了修改，使其更合理。 Reflect 对象使用函数的方式实现了 Object 的命令式操作。 Reflect.get 查找并返回 target 对象的 name 属性 1234567891011121314151617181920212223Reflect.get(target, name, receiver) let exam = &#123; name: \"Tom\", age: 24, get info()&#123; return this.name + this.age; &#125;&#125;Reflect.get(exam, 'name'); // \"Tom\" // 当 target 对象中存在 name 属性的 getter 方法， getter 方法的 this 会绑定 // receiverlet receiver = &#123; name: \"Jerry\", age: 20&#125;Reflect.get(exam, 'info', receiver); // Jerry20 // 当 name 为不存在于 target 对象的属性时，返回 undefinedReflect.get(exam, 'birth'); // undefined // 当 target 不是对象时，会报错Reflect.get(1, 'name'); // TypeError Reflect.set 将 target 的 name 属性设置为 value。返回值为 boolean ，true 表示修改成功，false 表示失败。当 target 为不存在的对象时，会报错。 123456789101112131415161718192021222324252627let exam = &#123; name: &quot;Tom&quot;, age: 24, set info(value)&#123; return this.age = value; &#125;&#125;exam.age; // 24Reflect.set(exam, &apos;age&apos;, 25); // trueexam.age; // 25 // value 为空时会将 name 属性清除Reflect.set(exam, &apos;age&apos;, ); // trueexam.age; // undefined // 当 target 对象中存在 name 属性 setter 方法时，setter 方法中的 this 会绑定 // receiver , 所以修改的实际上是 receiver 的属性,let receiver = &#123; age: 18&#125;Reflect.set(exam, &apos;info&apos;, 1, receiver); // truereceiver.age; // 1 let receiver1 = &#123; name: &apos;oppps&apos;&#125;Reflect.set(exam, &apos;info&apos;, 1, receiver1);receiver1.age; // 1 10.Promise和asymc10.1 Promise 状态Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。 Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。 1234567891011121314const p1 = new Promise(function(resolve,reject)&#123; resolve('success1'); resolve('success2');&#125;); const p2 = new Promise(function(resolve,reject)&#123; resolve('success3'); reject('reject');&#125;);p1.then(function(value)&#123; console.log(value); // success1&#125;);p2.then(function(value)&#123; console.log(value); // success3&#125;); 10.2 asyncasync 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。 和await结合使用 使Promise 看起来像同步 1234567891011121314function testAwait (x) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(x); &#125;, 2000); &#125;);&#125; async function helloAsync() &#123; var x = await testAwait (&quot;hello world&quot;); console.log(x); &#125;helloAsync ();// hello world","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"webpack","slug":"webpack","date":"2019-03-04T14:47:43.000Z","updated":"2020-01-27T17:03:50.389Z","comments":true,"path":"2019/03/04/webpack/","link":"","permalink":"http://yoursite.com/2019/03/04/webpack/","excerpt":"","text":"webpack1.概念以及作用本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具； 借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。 123456789# 在没有使用webpack之前：举个例子：index.html里面有一大堆的css和js文件，如a.js b.js c.js d.js等等（1）a.js要用到b.js里面的一个函数，则a.js要放在b.js后面（2）c.js要用到a.js里面的一个函数，则c.js要放在a.js后面（3）b.js又要用到d.js文件里面的函数，则b.js就要放在d.js后面如果有N多个js文件，需要手动处理他们的关系，即容易出错。# 使用webpack：webpack的理念就是一切皆模块化，把一堆的css文件和js文件放在一个总的入口文件，通过require引入，剩下的事情webpack会处理，包括所有模块的前后依赖关系，打包、压缩、合并成一个js文件，公共代码抽离成一个js文件、某些自己指定的js单独打包，模块可以是css/js/images/font等等。 2.webpack的使用2.1webpack的安装 运行npm i webpack@4.27.1 -g全局安装webpack，这样就能在全局使用webpack的命令 npm i webpack-cli@3.1.2 –g 全局安装webpack命令行工具 1配置环境变量 在项目根目录中运行npm i webpack@4.27.1 --save-dev安装到项目依赖中 123npm info webpack //查看npm上的webpack的信息webpack -v //查看当前安装的webpack的版本信息 ####2.2webpack的配置文件 在项目根目录中创建webpack.config.js 由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在webpack.config.js中配置这两个路径： 1234567891011// 导入处理路径的模块var path = require(&apos;path&apos;);// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理module.exports = &#123; entry: path.resolve(__dirname, &apos;src/main.js&apos;), // 项目入口文件 output: &#123; // 配置输出选项 path: path.resolve(__dirname, &apos;dist&apos;), // 配置输出的路径 filename: &apos;bundle.js&apos; // 配置输出的文件名 &#125;&#125; 使用命令打包构建 123456789# 使用webpack命令即可打包项目、webpack //没有指定webpack打包的配置文件，默认使用项目根路径下的webpack.config.js文件webpack --config webpack.config.js //指定webpack打包的时候使用的配置文件// 当我们在控制台，直接输入 webpack 命令执行的时候，webpack 做了以下几步：// 1. 首先webpack 发现我们并没有通过命令的形式给它指定入口和出口// 2. webpack 就会去项目的根目录中查找一个叫做 `webpack.config.js` 的配置文件// 3. 当找到配置文件后，webpack会去解析执行这个配置文件，当解析执行完配置文件后，就得到了 配置文件中，导出的配置对象// 4. 当 webpack拿到配置对象后，就拿到了配置对象中指定的入口和出口，然后进行打包构建； 2.3webpack实时打包构建 由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用webpack-dev-server来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 安装webpack-dev-server 123npm i webpack-dev-server@3.1.9 --save-devnpm i webpack@4.27.1 --save-dev //项目中安装webpacknpm i webpack-cli@3.1.2 安装完成之后，在命令行直接运行webpack-dev-server来进行打包，发现报错，因为它不是全局命令，不可以直接使用。 我们借助于package.json文件中的指令来进行运行webpack-dev-server命令，在scripts节点下新增&quot;dev&quot;: &quot;webpack-dev-server&quot;指令，发现可以进行实时打包 1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack-dev-server&quot;&#125; 运行项目 1npm run dev 但是dist目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中。把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 12Project is running at [1m [34mhttp://localhost:8084/ [39m[22mwebpack output is served from / 1此时我们可以通过http://localhost:8083/bundle.js 文件，因为webpack-dev-server默认是将bundle.js文件打包到根路径，所以要能做到修改main.js之后页面也要同步变化，需要修改页面的script标签： 1&lt;script type=&quot;text/javascript&quot; src=&quot;../bundle.js&quot;&gt;&lt;/script&gt; 指定启动参数： 1为了能在访问http://localhost:8080/的时候直接访问到index首页，可以使用--contentBase src指令来修改dev指令，指定启动的根目录： 123456789&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack-dev-server --open --port 3001 --contentBase src --hot&quot; &#125;, // --open含义：构建完成自动打开浏览器 // --port 3001 : 指定运行的端口 // --contentBase src : 指定运行的根目录是src，即认为src就是项目根目录 // --hot : 以补丁的方式修改文件，而不是修改全部文件 解决webpack4.0之后打包大小警告和热更新慢的问题 123456789101112131415161718https://cloud.tencent.com/developer/section/1477466#main.js const path = require(&apos;path&apos;)module.exports = &#123; //1.设置为开发模式，不然热更新会比较缓慢 mode:&quot;development&quot;, entry: path.resolve(__dirname, &apos;src/main.js&apos;), output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;, //2.打包文件大小警告和错误的问题 performance: &#123; hints:false &#125;&#125; 2.4webpack配置文件生成参数12345678910111213141516171819202122const path = require(&apos;path&apos;)// 启用热更新的 第2步const webpack = require(&apos;webpack&apos;)module.exports = &#123; entry: path.join(__dirname, &apos;./src/main.js&apos;), output: &#123; path: path.join(__dirname, &apos;./dist&apos;), filename: &apos;bundle.js&apos; &#125;, devServer: &#123; // 这是配置 dev-server 命令参数的第二种形式，相对来说，这种方式麻烦一些 // --open --port 3000 --contentBase src --hot open: true, // 自动打开浏览器 port: 3000, // 设置启动时候的运行端口 contentBase: &apos;src&apos;, // 指定托管的根目录 hot: true // 启用热更新 的 第1步 &#125;, plugins: [ // 配置插件的节点 new webpack.HotModuleReplacementPlugin(), // new 一个热更新的 模块对象， 这是 启用热更新的第 3 步 ],&#125; ####2.5html-webpack-plugin插件配置启动页面 123https://www.npmjs.com/package/html-webpack-pluginhtml-webpack-plugin插件可以**将指定页面配置生成到内存中**，并且可以**将打包的bundle.js配置到内存中生成的html页面中**，使用步骤如下： 运行npm i html-webpack-plugin@3.2.0 --save-dev安装到开发依赖 修改webpack.config.js配置文件如下： 123456789101112131415161718const path = require(&apos;path&apos;)// 导入自动生成HTMl文件的插件var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; entry: path.join(__dirname, &apos;./src/main.js&apos;), output: &#123; path: path.join(__dirname, &apos;./dist&apos;), filename: &apos;bundle.js&apos; &#125;, plugins: [ // 添加plugins节点配置插件 new htmlWebpackPlugin(&#123; template:path.resolve(__dirname, &apos;src/index.html&apos;),//模板路径 filename:&apos;index.html&apos;//自动生成的HTML文件的名称 &#125;) ],&#125; package.json中script`节点中的dev指令如下： 1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack-dev-server --open --port 3001 --contentBase src --hot&quot;&#125;, 将index.html中script标签注释掉，因为html-webpack-plugin插件会自动把bundle.js注入到index.html页面中！ 2.6使用webpack打包css文件一般情况下，我们并不推荐在html页面中直接引入其他css文件，这样会导致过多的请求。对应的，我们可以使用webpack来构建。使用步骤如下： 运行 npm i style-loader css-loader --save-dev main.js中引入index.css 1import \"./css/index.css\" 修改webpack.config.js这个配置文件： 1234567// 用来配置第三方loader模块的module: &#123; rules: [ // 匹配以.css结尾的文件 &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;//处理css文件的规则 ]&#125; webpack 处理第三方文件类型的过程 12341. 发现这个要处理的文件不是JS文件，然后就去配置文件中，查找有没有对应的第三方 loader 规则2. 如果能找到对应的规则， 就会调用对应的loader处理这种文件类型；3. 在调用loader的时候，use中相关loader模块的调用顺序是从后向前调用的；4. 当最后的一个loader调用完毕，会把处理的结果直接交给 webpack 进行打包合并，最终输出到 bundle.js 中去 2.7使用webpack打包less文件 运行npm i less-loader less，需要同时安装less-loader和less main.js中引入index.less 1import \"./css/index.less\" 修改webpack.config.js这个配置文件： 123456module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125; ]&#125; 2.8使用webpack打包sass文件 运行npm i sass-loader@7.3.1 node-sass --save-dev main.js中引入index.scss 12//注意：文件名是scss结尾import \"./css/index.scss\" 在webpack.config.js中添加处理scss文件的loader模块： 1234567module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125; ]&#125; ####2.9使用webpack处理css中的路径 运行npm i url-loader file-loader --save-dev 在webpack.config.js中添加处理url路径的loader模块： 12345678module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;, &#123; test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: 'url-loader' &#125; ] &#125; index.css 12345div&#123; width: 600px; height: 450px; background-image: url(../images/1.jpg);&#125; 1注意点：url-loader默认情况下会将图片转换为base64编码的图片，好处是可以减少图片的二次请求。但是这种方式一般情况下适用于小图，如果是大图，我们可以像下面这样去使用： 1234567891011121314151617181920212223module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;, &#123; test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192, name:'[hash:8]-[name].[ext]' &#125; &#125; ] &#125; ]&#125;//limit ： 当图片大小小于等于指定的值时会进行base64编码//name =[name].[ext]： 不给图片重命名，还是使用原图名。如果没有这个属性，则默认会使用hashcode的方式来给图片重命名。//给图片重命名的好处是：如果在多个不同的目录下有两张同名的图片(内容不同)，不会产生冲突。(默认情况下webpack会将图片也打包到根路径下)//如果既想多个文件夹下的同名的图片被打包后不冲突，又想保留原来的图片名字，可以这样使用：name=[hash:8]-[name].[ext] ， [hash:8]表示保留8位hash值，然后再去追加原来的[name] 2.10使用webpack处理字体图标1234567891011121314151617181920212223242526module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125;, &#123; test: /\\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125;, &#123; test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: [ &#123; loader: &apos;url-loader&apos;, options: &#123; limit: 8192, name:&apos;[hash:8]-[name].[ext]&apos; &#125; &#125; ] &#125;, &#123; test: /\\.(ttf|eot|svg|woff|woff2)$/, use: [ &#123; loader:&apos;url-loader&apos; &#125; ] &#125;, // 处理 字体文件的 loader ]&#125; 2.11webpack中babel的配置1在 webpack 中，默认只能处理一部分 ES6 的新语法；这时候就需要借助于第三方的 loader，来帮助webpack 处理这些高级的语法，当第三方loader可以把高级语法转为低级的语法，然后再把结果交给 webpack 去打包到 bundle.js 中 运行npm i babel-core@6.26.3 babel-loader@7.1.5 babel-plugin-transform-runtime --save-dev安装babel的相关loader包 (babel的转换工具) 运行npm i babel-preset-env babel-preset-stage-0 --save-dev安装babel转换的语法 (es6的语法和es5的语法的对应关系) 在webpack.config.js中添加相关loader模块，其中需要注意的是，一定要把node_modules文件夹添加到排除项： 1234567891011module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;, &#123; test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: 'url-loader?limit=1024&amp;name=[hash:8]-[name].[ext]' &#125;, &#123; test: /\\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader' &#125;, // 处理 字体文件的 loader //配置 babel 的 loader规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉 &#123; test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/ &#125;, ]&#125; 在项目根目录中添加.babelrc文件，并修改这个配置文件如下(这个文件必须符合json的语法，不能有注释。字符串必须使用双引号)： 1234&#123; \"presets\": [\"env\", \"stage-0\"], \"plugins\": [\"transform-runtime\"]&#125; 注意：之前用的比较多的语法插件babel-preset-es2015更新为babel-preset-env，它包含了所有的ES相关的语法； 1.3.11 所有配置总结12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# 1.安装npm i webpack@4.20.1 --save-dev //安装webpacknpm init -y //项目初始化npm i webpack-dev-server@3.1.9 --save-dev //实时打包构建npm i webpack-cli@3.1.2 npm i html-webpack-plugin@3.2.0 --save-dev //配置内存页面npm i style-loader css-loader --save-dev //css加载器npm i less-loader less //less加载器npm i sass-loader@7.3.1 node-sass --save-dev //sass加载器npm i url-loader file-loader --save-dev //url加载器npm i babel-core@6.26.3 babel-loader@7.1.5 babel-plugin-transform-runtime --save-dev //babel转换工具npm i babel-preset-env babel-preset-stage-0 --save-dev //babel转换的语法#2.webpack.config.jsconst path = require(&apos;path&apos;)// 导入自动生成HTMl文件的插件var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; entry: path.join(__dirname, &apos;./src/main.js&apos;), output: &#123; path: path.join(__dirname, &apos;./dist&apos;), filename: &apos;bundle.js&apos; &#125;, plugins: [ // 添加plugins节点配置插件 new htmlWebpackPlugin(&#123; template:path.resolve(__dirname, &apos;src/index.html&apos;),//模板路径 filename:&apos;index.html&apos;//自动生成的HTML文件的名称 &#125;) ], module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125;, &#123; test: /\\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125;, &#123; test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: &apos;url-loader?limit=1024&amp;name=[hash:8]-[name].[ext]&apos; &#125;, &#123; test: /\\.(ttf|eot|svg|woff|woff2)$/, use: &apos;url-loader&apos; &#125;, // 处理 字体文件的 loader //配置 babel 的 loader规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉 &#123; test: /\\.js$/, use: &apos;babel-loader&apos;, exclude: /node_modules/ &#125;, ] &#125;&#125;#3.项目入口文件import &quot;./css/index.css&quot;console.log(&quot;ok&quot;);class Person&#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; showInfo()&#123; console.log(this.name); &#125;&#125;var p = new Person(&quot;xiaoming&quot;,18);console.log(p.name);#4.package.json &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack-dev-server --open --port 3000 --contentBase src --hot&quot; &#125;#5.项目根目录 .babelrc&#123; &quot;presets&quot;: [&quot;env&quot;, &quot;stage-0&quot;], &quot;plugins&quot;: [&quot;transform-runtime&quot;]&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"AJAX","slug":"AJAX","date":"2019-02-22T12:54:10.000Z","updated":"2020-01-27T12:25:28.267Z","comments":true,"path":"2019/02/22/AJAX/","link":"","permalink":"http://yoursite.com/2019/02/22/AJAX/","excerpt":"","text":"AJAX1.什么是AJAX？ Ajax（Asynchronous JavaScript and XML的缩写）是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。 AJAX的好处：可以通过js代码发送get或者post的请求去从后台获取到相应数据，并只对页面中的部分标签进行刷新渲染，而不需要刷新整个页面，节约了带宽，优化了性能 2.创建AJAX对象12//兼容性写法 ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);是为了兼容IE5 IE6var ajax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); 3.AJAX的方法12345678910111213141516171819202122//设置请求方式ajax.open(&quot;post&quot;,&quot;url&quot;,true); //第三个参数如果为true，则是异步，反之同步//设置请求头格式（post请求时一定要加请求头，这是因为在传输过程中会出现转码的情况，可能导致乱码的情况）xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);//发送请求:get请求参数放在url后面，post请求参数send()方法里面ajax.send(&quot;数据&quot;); //监听ajax状态，当ajax的状态发生改变的时候执行ajax.onreadystatechange = function()&#123; //响应完成，浏览器已经可以获取到服务器响应结果了 if(this.readyState == 4)&#123; //这是AJAX的状态码 区别与http的状态码 状态码还有 1 2 3 其中3是数据正在传输时的状态，他不保证数据的完整性 //http响应的状态码 if(this.state == 200)&#123; //还有302 301 404... //获取响应内容 console.log(this.responseText); //用ajax.responseText获取服务器返回的数据 //responseText 获得字符串形式的响应数据。 //responseXML 获得XML 形式的响应数据 &#125; &#125;&#125; 4.数据渲染的两种方式4.1数据在服务器中渲染完毕，返回给客户端一个完整页面 浏览器发送请求至服务器 服务器接收到请求的信息，根据请求找到相应的信息（如JSON数据），在读取相应的页面文件，并渲染成一个完整的页面，将这个页面返回给客户端 客户端接收到此页面，并显示 (此方式要在服务器端安装art-template express-art-template等第三方模板） 4.2服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示 客户端发送数据请求给服务器 服务器拿到请求，找到相应的数据（如JSON），直接将此数据返回给客户端 客户端拿到数据后，在客户端进行渲染，并显示。（此方式要用到前端渲染插件template-web.js） 5.XMLXML extensible Markup Language 扩展的标记语言，XML的标签可以自定义HTML Hyper Text Markup Lanaguage HTML的标签是由W3C规范的，大概一共200多个 XML用途：1、 定义数据结构2、 作为配置文件出现 XML组成：1、 XML文档声明2、 XML标签3、 XML属性4、 XML注释 XML文档注意点：1）xml的标签必须成对出现如，为成对出现时的标签也必须要是自关闭标签 如2）xml标签名称区分大小写。3）xml标签一定要正确配对。4）xml标签名中间不能使用空格5）xml标签名不能以数字开头6）注意： 在一个xml文档中，有且仅有一个根标签 12345678910111213141516//使用xml设计一个通讯录&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;contact&gt; &lt;person id=&quot;100&quot;&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;phone&gt;12345678&lt;/phone&gt; &lt;email&gt;12453@qq.com&lt;/email&gt; &lt;/person&gt; &lt;person id=&quot;101&quot;&gt; &lt;name&gt;李四&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;phone&gt;22345678&lt;/phone&gt; &lt;email&gt;34453@qq.com&lt;/email&gt; &lt;/person&gt;&lt;/contact&gt; xml的使用 1234567891011121314151617181920212223242526//服务器代码//返回XML格式的数据app.get(&quot;/getXML&quot;,(req,res)=&gt;&#123; //设置响应头，指定返回的数据是XML res.header(&quot;content-type&quot;,&quot;application/xml&quot;); var xml = &apos;&lt;?xml version=&quot;1.1&quot; encoding=&quot;utf-8&quot;?&gt;&apos;;//XML文档声明 xml += &apos;&lt;person&gt;&apos;; xml += &apos;&lt;name&gt;羊杨&lt;/name&gt;&apos;; xml += &apos;&lt;age&gt;16&lt;/age&gt;&apos;; xml += &apos;&lt;gender&gt;男&lt;/gender&gt;&apos;; xml += &apos;&lt;/person&gt;&apos;; res.send(xml);&#125;)//客户端代码ajax.onreadystatechange = function()&#123; if(this.readyState == 4)&#123; //获取响应的XML数据 var xml = this.responseXML.documentElement;//ajax.responseXML.documentElement拿到文档数据 var age = xml.querySelector(&quot;age&quot;);//用标签选择器获取到age数据 但此时age是&lt;age&gt;16&lt;/age&gt; console.log(age.innerHTML);//此处用innerText拿不到数据 console.log(xml.children);//xml的语法几乎与html语法类似 &#125;&#125; JSON json数据的使用 12345678910111213141516171819202122232425262728293031//服务器代码//返回JSON格式的数据app.get(&quot;/getJSON&quot;,(req,res)=&gt;&#123; //数组 let arr = [ &#123; name:&quot;zhangsan&quot;, age:&quot;18&quot;, gender:&quot;男&quot;, id:001 &#125;, &#123; name:&quot;lisi&quot;, age:&quot;28&quot;, gender:&quot;男&quot;, id:002 &#125; ] //将数组转换为JSON数据 res.status(200).send(JSON.stringify(arr));&#125;)//客户端代码ajax.onreadystatechange = function()&#123; if(this.readyState == 4)&#123; console.log(this.responseText); //这是JSON字符串，在使用的时候往往需要转换为对象 var students = JSON.parse(this.responseText); var html = template(&quot;generatorTable&quot;,&#123;students:students&#125;); container.innerHTML = html; &#125;&#125; 6.jQuery中的AJAX推荐使用 方便的一批 6.1使用客户端代码 123456789101112131415161718192021222324252627282930$.ajax(&#123; //请求方式 type:&quot;get&quot;, //post //请求路径 url:&quot;&quot;, //如http://localhost:3000/index //请求参数，无论是get还是post请求，请求参数都可以写在这里 //注意：请求为get时 在服务器得到请求参数时 仍然使用res.query //这里的data数据必须为字符串 若要传入json数据 需要将json数据转换为字符串如 JSON.stringify(&#123;[&#123;&#125;,&#123;&#125;]&#125;) data:&#123;name:&quot;zhangsan&quot;&#125;, //规定所要请求的数据的类型 dataType: &apos;&apos;, //在jQuery中如果请求已经是post，默认的contentType就是application/x-www-form-urlencoded,不需要单独再去写 //contentType: &quot;application/x-www-form-urlencoded&quot;, //请求成功的回调 success:function(res)&#123; console.log(res);//res是请求的到的数据 &#125; //请求出错的回调 推荐写 error:function(err)&#123; console.log(err); &#125; //无论请求的成功与否，只要请求结束都会执行此函数 complete:function(xhr)&#123; &#125;&#125;) 服务器代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152let express = require(&quot;express&quot;);let app = express();const bodyParser = require(&apos;body-parser&apos;);app.use(bodyParser.urlencoded(&#123;extended:false&#125;));//注意 当客户端中的data:JSON.stringify([&#123;name:&apos;zhangsan&apos;&#125;,&#123;name:&apos;lisi&apos;&#125;])时，服务器需要此配置//以解析body中的json数据app.use(bodyParser.json(&#123;extended:false&#125;));app.use(express.static(&quot;./views&quot;));//当ajax的url为&apos;/getJSON&apos;时 此接口响应 返回JSON格式的数据//此时ajax的dataType要设置为&apos;json&apos;app.get(&quot;/getJSON&quot;,(req,res)=&gt;&#123; //数组 let arr = [ &#123; name:&quot;zhangsan&quot;, age:&quot;18&quot;, gender:&quot;男&quot;, id:001 &#125;, &#123; name:&quot;lisi&quot;, age:&quot;28&quot;, gender:&quot;男&quot;, id:002 &#125; ] arr.forEach((user,idx)=&#123; if(user.name == req.body.name)&#123; res.status(200).send(JSON.stringify(user)); &#125; &#125;)&#125;)//当ajax的url为&apos;/getXML&apos;时 此接口响应 返回XML格式的数据//此时ajax的dataType要设置为&apos;xml&apos;app.get(&quot;/getXML&quot;,(req,res)=&gt;&#123; //设置响应头，指定返回的数据是XML res.header(&quot;content-type&quot;,&quot;application/xml&quot;); var xml = &apos;&lt;?xml version=&quot;1.1&quot; encoding=&quot;utf-8&quot;?&gt;&apos;; xml += &apos;&lt;person&gt;&apos;; xml += &apos;&lt;name&gt;zhangsan&lt;/name&gt;&apos;; xml += &apos;&lt;age&gt;16&lt;/age&gt;&apos;; xml += &apos;&lt;gender&gt;男&lt;/gender&gt;&apos;; xml += &apos;&lt;/person&gt;&apos;; res.send(xml);&#125;) 发送也接受html或script数据 服务器代码 123456789101112131415161718192021const express = require(&apos;express&apos;);const app = express();const bodyParser = require(&apos;body-parser&apos;);app.use(bodyParser.urlencoded(&#123;extended:false&#125;));app.use(express.static(&apos;views&apos;));app.get(&apos;/getScript&apos;,(req,res)=&gt;&#123; res.header(&apos;content-type&apos;,&apos;application/javascript;charset=utf-8&apos;); res.send(&apos;alert(123);&apos;);&#125;);app.get(&apos;/getHtml&apos;,(req,res)=&gt;&#123; res.header(&apos;content-type&apos;,&apos;text/html;charset=utf-8&apos;) res.send(&apos;&lt;h1&gt;HTML&lt;/h1&gt;&apos;);&#125;);app.listen(3000,()=&gt;&#123; console.log(&apos;running...&apos;);&#125;); 客户端代码 1234567891011121314151617181920212223242526272829303132$(&apos;#btn1&apos;).click(function()&#123; $.ajax(&#123; type: &apos;get&apos;, url: &apos;/getHtml&apos;, data: &apos;&apos;, dataType: &apos;html&apos;, success:function(res)&#123; //因为dataType为html jQuery。AJAX会自动设置响应头为text/html 则 可以直接追加res到页面中 $(&apos;#info&apos;).append(res); &#125;, error:function(err)&#123; console.log(err); &#125; &#125;);&#125;);$(&apos;#btn2&apos;).click(function()&#123; $.ajax(&#123; type: &apos;get&apos;, url: &apos;/getScript&apos;, data: &apos;&apos;, dataType: &apos;script&apos;, success:function(res)&#123; //之所以alert()能执行 是因为将script代码打印到控制台 控制台会执行script代码 //也可以用script标签的对res进行封装 追加到页面中 也可以执行 console.log(res); &#125;, error:function(err)&#123; console.log(err); &#125; &#125;);&#125;); 6.2dataTypedataType取值有xml、html、json、jsonp、script或者text 当dataType取值为json，会自动将服务器返回的文本数据通过JSON.parse()转换成对象。服务器应该设置这个响应头：res.header(“content-type”, “application/json;charset=utf-8”); 当dataType为xml或者text的时候，返回的数据不会另做处理服务器应该设置这个响应头：res.header(“content-type”,”application/xml”);res.header(“content-type”,”text/plain;charset=utf-8”); 当dataType为html的时候，返回的内容中的script标签会在网页内容被拼接到页面的时候执行服务器应该设置这个响应头：res.header(“content-type”,”text/html;charset=utf-8”); 当dataType为script的时候，会将服务器返回的结果当成js代码执行并且将js代码的文本内容返回给客户端服务器应该设置这个响应头：res.header(“content-type”,”application/javascript”); 当dataType为jsonp的时候，会向服务器发送一个jsonp请求服务器应该设置这个响应头：res.header(“content-type”,”application/javascript”); 6.3nprogress的使用（全局事件处理）1、在html文件中引入nprogress.js 和 nprogress.css 2 12345$(document).ajaxStart(function()&#123;//请求数据开始 NProgress.start();//数据加载动画&#125;).ajaxStop(function()&#123;//请求数据结束 NProgress.done();//数据加载完毕动画&#125;); 7.跨域请求同源策略是浏览器的一种安全策略，所谓同源是指 域名，协议，端口完全相同 ，只有同源的地址才可以相互通过AJAX的方式请求。 同源或者不同源说的是两个地址之间的关系，不同源地址之间请求我们称之为跨域请求 例如 12http://localhost:8000 是不可以通过ajax访问 http://locally.uieee.com/categories的因为两者不满足同源的条件 7.1如何进行跨域请求 CORS JSONP 代理服务器 修改document.domain Iframe Location.hash Window.postMessage() Websocket CORS只需要改动服务器，不用改动客户端代码，客户端可以直接使用$.ajax() Cross Origin Resource Share，跨域资源共享。这种方案无需客户端作出任何变化（客户端不用改代码），只是在被请求的服务端响应的时候添加一个Access- Control-Allow-Origin 的响应头，表示这个资源是否允许指定域请求。 12345678//直接在服务器配置如下,客户端代码和以前一样写app.all(&apos;*&apos;, function(req, res, next) &#123; res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-type&apos;); res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS,PATCH&quot;); res.header(&apos;Access-Control-Max-Age&apos;,6000);//预请求缓存10分钟 next(); &#125;); JSONPJSON with Padding 实质上是通过script的src属性进行数据请求。本质上不是AJAX请求 需要服务器和客户端配合 12345678910111213141516171819//此时客户端的地址为http://localhost:3000实现要点//客户端代码var script = document.createElement(&apos;script&apos;);script.src = &apos;http://localhost:9999/testJSONP&apos;;//向http://localhost:9999发送跨域请求document.body.appendChild(script)//服务器代码app.get(&quot;/testJSONP&quot;,(req,res)=&gt;&#123; //设置响应头 服务器给客户端发送了一个js代码块 res.header(&quot;content-type&quot;,&quot;application/javascript&quot;); let data = JSON.stringify(&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;) ; //服务器发送 `foo(&apos;&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;&apos;)` 这个字符串给客户端 res.send(`foo($&#123;data&#125;)`);&#125;)//如果服务器给客户端返回的js代码块中有函数调用，必须提前在客户端中声明要调用的那个函数function foo(data)&#123; console.log(data);&#125; jQuery代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//客户端代码$.ajax(&#123; type:&quot;get&quot;, url:&quot;http://localhost:9999/testJSONP&quot;, data:&apos;&apos;, dataType: &apos;jsonp&apos;, success:function(res)&#123; $(&apos;body&apos;).append(res); &#125; error:function(err)&#123; console.log(err); &#125; complete:function(xhr)&#123; &#125;&#125;);function foo(data)&#123; console.log(data);&#125;//服务器http://localhost:3000代码const express = require(&apos;express&apos;);const app = express();const bodyParser = require(&apos;body-parser&apos;);app.use(bodyParser.urlencoded(&#123;extended:false&#125;));app.use(express.static(&apos;views&apos;));app.listen(3000,()=&gt;&#123; console.log(&apos;running...&apos;);&#125;);//服务器http://localhost:8888代码const express = require(&apos;express&apos;);const app = express();const bodyParser = require(&apos;body-parser&apos;);app.use(bodyParser.urlencoded(&#123;extended:false&#125;));app.get(&apos;/getJsonp&apos;,(req,res)=&gt;&#123; res.send(&apos;foo(&quot;你拿到了http://localhost:8888的jsonp&quot;);&apos;);&#125;);app.listen(8888,()=&gt;&#123; console.log(&apos;running...&apos;);&#125;); 8.结束语AJAX是通过XMLHttpRequest或者封装后的框架进行网络请求，由于这种方式的配置和调用方式非常混乱，已被Fetch取代","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://yoursite.com/tags/AJAX/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"JS基础知识","slug":"js基本知识","date":"2019-02-05T13:25:25.000Z","updated":"2020-01-26T13:42:33.946Z","comments":true,"path":"2019/02/05/js基本知识/","link":"","permalink":"http://yoursite.com/2019/02/05/js基本知识/","excerpt":"","text":"JS基础知识1.JavaScript 是什么？ JavaScript 是一种轻量级的编程语言。 JavaScript 是可插入 HTML 页面的编程代码。 JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。 2.js的基本数据类型 Number String null undefined Boolean 复杂的数据类型：Array Function Object 3.typeof的类型12345678910typeof &quot;John&quot; // 返回 string typeof 3.14 // 返回 numbertypeof NaN // 返回 numbertypeof false // 返回 booleantypeof [1,2,3,4] // 返回 objecttypeof &#123;name:&apos;John&apos;, age:34&#125; // 返回 objecttypeof new Date() // 返回 objecttypeof function () &#123;&#125; // 返回 functiontypeof myCar // 返回 undefined (如果 myCar 没有声明)typeof null // 返回 object typeof只能区分值类型，对引用类型无能为力，只能区分函数functionNaN表示特殊的非数字值，null是空指针，并没有指向任何一个地址typeof能区分的五种基本类型：string、boolean、number、undefined、symbol和函数function 4.判断一个变量是否为数组 instanceof 判断 12var arr = [1,2,3,4];console.log(arr instanceof Array)//true; 原型链方法 123var arr = [1,23,4];console.log(arr.__proto__.constructor==Array);//trueconsole.log(arr.constructor==Array)//true 这两段代码是一样的 Object.prototype.toString 的用法 1234function isArray(o)&#123;return Object.prototype.toString.call(o)==&apos;[object Array]&apos;;&#125;console.log(isArray(ary)); Array.isArray() 12Array.isArray([1, 2, 3]); // true 5.use strict严格模式&quot;use strict&quot; 是 ES5 特性，它使我们的代码在函数或整个脚本中处于严格模式。严格模式帮助我们在代码的早期避免 bug，并为其添加限制。 严格模式的一些限制： 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不能在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 设立”严格模式”的目的，主要有以下几个： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 6.JS数组方法12345678910111213Array.concat( ) 连接数组Array.join( ) 将数组元素连接起来以构建一个字符串Array.length 数组的大小Array.pop( ) 删除并返回数组的最后一个元素Array.push( ) 给数组添加元素Array.reverse( ) 颠倒数组中元素的顺序Array.shift( ) 将元素移出数组Array.slice( ) 返回数组的一部分Array.sort( ) 对数组元素进行排序Array.splice( ) 插入、删除或替换数组的元素Array.toLocaleString( ) 把数组转换成局部字符串Array.toString( ) 将数组转换成一个字符串Array.unshift( ) 在数组头部插入一个元素","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"","slug":"Tomcat安装和使用","date":"2019-01-23T12:16:30.000Z","updated":"2020-01-26T08:39:32.794Z","comments":true,"path":"2019/01/23/Tomcat安装和使用/","link":"","permalink":"http://yoursite.com/2019/01/23/Tomcat安装和使用/","excerpt":"","text":"Tomcat安装和使用安装JDK步骤及配置JDK环境变量步骤省略。 一下载安装。1.官网下载 2.文件减压 二使用Tomcat 先解压下载的压缩包、然后在bin目录下找到startup.bat文件、并用鼠标双击此文件 然后在浏览器中输入http://localhost:8080回车后，显示如下界面：此时就说明Tomcat服务启动正常了。 ​ 将打包后的文件放入webapps目录下在此启动Tomcat访问8080端口即可。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"CSS3动画","slug":"CSS3动画","date":"2019-01-03T12:55:30.000Z","updated":"2020-01-24T12:18:00.259Z","comments":true,"path":"2019/01/03/CSS3动画/","link":"","permalink":"http://yoursite.com/2019/01/03/CSS3动画/","excerpt":"","text":"CSS3动画通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。 ###1.CSS3的@keyframes 规则 @keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。 @keyframes 中创建动画时，请把它捆绑到某个选择器，否则不会产生动画效果。通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器： 规定动画的名称 规定动画的时长 2.CSS3 中动画的使用动画是使元素从一种样式逐渐变化为另一种样式的效果。 您可以改变任意多的样式任意多的次数。 请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。 0% 是动画的开始，100% 是动画的完成。 为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。 动画是使元素从一种样式逐渐变化为另一种样式的效果。 您可以改变任意多的样式任意多的次数。 请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。 0% 是动画的开始，100% 是动画的完成。 为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;width:100px;height:100px;background:red;animation:myfirst 5s;-moz-animation:myfirst 5s; /* Firefox */-webkit-animation:myfirst 5s; /* Safari and Chrome */-o-animation:myfirst 5s; /* Opera */&#125;@keyframes myfirst&#123;from &#123;background:red;&#125;to &#123;background:yellow;&#125;&#125;@-moz-keyframes myfirst /* Firefox */&#123;from &#123;background:red;&#125;to &#123;background:yellow;&#125;&#125;@-webkit-keyframes myfirst /* Safari and Chrome */&#123;from &#123;background:red;&#125;to &#123;background:yellow;&#125;&#125;@-o-keyframes myfirst /* Opera */&#123;from &#123;background:red;&#125;to &#123;background:yellow;&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;本例在 Internet Explorer 中无效。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 3.CSS3 动画属性 animation (所有动画属性的简写属性，除了 animation-play-state 属性) 12animation: name duration timing-function delay iteration-count direction;animation: demo 3s liner 0.2 iteration-count direction; animation-name(为 @keyframes 动画指定名称) 1animation-name: keyframename|none; animation-duration(定义动画完成一个周期需要多少秒或毫秒) 1animation-duration: time; animation-timing-function(指定动画将如何完成一个周期） 12345678animation-timing-function: value;linear 动画从头到尾的速度是相同的。ease 默认。动画以低速开始，然后加快，在结束前变慢。ease-in 动画以低速开始。ease-out 动画以低速结束。 ease-in-out 动画以低速开始和结束。 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。 animation-delay (定义动画什么时候开始) 1animation-delay: time; animation-iteration-count(定义动画应该播放多少次) 1234animation-iteration-count: value;n 一个数字，定义应该播放多少次动画infinite 指定动画应该播放无限次（永远） animation-direction (定义是否循环交替反向播放动画) 12345678animation-direction: normal|reverse|alternate|alternate-reverse|initial|inherit;normal 默认值。动画按正常播放。 reverse 动画反向播放。 alternate 动画在奇数次（1、3、5...）正向播放，在偶数次（2、4、6...）反向播放。alternate-reverse 动画在奇数次（1、3、5...）反向播放，在偶数次（2、4、6...）正向播放。initial 设置该属性为它的默认值。 inherit 从父元素继承该属性。 animation–play-state(指定动画是否正在运行或已暂停) 1234animation-play-state: paused|running;paused 指定暂停动画 running 指定正在运行的动画 ​","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"},{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/动画/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"前端兼容性问题小结","slug":"前端兼容性问题小结","date":"2018-12-21T12:45:30.000Z","updated":"2020-01-24T12:18:06.408Z","comments":true,"path":"2018/12/21/前端兼容性问题小结/","link":"","permalink":"http://yoursite.com/2018/12/21/前端兼容性问题小结/","excerpt":"","text":"前端兼容性问题小结1.不同浏览器的标签默认的外补丁和内补丁不同问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。 碰到频率:100% 解决方案：CSS里 *{margin:0;padding:0;}，或使用第三方css文件重置。 备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。 2.图片默认有间距问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。 碰到几率：20% 解决方案：使用float属性为img布局 备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（我的一个学生使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以我禁止他们使用） ###3.IE9一下浏览器不能使用opacity 解决方案： 123opacity: 0.5;filter:alpha(opacity = 50);filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50); 4.IE6 背景闪烁的问题问题：链接、按钮用 CSSsprites 作为背景，在 ie6 下会有背景图闪烁的现象。原因是 IE6 没有将背景图缓存，每次触发 hover 的时候都会重新加载 解决：可以用 JavaScript 设置 ie6 缓存这些图片： 1document.execCommand(&quot;BackgroundImageCache&quot;, false, true); 5.键盘事件 keyCode 兼容性写法1234567891011var inp = document.getElementById(&apos;inp&apos;)var result = document.getElementById(&apos;result&apos;)function getKeyCode(e) &#123; e = e ? e : (window.event ? window.event : &quot;&quot;) return e.keyCode ? e.keyCode : e.which&#125;inp.onkeypress = function(e) &#123; result.innerHTML = getKeyCode(e)&#125; 6.DOM 事件处理程序的兼容写法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var eventshiv = &#123; // event兼容 getEvent: function(event) &#123; return event ? event : window.event; &#125;,// &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;兼容getType: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(event) &#123; &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; event.type;&#125;,// target兼容getTarget: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(event) &#123; &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; event.target ? event.target : event.srcelem;&#125;,// 添加事件句柄addHandler: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(elem, &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener) &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (elem.addEventListener) &#123; elem.addEventListener(&lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;); &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (elem.attachEvent) &#123; elem.attachEvent(&lt;span class=&quot;hljs-string&quot;&gt;&apos;on&apos;&lt;/span&gt; + &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener); &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &#123; // 在这里由于.与&lt;span class=&quot;hljs-string&quot;&gt;&apos;on&apos;&lt;/span&gt;字符串不能链接，只能用 [] elem[&lt;span class=&quot;hljs-string&quot;&gt;&apos;on&apos;&lt;/span&gt; + &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;] = listener; &#125;&#125;,// 移除事件句柄removeHandler: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(elem, &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener) &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (elem.removeEventListener) &#123; elem.removeEventListener(&lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;); &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (elem.detachEvent) &#123; elem.detachEvent(&lt;span class=&quot;hljs-string&quot;&gt;&apos;on&apos;&lt;/span&gt; + &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener); &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &#123; elem[&lt;span class=&quot;hljs-string&quot;&gt;&apos;on&apos;&lt;/span&gt; + &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;] = null; &#125;&#125;,// 添加事件代理addAgent: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (elem, &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, agent, listener) &#123; elem.addEventListener(&lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (e) &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (e.target.matches(agent)) &#123; listener.call(e.target, e); // this 指向 e.target &#125; &#125;);&#125;,// 取消默认行为preventDefault: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(event) &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (event.preventDefault) &#123; event.preventDefault(); &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &#123; event.returnValue = &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;; &#125;&#125;,// 阻止事件冒泡stopPropagation: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(event) &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (event.stopPropagation) &#123; event.stopPropagation(); &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &#123; event.cancelBubble = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;; &#125;&#125;;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"兼容性","slug":"兼容性","permalink":"http://yoursite.com/tags/兼容性/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"css知识点小结(2)","slug":"css知识点小结-2","date":"2018-12-13T12:42:33.000Z","updated":"2020-01-23T06:01:48.860Z","comments":true,"path":"2018/12/13/css知识点小结-2/","link":"","permalink":"http://yoursite.com/2018/12/13/css知识点小结-2/","excerpt":"","text":"css知识点小结(2)1.文本超出部分显示省略号单行 123overflow:hidden；text-overflow:ellipsis;white-space:nowarp; 多行 1234display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3; // 最多显示几行overflow: hidden; ###2.优雅降级和渐进增强 优雅降级： Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。 渐进增强： 从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验； 3.transition和animation的区别 transition是过渡动画，animation是帧动画。 transition只能从一种状态过渡到另外一种状态，animation可以定制复杂动画(多个帧)，可以定义动画的区间等。 transition必须通过一些行为才能触发（js或者伪类来触发），animation的话直接就可以触发。 4.margin-left:calc(-100%-100px) 代码中calc（）作用 通过计算来确定CSS属性值。 calc是英文单词calculate(计算)的缩写，是css3的一个新增的功能，你可以使用calc()给元素的border、margin、pading、font-size和width等属性设置动态值。calc()可以使用数学运算中的简单加（+）、减（-）、乘（）和除（/）来解决问题，而且还可以根据单位如px,em,rem和百分比来转化计算 5. Sass、Less的区别？CSS 预处理，他们是动态的样式语言。他们规定了一种特殊的语法并且内置了编译器，可以将less/sass写的代码通过编译器编译成 CSS。 1234Less和Sass的区别：1.变量符不一样，less 是@，而 Sass 是$;2.Sass支持条件语句，可以使用 if&#123;&#125;else&#123;&#125;,for&#123;&#125;循环等等。而 Less 不支持;3.Sass是基于Ruby，需要在服务端处理的；而Less是在客户端处理，需要引入less.js","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/总结/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"css知识点小结(1)","slug":"css知识点小结-1","date":"2018-12-02T11:30:30.000Z","updated":"2020-01-24T12:17:50.641Z","comments":true,"path":"2018/12/02/css知识点小结-1/","link":"","permalink":"http://yoursite.com/2018/12/02/css知识点小结-1/","excerpt":"","text":"css知识点小结(1)1.css选择器优先级选择器的特殊性值表述为4个部分，用0,0,0,0表示，权重计算规则如下： 行间样式 1,0,0,0 ID选择器 0,1,0,0 类选择器、属性选择器或伪类 0,0,1,0 元素和伪元素 0,0,0,1 最后比较特殊的一个标志!important（权重），它没有特殊性值，但它的优先级是最高的 2块格式化上下文（Block Formatting Context）及其工作原理块格式上下文（BFC）是它是一个独立的渲染区域，容器里面的子元素不会影响到外面的元素。 BFC特性 在BFC中，盒子从顶端开始垂直地一个接一个地排列。 盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠。 在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。 BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。 计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。 如何触发BFC float的值不是none. position的值不是static或relative. display的值是table-cell、table-caption、inline-block、flex、或inline-flex。 overflow的值不是visible。 3.如何清除浮动 空div方法，在父盒子最后加一个空盒子并且加上clear:both&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt; 伪元素法，使用伪元素定义一个clearfix的样式类，然后使用&lt;div class=&quot;clearfix&quot;&gt; 给父亲设置overflow: auto或overflow: hidden等方法（触发BFC）。 给父元素指定高度。 4.外边距重叠（外边距坍塌）在 CSS 当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。 折叠结果遵循下列计算规则： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。 5.伪元素及其使用伪元素指的是两个冒号的选择器 div::before div::after p::first-letter 伪元素的用途： 1.用after清除浮动 123456789101112&lt;div class=\"clear-fix\"&gt; &lt;div&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; clear-fix::after &#123; clear: both; content: \"\"; display: block; height: 0; overflow: hidden &#125;&lt;/style&gt; 利用伪类实现简单图标 元素 hover 特效 6.flex布局中的属性在容器上可以设置6个属性： flex-direction 主轴方向 flex-wrap 主轴超出范围是否换行 flex-flow flex-direction和flex-wrap的复合属性 justify-content 元素在主轴的对齐方式 align-items 元素在侧轴的对齐方式 align-content 元素在侧轴的对齐方式（多行） 注意：当设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。 Flex 有六种属性可运用在 item 项目上: order flex-item的排序 flex-basis flex-item的宽度 flex-grow flex-item占据剩余空间的比例 flex-shrink flex-item占据收缩空间的比例 flex flex-grow\\flex-shrink\\flex-basis的复合属性 align-self 规定flex-item自己的对齐方式 7.行内元素、块级元素行内元素：在一行显示，不可以设置宽高。代表 span a input select strong 块级元素：换行显示，可以设置宽高。代表 div dl dd dt form p table tr th td 行内块级元素：在一行显示，可以设置宽高。代表 img input 8.水平垂直居中的方式 flex布局 123display: flex;justify-content: center;align-items: center; position定位 12345678910// 父容器position: relative;// 子容器position:absolute;margin:auto;top:0;bottom:0;left:0;right:0; position+transform 12345678// 父容器position: relative;// 子容器position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%); position+margin 123456789101112// 父容器position: relative;// 子容器height: 50px;background-color: #21252b;position: absolute;margin: auto;top: 50%;left: 50%;margin-left: -25px;margin-top: -25px; 9.CSS中link和@import的区别 link属于HTML标签，而@import是CSS提供的 页面加载时，link会同时被加载，而@import引用的CSS会等到页面加载完毕后再加载 import只在IE5以上被识别，存在兼容性问题，link无兼容性问题 link方式的样式的权重高于@import的权重 10.CSS的常用选择器1.id选择器（#box）2.类选择器（.box）3.标签选择器（div）4.相邻选择器（h1+p）5.子选择器（ul&gt;li）6.后代选择器（li a）7.通配符选择器（*）8.属性选择器（a[attr=”d1”]）9.伪类选择器（a:hover, li:nth-child）","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/总结/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"html知识点小结","slug":"html知识点总结","date":"2018-11-25T12:15:50.000Z","updated":"2020-01-21T11:38:17.418Z","comments":true,"path":"2018/11/25/html知识点总结/","link":"","permalink":"http://yoursite.com/2018/11/25/html知识点总结/","excerpt":"","text":"html知识点小结##1.语义化标签简单的来说就是用正确的标签做正确的事情。 优点： 见名知意，可读性好，方便代码的开发和维护。 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。 方便其他设备解析，如盲人阅读器根据语义渲染网页 2. CSS 的&lt;link&gt;标签放在&lt;head&gt;&lt;/head&gt;之间？ JS 的&lt;script&gt;标签放在&lt;/body&gt;之前 把&lt;link&gt;放在 &lt;head&gt;中 这种做法可以让页面逐步呈现，提高了用户体验。如果将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。并且link会阻止页面渲染但是不会组织页面的加载。 把&lt;script&gt;标签恰好放在&lt;/body&gt;之前 脚本在下载和执行期间会阻止 HTML 解析。把&lt;script&gt;标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户。 3.Reflow和Repaint（重绘和重排） Reflow：当涉及到DOM节点的布局属性发生变化时，就会重新计算该属性，浏览器会重新描绘相应的元素，此过程叫Reflow（回流或重排）。 Repaint：当影响DOM元素可见性的属性发生变化 (如 color) 时, 浏览器会重新描绘相应的元素, 此过程称为Repaint（重绘）。因此重排必然会引起重绘。 1- 调整窗口大小2- 字体大小3- 样式表变动4- 元素内容变化，尤其是输入控件5- CSS伪类激活，在用户交互过程中发生6- DOM操作，DOM元素增删、修改7- width, clientWidth, scrollTop等布局宽高的计算 Repaint和Reflow是不可避免的，只能说对性能的影响减到最小，给出下面几条建议：1- 避免逐条更改样式。建议集中修改样式，例如操作className。2- 避免频繁操作DOM。创建一个documentFragment或div，在它上面应用所有DOM操作，最后添加到文档里。设置 display:none的元素上操作，最后显示出来。3- 避免频繁读取元素几何属性（例如scrollTop）。绝对定位具有复杂动画的元素。4- 绝对定位使它脱离文档流，避免引起父元素及后续元素大量的回流 4.href和src区别它们之间的主要区别可以用这样一句话来概括：src用于替代这个元素，而href用于建立这个标签与外部资源之间的关系。 hrefhref标识超文本引用，用在link和a等元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系若在文档中添加href ，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。 srcsrc表示引用资源，替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分。当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。 使用场景 引用css文件时：href=&quot;cssfile.css&quot; 引用js文件时：src=&quot;myscript.js&quot; 引用图片：src=&quot;mypic.jpg&quot; 网站链接：href=&quot;http://www.webpage.com&quot; 5.浏览器的渲染过程 解析HTML生成DOM树。 解析CSS生成CSSOM规则树。 将DOM树与CSSOM规则树合并在一起生成渲染树。 遍历渲染树开始布局，计算每个节点的位置大小信息。 将渲染树每个节点绘制到屏幕。 6.doctype有什么用DOCTYPE是document type的简写，它并不是 HTML 标签，也没有结束标签，它是一种标记语言的文档类型声明，即告诉浏览器当前 HTML 是用什么版本编写的。 1.告知浏览器文档使用哪种 HTML 或 XHTML 规范。 2.告诉浏览器按照何种规范解析页（如果你的页面没有DOCTYPE的声明，那么浏览器会进入Quirks模式） 7.优化图片加载的方法 图片懒加载。 使用icon和精灵图技术。 使用其他服务器单独存放图片。 如果图片过大，可以使用特殊编码的图片（base64编码） 8.常见的浏览器内核有哪些Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML] Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）] 9.SEO中的TDK网页标题(title)：用于告诉用户和搜索引擎当前页面的核心内容，title是搜索引擎根据用户检索关键词进行排名的核心指标，一般标题中含有搜索的关键词才能获得较好的排名; 页面描述(description)：显示在搜索结果中，以百度为例如下图，用于告知用户网站页面的主要内容，作为引导用户点击的索引; 页面关键词(keywords)：告诉搜索引擎当前页面内容的关键词，用户无论在搜索结果还是浏览页面时都看不到页面关键词。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/总结/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"First-Blog","slug":"First-Blog","date":"2018-11-12T11:32:00.000Z","updated":"2020-01-19T15:27:15.732Z","comments":true,"path":"2018/11/12/First-Blog/","link":"","permalink":"http://yoursite.com/2018/11/12/First-Blog/","excerpt":"","text":"个人的第一篇博客今天开启了个人博客，打算记录和分享一些关于生活，学习，以及技术方面的内容，也算是一个简单的记录吧。 个人还是希望把日语继续学下去，工作中英语也很重要，还有各种前端技术，所以不能停滞不前，需要保持高度的学习状态，好好加油吧！","categories":[{"name":"随想","slug":"随想","permalink":"http://yoursite.com/categories/随想/"}],"tags":[{"name":"第一篇博客","slug":"第一篇博客","permalink":"http://yoursite.com/tags/第一篇博客/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"http://yoursite.com/categories/随想/"}]}]}