{"meta":{"title":"Moshou","subtitle":null,"description":null,"author":"Moshou","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"bangumi/index.html","permalink":"http://yoursite.com/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-10-15T00:10:32.000Z","comments":true,"path":"comment/index.html","permalink":"http://yoursite.com/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"client/index.html","permalink":"http://yoursite.com/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"donate/index.html","permalink":"http://yoursite.com/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"lab/index.html","permalink":"http://yoursite.com/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"music/index.html","permalink":"http://yoursite.com/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-10-15T00:10:32.000Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-10-15T00:10:32.000Z","comments":true,"path":"rss/index.html","permalink":"http://yoursite.com/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"http://yoursite.com/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-10-15T00:10:32.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"video/index.html","permalink":"http://yoursite.com/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"Vue结合webpack的使用","slug":"Vue结合webpack的使用","date":"2019-03-19T11:18:44.000Z","updated":"2020-01-28T14:45:09.921Z","comments":true,"path":"2019/03/19/Vue结合webpack的使用/","link":"","permalink":"http://yoursite.com/2019/03/19/Vue结合webpack的使用/","excerpt":"","text":"Vue结合webpack的使用1.基本使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#1.安装vue 运行npm i vue@2.3.4将vue安装为运行依赖 #2.main.js/* 注意：在webpack中使用 import Vue from &apos;vue&apos;导入的Vue构造函数功能不完整，只提供了runtime-only的方式，并没有提供像网页中那样的使用方式； import Vue from &apos;vue&apos; 导入包的规则： 1. 找项目根目录中有没有 node_modules 的文件夹 2. 在node_modules中根据包名，找对应的vue文件夹 3. 在vue文件夹中，找一个叫做 package.json 的包配置文件 4. 在package.json文件中，查找一个 main 属性【main属性指定了这个包在被加载时候的入口文件】，这里我们发现入口文件为vue.runtime.common.js，并不是vue.js文件 解决方案有两种： 1.在webpack.config.js下新增配置： resolve: &#123; alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.js&apos; &#125; &#125; 然后使用 import Vue from &apos;vue&apos; 就可以了 2.手动修改导包的路径为：import Vue from &apos;vue/dist/vue&apos;&apos;，此时无需修改配置文件*/import Vue from &apos;vue&apos;var login = &#123; template: &apos;&lt;h1&gt;这是login组件，是使用网页中形式创建出来的组件&lt;/h1&gt;&apos;&#125;var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg: &apos;123&apos; &#125;, components:&#123; login &#125;&#125;)#3.index.html&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;login&gt;&lt;/login&gt;&lt;/div&gt;#4.webpack.config.jsresolve: &#123; alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.js&apos; &#125;&#125;#5.package.json、.babelrc还有webpack的所需要安装的内容和之前一致 2.使用.vue的方式生成组件1vscode中安装vetur插件，可以格式化html、标准css（有分号 、大括号的那种）、标准js（有分号 、双引号的那种）、vue文件webstorm中支持vue文件的提示，需要安装插件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#1. 新建login.vue文件&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是登录组件，使用 .vue 文件定义出来的 &lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;#2.main.js引入.vue文件，并使用import Vue from &apos;vue&apos;import login from &apos;./login.vue&apos;var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg: &apos;123&apos; &#125;, components:&#123; login &#125;&#125;)#3. index.html&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;login&gt;&lt;/login&gt;&lt;/div&gt;#4.安装vue-loader和 vue-template-compiler(默认情况下不支持import方式引入.vue文件，需要安装下面两个文件)npm i vue-loader@15.4.2 vue-template-compiler@2.3.4//注意：这里vue-template-compiler版本需要和当前使用的vue版本一致#5.webpack.config.jsconst path = require(&apos;path&apos;)var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);//1.引入VueLoaderPlugin插件(在vue-loader15版本以后需要配置这个)const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin&apos;);module.exports = &#123; entry: path.join(__dirname, &apos;./src/main.js&apos;), output: &#123; path: path.join(__dirname, &apos;./dist&apos;), filename: &apos;bundle.js&apos; &#125;, plugins: [ new htmlWebpackPlugin(&#123; template:path.resolve(__dirname, &apos;src/index.html&apos;),//模板路径 filename:&apos;index.html&apos;//自动生成的HTML文件的名称 &#125;), // 2.配置VueLoaderPlugin插件 new VueLoaderPlugin() ], module: &#123; rules: [ &#123; test: /\\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;, &#123; test: /\\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125;, &#123; test: /\\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125;, &#123; test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: &apos;url-loader?limit=1024&amp;name=[hash:8]-[name].[ext]&apos; &#125;, &#123; test: /\\.(ttf|eot|svg|woff|woff2)$/, use: &apos;url-loader&apos; &#125;, &#123; test: /\\.js$/, use: &apos;babel-loader&apos;, exclude: /node_modules/ &#125;, //3.处理 .vue 文件的 loader &#123; test: /\\.vue$/, use: &apos;vue-loader&apos; &#125; ] &#125;, resolve: &#123; alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.js&apos; &#125; &#125;&#125; 3.render渲染组件123456789101112131415#main.jsimport Vue from &apos;vue&apos;import login from &apos;./login.vue&apos;var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg: &apos;123&apos; &#125;, render: c =&gt; c(login)&#125;)//注意：此种方式会替换页面内容 4.vue组件中的数据2.4.1 模块的导出 ES6语法： 在ES6中使用 export default 和 export 导出模块中的成员; (Node中使用 module.exports 和 export导出成员) 使用 import ** from ** 和 import ‘路径’ 还有 import {a, b} from ‘模块标识’ 导入其他模块 123456789101112131415161718192021222324252627282930#1. 新建test.js// 在 ES6 中，使用 export default 和 export 向外暴露成员：var info = &#123; name: 'zs', age: 20&#125;export default info/* 注意： export default 向外暴露的成员，可以使用任意的变量来接收 在一个模块中，export default 只允许向外暴露1次 在一个模块中，可以同时使用 export default 和 export 向外暴露成员*/export var title = '小星星'export var content = '哈哈哈'/*注意： 使用 export 向外暴露的成员，只能使用 &#123; &#125; 的形式来接收，这种形式叫做 【按需导出】 export 可以向外暴露多个成员， 同时如果某些成员在我们import 的时候不需要，则可以不在 &#123;&#125; 中定义 使用 export 导出的成员，必须严格按照导出时候的名称来使用 &#123;&#125; 按需接收； 使用 export 导出的成员，如果想换个名称来接收，可以使用 as 来起别名；*/#2. main.jsimport minfo3, &#123; title as title123, content &#125; from './test.js'console.log(minfo3) //这里的minfo3就是test.js中所暴露出来的default infoconsole.log(title123 + ' --- ' + content) 2.4.2 .vue中的数据导出123456789101112131415161718192021222324#login.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是登录组件，使用 .vue 文件定义出来的 --- &#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;button @click=\"show\"&gt;点我&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; // 注意：组件中的 data 必须是 function return &#123; msg: \"123321\" &#125;; &#125;, methods: &#123; show() &#123; console.log(\"调用了 login.vue 中的 show 方法\"); &#125; &#125; &#125;;&lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"webpack","slug":"webpack","date":"2019-03-04T14:47:43.000Z","updated":"2020-01-27T17:03:50.389Z","comments":true,"path":"2019/03/04/webpack/","link":"","permalink":"http://yoursite.com/2019/03/04/webpack/","excerpt":"","text":"webpack1.概念以及作用本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具； 借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。 123456789# 在没有使用webpack之前：举个例子：index.html里面有一大堆的css和js文件，如a.js b.js c.js d.js等等（1）a.js要用到b.js里面的一个函数，则a.js要放在b.js后面（2）c.js要用到a.js里面的一个函数，则c.js要放在a.js后面（3）b.js又要用到d.js文件里面的函数，则b.js就要放在d.js后面如果有N多个js文件，需要手动处理他们的关系，即容易出错。# 使用webpack：webpack的理念就是一切皆模块化，把一堆的css文件和js文件放在一个总的入口文件，通过require引入，剩下的事情webpack会处理，包括所有模块的前后依赖关系，打包、压缩、合并成一个js文件，公共代码抽离成一个js文件、某些自己指定的js单独打包，模块可以是css/js/images/font等等。 2.webpack的使用2.1webpack的安装 运行npm i webpack@4.27.1 -g全局安装webpack，这样就能在全局使用webpack的命令 npm i webpack-cli@3.1.2 –g 全局安装webpack命令行工具 1配置环境变量 在项目根目录中运行npm i webpack@4.27.1 --save-dev安装到项目依赖中 123npm info webpack //查看npm上的webpack的信息webpack -v //查看当前安装的webpack的版本信息 ####2.2webpack的配置文件 在项目根目录中创建webpack.config.js 由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在webpack.config.js中配置这两个路径： 1234567891011// 导入处理路径的模块var path = require(&apos;path&apos;);// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理module.exports = &#123; entry: path.resolve(__dirname, &apos;src/main.js&apos;), // 项目入口文件 output: &#123; // 配置输出选项 path: path.resolve(__dirname, &apos;dist&apos;), // 配置输出的路径 filename: &apos;bundle.js&apos; // 配置输出的文件名 &#125;&#125; 使用命令打包构建 123456789# 使用webpack命令即可打包项目、webpack //没有指定webpack打包的配置文件，默认使用项目根路径下的webpack.config.js文件webpack --config webpack.config.js //指定webpack打包的时候使用的配置文件// 当我们在控制台，直接输入 webpack 命令执行的时候，webpack 做了以下几步：// 1. 首先webpack 发现我们并没有通过命令的形式给它指定入口和出口// 2. webpack 就会去项目的根目录中查找一个叫做 `webpack.config.js` 的配置文件// 3. 当找到配置文件后，webpack会去解析执行这个配置文件，当解析执行完配置文件后，就得到了 配置文件中，导出的配置对象// 4. 当 webpack拿到配置对象后，就拿到了配置对象中指定的入口和出口，然后进行打包构建； 2.3webpack实时打包构建 由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用webpack-dev-server来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 安装webpack-dev-server 123npm i webpack-dev-server@3.1.9 --save-devnpm i webpack@4.27.1 --save-dev //项目中安装webpacknpm i webpack-cli@3.1.2 安装完成之后，在命令行直接运行webpack-dev-server来进行打包，发现报错，因为它不是全局命令，不可以直接使用。 我们借助于package.json文件中的指令来进行运行webpack-dev-server命令，在scripts节点下新增&quot;dev&quot;: &quot;webpack-dev-server&quot;指令，发现可以进行实时打包 1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack-dev-server&quot;&#125; 运行项目 1npm run dev 但是dist目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中。把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 12Project is running at [1m [34mhttp://localhost:8084/ [39m[22mwebpack output is served from / 1此时我们可以通过http://localhost:8083/bundle.js 文件，因为webpack-dev-server默认是将bundle.js文件打包到根路径，所以要能做到修改main.js之后页面也要同步变化，需要修改页面的script标签： 1&lt;script type=&quot;text/javascript&quot; src=&quot;../bundle.js&quot;&gt;&lt;/script&gt; 指定启动参数： 1为了能在访问http://localhost:8080/的时候直接访问到index首页，可以使用--contentBase src指令来修改dev指令，指定启动的根目录： 123456789&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack-dev-server --open --port 3001 --contentBase src --hot&quot; &#125;, // --open含义：构建完成自动打开浏览器 // --port 3001 : 指定运行的端口 // --contentBase src : 指定运行的根目录是src，即认为src就是项目根目录 // --hot : 以补丁的方式修改文件，而不是修改全部文件 解决webpack4.0之后打包大小警告和热更新慢的问题 123456789101112131415161718https://cloud.tencent.com/developer/section/1477466#main.js const path = require(&apos;path&apos;)module.exports = &#123; //1.设置为开发模式，不然热更新会比较缓慢 mode:&quot;development&quot;, entry: path.resolve(__dirname, &apos;src/main.js&apos;), output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;, //2.打包文件大小警告和错误的问题 performance: &#123; hints:false &#125;&#125; 2.4webpack配置文件生成参数12345678910111213141516171819202122const path = require(&apos;path&apos;)// 启用热更新的 第2步const webpack = require(&apos;webpack&apos;)module.exports = &#123; entry: path.join(__dirname, &apos;./src/main.js&apos;), output: &#123; path: path.join(__dirname, &apos;./dist&apos;), filename: &apos;bundle.js&apos; &#125;, devServer: &#123; // 这是配置 dev-server 命令参数的第二种形式，相对来说，这种方式麻烦一些 // --open --port 3000 --contentBase src --hot open: true, // 自动打开浏览器 port: 3000, // 设置启动时候的运行端口 contentBase: &apos;src&apos;, // 指定托管的根目录 hot: true // 启用热更新 的 第1步 &#125;, plugins: [ // 配置插件的节点 new webpack.HotModuleReplacementPlugin(), // new 一个热更新的 模块对象， 这是 启用热更新的第 3 步 ],&#125; ####2.5html-webpack-plugin插件配置启动页面 123https://www.npmjs.com/package/html-webpack-pluginhtml-webpack-plugin插件可以**将指定页面配置生成到内存中**，并且可以**将打包的bundle.js配置到内存中生成的html页面中**，使用步骤如下： 运行npm i html-webpack-plugin@3.2.0 --save-dev安装到开发依赖 修改webpack.config.js配置文件如下： 123456789101112131415161718const path = require(&apos;path&apos;)// 导入自动生成HTMl文件的插件var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; entry: path.join(__dirname, &apos;./src/main.js&apos;), output: &#123; path: path.join(__dirname, &apos;./dist&apos;), filename: &apos;bundle.js&apos; &#125;, plugins: [ // 添加plugins节点配置插件 new htmlWebpackPlugin(&#123; template:path.resolve(__dirname, &apos;src/index.html&apos;),//模板路径 filename:&apos;index.html&apos;//自动生成的HTML文件的名称 &#125;) ],&#125; package.json中script`节点中的dev指令如下： 1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack-dev-server --open --port 3001 --contentBase src --hot&quot;&#125;, 将index.html中script标签注释掉，因为html-webpack-plugin插件会自动把bundle.js注入到index.html页面中！ 2.6使用webpack打包css文件一般情况下，我们并不推荐在html页面中直接引入其他css文件，这样会导致过多的请求。对应的，我们可以使用webpack来构建。使用步骤如下： 运行 npm i style-loader css-loader --save-dev main.js中引入index.css 1import \"./css/index.css\" 修改webpack.config.js这个配置文件： 1234567// 用来配置第三方loader模块的module: &#123; rules: [ // 匹配以.css结尾的文件 &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;//处理css文件的规则 ]&#125; webpack 处理第三方文件类型的过程 12341. 发现这个要处理的文件不是JS文件，然后就去配置文件中，查找有没有对应的第三方 loader 规则2. 如果能找到对应的规则， 就会调用对应的loader处理这种文件类型；3. 在调用loader的时候，use中相关loader模块的调用顺序是从后向前调用的；4. 当最后的一个loader调用完毕，会把处理的结果直接交给 webpack 进行打包合并，最终输出到 bundle.js 中去 2.7使用webpack打包less文件 运行npm i less-loader less，需要同时安装less-loader和less main.js中引入index.less 1import \"./css/index.less\" 修改webpack.config.js这个配置文件： 123456module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125; ]&#125; 2.8使用webpack打包sass文件 运行npm i sass-loader@7.3.1 node-sass --save-dev main.js中引入index.scss 12//注意：文件名是scss结尾import \"./css/index.scss\" 在webpack.config.js中添加处理scss文件的loader模块： 1234567module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125; ]&#125; ####2.9使用webpack处理css中的路径 运行npm i url-loader file-loader --save-dev 在webpack.config.js中添加处理url路径的loader模块： 12345678module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;, &#123; test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: 'url-loader' &#125; ] &#125; index.css 12345div&#123; width: 600px; height: 450px; background-image: url(../images/1.jpg);&#125; 1注意点：url-loader默认情况下会将图片转换为base64编码的图片，好处是可以减少图片的二次请求。但是这种方式一般情况下适用于小图，如果是大图，我们可以像下面这样去使用： 1234567891011121314151617181920212223module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;, &#123; test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192, name:'[hash:8]-[name].[ext]' &#125; &#125; ] &#125; ]&#125;//limit ： 当图片大小小于等于指定的值时会进行base64编码//name =[name].[ext]： 不给图片重命名，还是使用原图名。如果没有这个属性，则默认会使用hashcode的方式来给图片重命名。//给图片重命名的好处是：如果在多个不同的目录下有两张同名的图片(内容不同)，不会产生冲突。(默认情况下webpack会将图片也打包到根路径下)//如果既想多个文件夹下的同名的图片被打包后不冲突，又想保留原来的图片名字，可以这样使用：name=[hash:8]-[name].[ext] ， [hash:8]表示保留8位hash值，然后再去追加原来的[name] 2.10使用webpack处理字体图标1234567891011121314151617181920212223242526module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125;, &#123; test: /\\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125;, &#123; test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: [ &#123; loader: &apos;url-loader&apos;, options: &#123; limit: 8192, name:&apos;[hash:8]-[name].[ext]&apos; &#125; &#125; ] &#125;, &#123; test: /\\.(ttf|eot|svg|woff|woff2)$/, use: [ &#123; loader:&apos;url-loader&apos; &#125; ] &#125;, // 处理 字体文件的 loader ]&#125; 2.11webpack中babel的配置1在 webpack 中，默认只能处理一部分 ES6 的新语法；这时候就需要借助于第三方的 loader，来帮助webpack 处理这些高级的语法，当第三方loader可以把高级语法转为低级的语法，然后再把结果交给 webpack 去打包到 bundle.js 中 运行npm i babel-core@6.26.3 babel-loader@7.1.5 babel-plugin-transform-runtime --save-dev安装babel的相关loader包 (babel的转换工具) 运行npm i babel-preset-env babel-preset-stage-0 --save-dev安装babel转换的语法 (es6的语法和es5的语法的对应关系) 在webpack.config.js中添加相关loader模块，其中需要注意的是，一定要把node_modules文件夹添加到排除项： 1234567891011module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;, &#123; test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: 'url-loader?limit=1024&amp;name=[hash:8]-[name].[ext]' &#125;, &#123; test: /\\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader' &#125;, // 处理 字体文件的 loader //配置 babel 的 loader规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉 &#123; test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/ &#125;, ]&#125; 在项目根目录中添加.babelrc文件，并修改这个配置文件如下(这个文件必须符合json的语法，不能有注释。字符串必须使用双引号)： 1234&#123; \"presets\": [\"env\", \"stage-0\"], \"plugins\": [\"transform-runtime\"]&#125; 注意：之前用的比较多的语法插件babel-preset-es2015更新为babel-preset-env，它包含了所有的ES相关的语法； 1.3.11 所有配置总结12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# 1.安装npm i webpack@4.20.1 --save-dev //安装webpacknpm init -y //项目初始化npm i webpack-dev-server@3.1.9 --save-dev //实时打包构建npm i webpack-cli@3.1.2 npm i html-webpack-plugin@3.2.0 --save-dev //配置内存页面npm i style-loader css-loader --save-dev //css加载器npm i less-loader less //less加载器npm i sass-loader@7.3.1 node-sass --save-dev //sass加载器npm i url-loader file-loader --save-dev //url加载器npm i babel-core@6.26.3 babel-loader@7.1.5 babel-plugin-transform-runtime --save-dev //babel转换工具npm i babel-preset-env babel-preset-stage-0 --save-dev //babel转换的语法#2.webpack.config.jsconst path = require(&apos;path&apos;)// 导入自动生成HTMl文件的插件var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; entry: path.join(__dirname, &apos;./src/main.js&apos;), output: &#123; path: path.join(__dirname, &apos;./dist&apos;), filename: &apos;bundle.js&apos; &#125;, plugins: [ // 添加plugins节点配置插件 new htmlWebpackPlugin(&#123; template:path.resolve(__dirname, &apos;src/index.html&apos;),//模板路径 filename:&apos;index.html&apos;//自动生成的HTML文件的名称 &#125;) ], module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125;, &#123; test: /\\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125;, &#123; test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: &apos;url-loader?limit=1024&amp;name=[hash:8]-[name].[ext]&apos; &#125;, &#123; test: /\\.(ttf|eot|svg|woff|woff2)$/, use: &apos;url-loader&apos; &#125;, // 处理 字体文件的 loader //配置 babel 的 loader规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉 &#123; test: /\\.js$/, use: &apos;babel-loader&apos;, exclude: /node_modules/ &#125;, ] &#125;&#125;#3.项目入口文件import &quot;./css/index.css&quot;console.log(&quot;ok&quot;);class Person&#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; showInfo()&#123; console.log(this.name); &#125;&#125;var p = new Person(&quot;xiaoming&quot;,18);console.log(p.name);#4.package.json &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack-dev-server --open --port 3000 --contentBase src --hot&quot; &#125;#5.项目根目录 .babelrc&#123; &quot;presets&quot;: [&quot;env&quot;, &quot;stage-0&quot;], &quot;plugins&quot;: [&quot;transform-runtime&quot;]&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"AJAX","slug":"AJAX","date":"2019-02-22T12:54:10.000Z","updated":"2020-01-27T12:25:28.267Z","comments":true,"path":"2019/02/22/AJAX/","link":"","permalink":"http://yoursite.com/2019/02/22/AJAX/","excerpt":"","text":"AJAX1.什么是AJAX？ Ajax（Asynchronous JavaScript and XML的缩写）是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。 AJAX的好处：可以通过js代码发送get或者post的请求去从后台获取到相应数据，并只对页面中的部分标签进行刷新渲染，而不需要刷新整个页面，节约了带宽，优化了性能 2.创建AJAX对象12//兼容性写法 ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);是为了兼容IE5 IE6var ajax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); 3.AJAX的方法12345678910111213141516171819202122//设置请求方式ajax.open(&quot;post&quot;,&quot;url&quot;,true); //第三个参数如果为true，则是异步，反之同步//设置请求头格式（post请求时一定要加请求头，这是因为在传输过程中会出现转码的情况，可能导致乱码的情况）xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);//发送请求:get请求参数放在url后面，post请求参数send()方法里面ajax.send(&quot;数据&quot;); //监听ajax状态，当ajax的状态发生改变的时候执行ajax.onreadystatechange = function()&#123; //响应完成，浏览器已经可以获取到服务器响应结果了 if(this.readyState == 4)&#123; //这是AJAX的状态码 区别与http的状态码 状态码还有 1 2 3 其中3是数据正在传输时的状态，他不保证数据的完整性 //http响应的状态码 if(this.state == 200)&#123; //还有302 301 404... //获取响应内容 console.log(this.responseText); //用ajax.responseText获取服务器返回的数据 //responseText 获得字符串形式的响应数据。 //responseXML 获得XML 形式的响应数据 &#125; &#125;&#125; 4.数据渲染的两种方式4.1数据在服务器中渲染完毕，返回给客户端一个完整页面 浏览器发送请求至服务器 服务器接收到请求的信息，根据请求找到相应的信息（如JSON数据），在读取相应的页面文件，并渲染成一个完整的页面，将这个页面返回给客户端 客户端接收到此页面，并显示 (此方式要在服务器端安装art-template express-art-template等第三方模板） 4.2服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示 客户端发送数据请求给服务器 服务器拿到请求，找到相应的数据（如JSON），直接将此数据返回给客户端 客户端拿到数据后，在客户端进行渲染，并显示。（此方式要用到前端渲染插件template-web.js） 5.XMLXML extensible Markup Language 扩展的标记语言，XML的标签可以自定义HTML Hyper Text Markup Lanaguage HTML的标签是由W3C规范的，大概一共200多个 XML用途：1、 定义数据结构2、 作为配置文件出现 XML组成：1、 XML文档声明2、 XML标签3、 XML属性4、 XML注释 XML文档注意点：1）xml的标签必须成对出现如，为成对出现时的标签也必须要是自关闭标签 如2）xml标签名称区分大小写。3）xml标签一定要正确配对。4）xml标签名中间不能使用空格5）xml标签名不能以数字开头6）注意： 在一个xml文档中，有且仅有一个根标签 12345678910111213141516//使用xml设计一个通讯录&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;contact&gt; &lt;person id=&quot;100&quot;&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;phone&gt;12345678&lt;/phone&gt; &lt;email&gt;12453@qq.com&lt;/email&gt; &lt;/person&gt; &lt;person id=&quot;101&quot;&gt; &lt;name&gt;李四&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;phone&gt;22345678&lt;/phone&gt; &lt;email&gt;34453@qq.com&lt;/email&gt; &lt;/person&gt;&lt;/contact&gt; xml的使用 1234567891011121314151617181920212223242526//服务器代码//返回XML格式的数据app.get(&quot;/getXML&quot;,(req,res)=&gt;&#123; //设置响应头，指定返回的数据是XML res.header(&quot;content-type&quot;,&quot;application/xml&quot;); var xml = &apos;&lt;?xml version=&quot;1.1&quot; encoding=&quot;utf-8&quot;?&gt;&apos;;//XML文档声明 xml += &apos;&lt;person&gt;&apos;; xml += &apos;&lt;name&gt;羊杨&lt;/name&gt;&apos;; xml += &apos;&lt;age&gt;16&lt;/age&gt;&apos;; xml += &apos;&lt;gender&gt;男&lt;/gender&gt;&apos;; xml += &apos;&lt;/person&gt;&apos;; res.send(xml);&#125;)//客户端代码ajax.onreadystatechange = function()&#123; if(this.readyState == 4)&#123; //获取响应的XML数据 var xml = this.responseXML.documentElement;//ajax.responseXML.documentElement拿到文档数据 var age = xml.querySelector(&quot;age&quot;);//用标签选择器获取到age数据 但此时age是&lt;age&gt;16&lt;/age&gt; console.log(age.innerHTML);//此处用innerText拿不到数据 console.log(xml.children);//xml的语法几乎与html语法类似 &#125;&#125; JSON json数据的使用 12345678910111213141516171819202122232425262728293031//服务器代码//返回JSON格式的数据app.get(&quot;/getJSON&quot;,(req,res)=&gt;&#123; //数组 let arr = [ &#123; name:&quot;zhangsan&quot;, age:&quot;18&quot;, gender:&quot;男&quot;, id:001 &#125;, &#123; name:&quot;lisi&quot;, age:&quot;28&quot;, gender:&quot;男&quot;, id:002 &#125; ] //将数组转换为JSON数据 res.status(200).send(JSON.stringify(arr));&#125;)//客户端代码ajax.onreadystatechange = function()&#123; if(this.readyState == 4)&#123; console.log(this.responseText); //这是JSON字符串，在使用的时候往往需要转换为对象 var students = JSON.parse(this.responseText); var html = template(&quot;generatorTable&quot;,&#123;students:students&#125;); container.innerHTML = html; &#125;&#125; 6.jQuery中的AJAX推荐使用 方便的一批 6.1使用客户端代码 123456789101112131415161718192021222324252627282930$.ajax(&#123; //请求方式 type:&quot;get&quot;, //post //请求路径 url:&quot;&quot;, //如http://localhost:3000/index //请求参数，无论是get还是post请求，请求参数都可以写在这里 //注意：请求为get时 在服务器得到请求参数时 仍然使用res.query //这里的data数据必须为字符串 若要传入json数据 需要将json数据转换为字符串如 JSON.stringify(&#123;[&#123;&#125;,&#123;&#125;]&#125;) data:&#123;name:&quot;zhangsan&quot;&#125;, //规定所要请求的数据的类型 dataType: &apos;&apos;, //在jQuery中如果请求已经是post，默认的contentType就是application/x-www-form-urlencoded,不需要单独再去写 //contentType: &quot;application/x-www-form-urlencoded&quot;, //请求成功的回调 success:function(res)&#123; console.log(res);//res是请求的到的数据 &#125; //请求出错的回调 推荐写 error:function(err)&#123; console.log(err); &#125; //无论请求的成功与否，只要请求结束都会执行此函数 complete:function(xhr)&#123; &#125;&#125;) 服务器代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152let express = require(&quot;express&quot;);let app = express();const bodyParser = require(&apos;body-parser&apos;);app.use(bodyParser.urlencoded(&#123;extended:false&#125;));//注意 当客户端中的data:JSON.stringify([&#123;name:&apos;zhangsan&apos;&#125;,&#123;name:&apos;lisi&apos;&#125;])时，服务器需要此配置//以解析body中的json数据app.use(bodyParser.json(&#123;extended:false&#125;));app.use(express.static(&quot;./views&quot;));//当ajax的url为&apos;/getJSON&apos;时 此接口响应 返回JSON格式的数据//此时ajax的dataType要设置为&apos;json&apos;app.get(&quot;/getJSON&quot;,(req,res)=&gt;&#123; //数组 let arr = [ &#123; name:&quot;zhangsan&quot;, age:&quot;18&quot;, gender:&quot;男&quot;, id:001 &#125;, &#123; name:&quot;lisi&quot;, age:&quot;28&quot;, gender:&quot;男&quot;, id:002 &#125; ] arr.forEach((user,idx)=&#123; if(user.name == req.body.name)&#123; res.status(200).send(JSON.stringify(user)); &#125; &#125;)&#125;)//当ajax的url为&apos;/getXML&apos;时 此接口响应 返回XML格式的数据//此时ajax的dataType要设置为&apos;xml&apos;app.get(&quot;/getXML&quot;,(req,res)=&gt;&#123; //设置响应头，指定返回的数据是XML res.header(&quot;content-type&quot;,&quot;application/xml&quot;); var xml = &apos;&lt;?xml version=&quot;1.1&quot; encoding=&quot;utf-8&quot;?&gt;&apos;; xml += &apos;&lt;person&gt;&apos;; xml += &apos;&lt;name&gt;zhangsan&lt;/name&gt;&apos;; xml += &apos;&lt;age&gt;16&lt;/age&gt;&apos;; xml += &apos;&lt;gender&gt;男&lt;/gender&gt;&apos;; xml += &apos;&lt;/person&gt;&apos;; res.send(xml);&#125;) 发送也接受html或script数据 服务器代码 123456789101112131415161718192021const express = require(&apos;express&apos;);const app = express();const bodyParser = require(&apos;body-parser&apos;);app.use(bodyParser.urlencoded(&#123;extended:false&#125;));app.use(express.static(&apos;views&apos;));app.get(&apos;/getScript&apos;,(req,res)=&gt;&#123; res.header(&apos;content-type&apos;,&apos;application/javascript;charset=utf-8&apos;); res.send(&apos;alert(123);&apos;);&#125;);app.get(&apos;/getHtml&apos;,(req,res)=&gt;&#123; res.header(&apos;content-type&apos;,&apos;text/html;charset=utf-8&apos;) res.send(&apos;&lt;h1&gt;HTML&lt;/h1&gt;&apos;);&#125;);app.listen(3000,()=&gt;&#123; console.log(&apos;running...&apos;);&#125;); 客户端代码 1234567891011121314151617181920212223242526272829303132$(&apos;#btn1&apos;).click(function()&#123; $.ajax(&#123; type: &apos;get&apos;, url: &apos;/getHtml&apos;, data: &apos;&apos;, dataType: &apos;html&apos;, success:function(res)&#123; //因为dataType为html jQuery。AJAX会自动设置响应头为text/html 则 可以直接追加res到页面中 $(&apos;#info&apos;).append(res); &#125;, error:function(err)&#123; console.log(err); &#125; &#125;);&#125;);$(&apos;#btn2&apos;).click(function()&#123; $.ajax(&#123; type: &apos;get&apos;, url: &apos;/getScript&apos;, data: &apos;&apos;, dataType: &apos;script&apos;, success:function(res)&#123; //之所以alert()能执行 是因为将script代码打印到控制台 控制台会执行script代码 //也可以用script标签的对res进行封装 追加到页面中 也可以执行 console.log(res); &#125;, error:function(err)&#123; console.log(err); &#125; &#125;);&#125;); 6.2dataTypedataType取值有xml、html、json、jsonp、script或者text 当dataType取值为json，会自动将服务器返回的文本数据通过JSON.parse()转换成对象。服务器应该设置这个响应头：res.header(“content-type”, “application/json;charset=utf-8”); 当dataType为xml或者text的时候，返回的数据不会另做处理服务器应该设置这个响应头：res.header(“content-type”,”application/xml”);res.header(“content-type”,”text/plain;charset=utf-8”); 当dataType为html的时候，返回的内容中的script标签会在网页内容被拼接到页面的时候执行服务器应该设置这个响应头：res.header(“content-type”,”text/html;charset=utf-8”); 当dataType为script的时候，会将服务器返回的结果当成js代码执行并且将js代码的文本内容返回给客户端服务器应该设置这个响应头：res.header(“content-type”,”application/javascript”); 当dataType为jsonp的时候，会向服务器发送一个jsonp请求服务器应该设置这个响应头：res.header(“content-type”,”application/javascript”); 6.3nprogress的使用（全局事件处理）1、在html文件中引入nprogress.js 和 nprogress.css 2 12345$(document).ajaxStart(function()&#123;//请求数据开始 NProgress.start();//数据加载动画&#125;).ajaxStop(function()&#123;//请求数据结束 NProgress.done();//数据加载完毕动画&#125;); 7.跨域请求同源策略是浏览器的一种安全策略，所谓同源是指 域名，协议，端口完全相同 ，只有同源的地址才可以相互通过AJAX的方式请求。 同源或者不同源说的是两个地址之间的关系，不同源地址之间请求我们称之为跨域请求 例如 12http://localhost:8000 是不可以通过ajax访问 http://locally.uieee.com/categories的因为两者不满足同源的条件 7.1如何进行跨域请求 CORS JSONP 代理服务器 修改document.domain Iframe Location.hash Window.postMessage() Websocket CORS只需要改动服务器，不用改动客户端代码，客户端可以直接使用$.ajax() Cross Origin Resource Share，跨域资源共享。这种方案无需客户端作出任何变化（客户端不用改代码），只是在被请求的服务端响应的时候添加一个Access- Control-Allow-Origin 的响应头，表示这个资源是否允许指定域请求。 12345678//直接在服务器配置如下,客户端代码和以前一样写app.all(&apos;*&apos;, function(req, res, next) &#123; res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-type&apos;); res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS,PATCH&quot;); res.header(&apos;Access-Control-Max-Age&apos;,6000);//预请求缓存10分钟 next(); &#125;); JSONPJSON with Padding 实质上是通过script的src属性进行数据请求。本质上不是AJAX请求 需要服务器和客户端配合 12345678910111213141516171819//此时客户端的地址为http://localhost:3000实现要点//客户端代码var script = document.createElement(&apos;script&apos;);script.src = &apos;http://localhost:9999/testJSONP&apos;;//向http://localhost:9999发送跨域请求document.body.appendChild(script)//服务器代码app.get(&quot;/testJSONP&quot;,(req,res)=&gt;&#123; //设置响应头 服务器给客户端发送了一个js代码块 res.header(&quot;content-type&quot;,&quot;application/javascript&quot;); let data = JSON.stringify(&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;) ; //服务器发送 `foo(&apos;&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;&apos;)` 这个字符串给客户端 res.send(`foo($&#123;data&#125;)`);&#125;)//如果服务器给客户端返回的js代码块中有函数调用，必须提前在客户端中声明要调用的那个函数function foo(data)&#123; console.log(data);&#125; jQuery代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//客户端代码$.ajax(&#123; type:&quot;get&quot;, url:&quot;http://localhost:9999/testJSONP&quot;, data:&apos;&apos;, dataType: &apos;jsonp&apos;, success:function(res)&#123; $(&apos;body&apos;).append(res); &#125; error:function(err)&#123; console.log(err); &#125; complete:function(xhr)&#123; &#125;&#125;);function foo(data)&#123; console.log(data);&#125;//服务器http://localhost:3000代码const express = require(&apos;express&apos;);const app = express();const bodyParser = require(&apos;body-parser&apos;);app.use(bodyParser.urlencoded(&#123;extended:false&#125;));app.use(express.static(&apos;views&apos;));app.listen(3000,()=&gt;&#123; console.log(&apos;running...&apos;);&#125;);//服务器http://localhost:8888代码const express = require(&apos;express&apos;);const app = express();const bodyParser = require(&apos;body-parser&apos;);app.use(bodyParser.urlencoded(&#123;extended:false&#125;));app.get(&apos;/getJsonp&apos;,(req,res)=&gt;&#123; res.send(&apos;foo(&quot;你拿到了http://localhost:8888的jsonp&quot;);&apos;);&#125;);app.listen(8888,()=&gt;&#123; console.log(&apos;running...&apos;);&#125;); 8.结束语AJAX是通过XMLHttpRequest或者封装后的框架进行网络请求，由于这种方式的配置和调用方式非常混乱，已被Fetch取代","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://yoursite.com/tags/AJAX/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"JS基础知识","slug":"js基本知识","date":"2019-02-05T13:25:25.000Z","updated":"2020-01-26T13:42:33.946Z","comments":true,"path":"2019/02/05/js基本知识/","link":"","permalink":"http://yoursite.com/2019/02/05/js基本知识/","excerpt":"","text":"JS基础知识1.JavaScript 是什么？ JavaScript 是一种轻量级的编程语言。 JavaScript 是可插入 HTML 页面的编程代码。 JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。 2.js的基本数据类型 Number String null undefined Boolean 复杂的数据类型：Array Function Object 3.typeof的类型12345678910typeof &quot;John&quot; // 返回 string typeof 3.14 // 返回 numbertypeof NaN // 返回 numbertypeof false // 返回 booleantypeof [1,2,3,4] // 返回 objecttypeof &#123;name:&apos;John&apos;, age:34&#125; // 返回 objecttypeof new Date() // 返回 objecttypeof function () &#123;&#125; // 返回 functiontypeof myCar // 返回 undefined (如果 myCar 没有声明)typeof null // 返回 object typeof只能区分值类型，对引用类型无能为力，只能区分函数functionNaN表示特殊的非数字值，null是空指针，并没有指向任何一个地址typeof能区分的五种基本类型：string、boolean、number、undefined、symbol和函数function 4.判断一个变量是否为数组 instanceof 判断 12var arr = [1,2,3,4];console.log(arr instanceof Array)//true; 原型链方法 123var arr = [1,23,4];console.log(arr.__proto__.constructor==Array);//trueconsole.log(arr.constructor==Array)//true 这两段代码是一样的 Object.prototype.toString 的用法 1234function isArray(o)&#123;return Object.prototype.toString.call(o)==&apos;[object Array]&apos;;&#125;console.log(isArray(ary)); Array.isArray() 12Array.isArray([1, 2, 3]); // true 5.use strict严格模式&quot;use strict&quot; 是 ES5 特性，它使我们的代码在函数或整个脚本中处于严格模式。严格模式帮助我们在代码的早期避免 bug，并为其添加限制。 严格模式的一些限制： 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不能在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 设立”严格模式”的目的，主要有以下几个： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 6.JS数组方法12345678910111213Array.concat( ) 连接数组Array.join( ) 将数组元素连接起来以构建一个字符串Array.length 数组的大小Array.pop( ) 删除并返回数组的最后一个元素Array.push( ) 给数组添加元素Array.reverse( ) 颠倒数组中元素的顺序Array.shift( ) 将元素移出数组Array.slice( ) 返回数组的一部分Array.sort( ) 对数组元素进行排序Array.splice( ) 插入、删除或替换数组的元素Array.toLocaleString( ) 把数组转换成局部字符串Array.toString( ) 将数组转换成一个字符串Array.unshift( ) 在数组头部插入一个元素","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"","slug":"Tomcat安装和使用","date":"2019-01-23T12:16:30.000Z","updated":"2020-01-26T08:39:32.794Z","comments":true,"path":"2019/01/23/Tomcat安装和使用/","link":"","permalink":"http://yoursite.com/2019/01/23/Tomcat安装和使用/","excerpt":"","text":"Tomcat安装和使用安装JDK步骤及配置JDK环境变量步骤省略。 一下载安装。1.官网下载 2.文件减压 二使用Tomcat 先解压下载的压缩包、然后在bin目录下找到startup.bat文件、并用鼠标双击此文件 然后在浏览器中输入http://localhost:8080回车后，显示如下界面：此时就说明Tomcat服务启动正常了。 ​ 将打包后的文件放入webapps目录下在此启动Tomcat访问8080端口即可。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"CSS3动画","slug":"CSS3动画","date":"2019-01-03T12:55:30.000Z","updated":"2020-01-24T12:18:00.259Z","comments":true,"path":"2019/01/03/CSS3动画/","link":"","permalink":"http://yoursite.com/2019/01/03/CSS3动画/","excerpt":"","text":"CSS3动画通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。 ###1.CSS3的@keyframes 规则 @keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。 @keyframes 中创建动画时，请把它捆绑到某个选择器，否则不会产生动画效果。通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器： 规定动画的名称 规定动画的时长 2.CSS3 中动画的使用动画是使元素从一种样式逐渐变化为另一种样式的效果。 您可以改变任意多的样式任意多的次数。 请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。 0% 是动画的开始，100% 是动画的完成。 为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。 动画是使元素从一种样式逐渐变化为另一种样式的效果。 您可以改变任意多的样式任意多的次数。 请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。 0% 是动画的开始，100% 是动画的完成。 为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div&#123;width:100px;height:100px;background:red;animation:myfirst 5s;-moz-animation:myfirst 5s; /* Firefox */-webkit-animation:myfirst 5s; /* Safari and Chrome */-o-animation:myfirst 5s; /* Opera */&#125;@keyframes myfirst&#123;from &#123;background:red;&#125;to &#123;background:yellow;&#125;&#125;@-moz-keyframes myfirst /* Firefox */&#123;from &#123;background:red;&#125;to &#123;background:yellow;&#125;&#125;@-webkit-keyframes myfirst /* Safari and Chrome */&#123;from &#123;background:red;&#125;to &#123;background:yellow;&#125;&#125;@-o-keyframes myfirst /* Opera */&#123;from &#123;background:red;&#125;to &#123;background:yellow;&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;本例在 Internet Explorer 中无效。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 3.CSS3 动画属性 animation (所有动画属性的简写属性，除了 animation-play-state 属性) 12animation: name duration timing-function delay iteration-count direction;animation: demo 3s liner 0.2 iteration-count direction; animation-name(为 @keyframes 动画指定名称) 1animation-name: keyframename|none; animation-duration(定义动画完成一个周期需要多少秒或毫秒) 1animation-duration: time; animation-timing-function(指定动画将如何完成一个周期） 12345678animation-timing-function: value;linear 动画从头到尾的速度是相同的。ease 默认。动画以低速开始，然后加快，在结束前变慢。ease-in 动画以低速开始。ease-out 动画以低速结束。 ease-in-out 动画以低速开始和结束。 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。 animation-delay (定义动画什么时候开始) 1animation-delay: time; animation-iteration-count(定义动画应该播放多少次) 1234animation-iteration-count: value;n 一个数字，定义应该播放多少次动画infinite 指定动画应该播放无限次（永远） animation-direction (定义是否循环交替反向播放动画) 12345678animation-direction: normal|reverse|alternate|alternate-reverse|initial|inherit;normal 默认值。动画按正常播放。 reverse 动画反向播放。 alternate 动画在奇数次（1、3、5...）正向播放，在偶数次（2、4、6...）反向播放。alternate-reverse 动画在奇数次（1、3、5...）反向播放，在偶数次（2、4、6...）正向播放。initial 设置该属性为它的默认值。 inherit 从父元素继承该属性。 animation–play-state(指定动画是否正在运行或已暂停) 1234animation-play-state: paused|running;paused 指定暂停动画 running 指定正在运行的动画 ​","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"},{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/动画/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"前端兼容性问题小结","slug":"前端兼容性问题小结","date":"2018-12-21T12:45:30.000Z","updated":"2020-01-24T12:18:06.408Z","comments":true,"path":"2018/12/21/前端兼容性问题小结/","link":"","permalink":"http://yoursite.com/2018/12/21/前端兼容性问题小结/","excerpt":"","text":"前端兼容性问题小结1.不同浏览器的标签默认的外补丁和内补丁不同问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。 碰到频率:100% 解决方案：CSS里 *{margin:0;padding:0;}，或使用第三方css文件重置。 备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。 2.图片默认有间距问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。 碰到几率：20% 解决方案：使用float属性为img布局 备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（我的一个学生使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以我禁止他们使用） ###3.IE9一下浏览器不能使用opacity 解决方案： 123opacity: 0.5;filter:alpha(opacity = 50);filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50); 4.IE6 背景闪烁的问题问题：链接、按钮用 CSSsprites 作为背景，在 ie6 下会有背景图闪烁的现象。原因是 IE6 没有将背景图缓存，每次触发 hover 的时候都会重新加载 解决：可以用 JavaScript 设置 ie6 缓存这些图片： 1document.execCommand(&quot;BackgroundImageCache&quot;, false, true); 5.键盘事件 keyCode 兼容性写法1234567891011var inp = document.getElementById(&apos;inp&apos;)var result = document.getElementById(&apos;result&apos;)function getKeyCode(e) &#123; e = e ? e : (window.event ? window.event : &quot;&quot;) return e.keyCode ? e.keyCode : e.which&#125;inp.onkeypress = function(e) &#123; result.innerHTML = getKeyCode(e)&#125; 6.DOM 事件处理程序的兼容写法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var eventshiv = &#123; // event兼容 getEvent: function(event) &#123; return event ? event : window.event; &#125;,// &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;兼容getType: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(event) &#123; &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; event.type;&#125;,// target兼容getTarget: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(event) &#123; &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; event.target ? event.target : event.srcelem;&#125;,// 添加事件句柄addHandler: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(elem, &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener) &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (elem.addEventListener) &#123; elem.addEventListener(&lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;); &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (elem.attachEvent) &#123; elem.attachEvent(&lt;span class=&quot;hljs-string&quot;&gt;&apos;on&apos;&lt;/span&gt; + &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener); &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &#123; // 在这里由于.与&lt;span class=&quot;hljs-string&quot;&gt;&apos;on&apos;&lt;/span&gt;字符串不能链接，只能用 [] elem[&lt;span class=&quot;hljs-string&quot;&gt;&apos;on&apos;&lt;/span&gt; + &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;] = listener; &#125;&#125;,// 移除事件句柄removeHandler: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(elem, &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener) &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (elem.removeEventListener) &#123; elem.removeEventListener(&lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;); &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (elem.detachEvent) &#123; elem.detachEvent(&lt;span class=&quot;hljs-string&quot;&gt;&apos;on&apos;&lt;/span&gt; + &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener); &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &#123; elem[&lt;span class=&quot;hljs-string&quot;&gt;&apos;on&apos;&lt;/span&gt; + &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;] = null; &#125;&#125;,// 添加事件代理addAgent: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (elem, &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, agent, listener) &#123; elem.addEventListener(&lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (e) &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (e.target.matches(agent)) &#123; listener.call(e.target, e); // this 指向 e.target &#125; &#125;);&#125;,// 取消默认行为preventDefault: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(event) &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (event.preventDefault) &#123; event.preventDefault(); &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &#123; event.returnValue = &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;; &#125;&#125;,// 阻止事件冒泡stopPropagation: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(event) &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (event.stopPropagation) &#123; event.stopPropagation(); &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &#123; event.cancelBubble = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;; &#125;&#125;;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"兼容性","slug":"兼容性","permalink":"http://yoursite.com/tags/兼容性/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"css知识点小结(2)","slug":"css知识点小结-2","date":"2018-12-13T12:42:33.000Z","updated":"2020-01-23T06:01:48.860Z","comments":true,"path":"2018/12/13/css知识点小结-2/","link":"","permalink":"http://yoursite.com/2018/12/13/css知识点小结-2/","excerpt":"","text":"css知识点小结(2)1.文本超出部分显示省略号单行 123overflow:hidden；text-overflow:ellipsis;white-space:nowarp; 多行 1234display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3; // 最多显示几行overflow: hidden; ###2.优雅降级和渐进增强 优雅降级： Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。 渐进增强： 从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验； 3.transition和animation的区别 transition是过渡动画，animation是帧动画。 transition只能从一种状态过渡到另外一种状态，animation可以定制复杂动画(多个帧)，可以定义动画的区间等。 transition必须通过一些行为才能触发（js或者伪类来触发），animation的话直接就可以触发。 4.margin-left:calc(-100%-100px) 代码中calc（）作用 通过计算来确定CSS属性值。 calc是英文单词calculate(计算)的缩写，是css3的一个新增的功能，你可以使用calc()给元素的border、margin、pading、font-size和width等属性设置动态值。calc()可以使用数学运算中的简单加（+）、减（-）、乘（）和除（/）来解决问题，而且还可以根据单位如px,em,rem和百分比来转化计算 5. Sass、Less的区别？CSS 预处理，他们是动态的样式语言。他们规定了一种特殊的语法并且内置了编译器，可以将less/sass写的代码通过编译器编译成 CSS。 1234Less和Sass的区别：1.变量符不一样，less 是@，而 Sass 是$;2.Sass支持条件语句，可以使用 if&#123;&#125;else&#123;&#125;,for&#123;&#125;循环等等。而 Less 不支持;3.Sass是基于Ruby，需要在服务端处理的；而Less是在客户端处理，需要引入less.js","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/总结/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"css知识点小结(1)","slug":"css知识点小结-1","date":"2018-12-02T11:30:30.000Z","updated":"2020-01-24T12:17:50.641Z","comments":true,"path":"2018/12/02/css知识点小结-1/","link":"","permalink":"http://yoursite.com/2018/12/02/css知识点小结-1/","excerpt":"","text":"css知识点小结(1)1.css选择器优先级选择器的特殊性值表述为4个部分，用0,0,0,0表示，权重计算规则如下： 行间样式 1,0,0,0 ID选择器 0,1,0,0 类选择器、属性选择器或伪类 0,0,1,0 元素和伪元素 0,0,0,1 最后比较特殊的一个标志!important（权重），它没有特殊性值，但它的优先级是最高的 2块格式化上下文（Block Formatting Context）及其工作原理块格式上下文（BFC）是它是一个独立的渲染区域，容器里面的子元素不会影响到外面的元素。 BFC特性 在BFC中，盒子从顶端开始垂直地一个接一个地排列。 盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠。 在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。 BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。 计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。 如何触发BFC float的值不是none. position的值不是static或relative. display的值是table-cell、table-caption、inline-block、flex、或inline-flex。 overflow的值不是visible。 3.如何清除浮动 空div方法，在父盒子最后加一个空盒子并且加上clear:both&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt; 伪元素法，使用伪元素定义一个clearfix的样式类，然后使用&lt;div class=&quot;clearfix&quot;&gt; 给父亲设置overflow: auto或overflow: hidden等方法（触发BFC）。 给父元素指定高度。 4.外边距重叠（外边距坍塌）在 CSS 当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。 折叠结果遵循下列计算规则： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。 5.伪元素及其使用伪元素指的是两个冒号的选择器 div::before div::after p::first-letter 伪元素的用途： 1.用after清除浮动 123456789101112&lt;div class=\"clear-fix\"&gt; &lt;div&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; clear-fix::after &#123; clear: both; content: \"\"; display: block; height: 0; overflow: hidden &#125;&lt;/style&gt; 利用伪类实现简单图标 元素 hover 特效 6.flex布局中的属性在容器上可以设置6个属性： flex-direction 主轴方向 flex-wrap 主轴超出范围是否换行 flex-flow flex-direction和flex-wrap的复合属性 justify-content 元素在主轴的对齐方式 align-items 元素在侧轴的对齐方式 align-content 元素在侧轴的对齐方式（多行） 注意：当设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。 Flex 有六种属性可运用在 item 项目上: order flex-item的排序 flex-basis flex-item的宽度 flex-grow flex-item占据剩余空间的比例 flex-shrink flex-item占据收缩空间的比例 flex flex-grow\\flex-shrink\\flex-basis的复合属性 align-self 规定flex-item自己的对齐方式 7.行内元素、块级元素行内元素：在一行显示，不可以设置宽高。代表 span a input select strong 块级元素：换行显示，可以设置宽高。代表 div dl dd dt form p table tr th td 行内块级元素：在一行显示，可以设置宽高。代表 img input 8.水平垂直居中的方式 flex布局 123display: flex;justify-content: center;align-items: center; position定位 12345678910// 父容器position: relative;// 子容器position:absolute;margin:auto;top:0;bottom:0;left:0;right:0; position+transform 12345678// 父容器position: relative;// 子容器position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%); position+margin 123456789101112// 父容器position: relative;// 子容器height: 50px;background-color: #21252b;position: absolute;margin: auto;top: 50%;left: 50%;margin-left: -25px;margin-top: -25px; 9.CSS中link和@import的区别 link属于HTML标签，而@import是CSS提供的 页面加载时，link会同时被加载，而@import引用的CSS会等到页面加载完毕后再加载 import只在IE5以上被识别，存在兼容性问题，link无兼容性问题 link方式的样式的权重高于@import的权重 10.CSS的常用选择器1.id选择器（#box）2.类选择器（.box）3.标签选择器（div）4.相邻选择器（h1+p）5.子选择器（ul&gt;li）6.后代选择器（li a）7.通配符选择器（*）8.属性选择器（a[attr=”d1”]）9.伪类选择器（a:hover, li:nth-child）","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/总结/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"html知识点小结","slug":"html知识点总结","date":"2018-11-25T12:15:50.000Z","updated":"2020-01-21T11:38:17.418Z","comments":true,"path":"2018/11/25/html知识点总结/","link":"","permalink":"http://yoursite.com/2018/11/25/html知识点总结/","excerpt":"","text":"html知识点小结##1.语义化标签简单的来说就是用正确的标签做正确的事情。 优点： 见名知意，可读性好，方便代码的开发和维护。 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。 方便其他设备解析，如盲人阅读器根据语义渲染网页 2. CSS 的&lt;link&gt;标签放在&lt;head&gt;&lt;/head&gt;之间？ JS 的&lt;script&gt;标签放在&lt;/body&gt;之前 把&lt;link&gt;放在 &lt;head&gt;中 这种做法可以让页面逐步呈现，提高了用户体验。如果将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。并且link会阻止页面渲染但是不会组织页面的加载。 把&lt;script&gt;标签恰好放在&lt;/body&gt;之前 脚本在下载和执行期间会阻止 HTML 解析。把&lt;script&gt;标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户。 3.Reflow和Repaint（重绘和重排） Reflow：当涉及到DOM节点的布局属性发生变化时，就会重新计算该属性，浏览器会重新描绘相应的元素，此过程叫Reflow（回流或重排）。 Repaint：当影响DOM元素可见性的属性发生变化 (如 color) 时, 浏览器会重新描绘相应的元素, 此过程称为Repaint（重绘）。因此重排必然会引起重绘。 1- 调整窗口大小2- 字体大小3- 样式表变动4- 元素内容变化，尤其是输入控件5- CSS伪类激活，在用户交互过程中发生6- DOM操作，DOM元素增删、修改7- width, clientWidth, scrollTop等布局宽高的计算 Repaint和Reflow是不可避免的，只能说对性能的影响减到最小，给出下面几条建议：1- 避免逐条更改样式。建议集中修改样式，例如操作className。2- 避免频繁操作DOM。创建一个documentFragment或div，在它上面应用所有DOM操作，最后添加到文档里。设置 display:none的元素上操作，最后显示出来。3- 避免频繁读取元素几何属性（例如scrollTop）。绝对定位具有复杂动画的元素。4- 绝对定位使它脱离文档流，避免引起父元素及后续元素大量的回流 4.href和src区别它们之间的主要区别可以用这样一句话来概括：src用于替代这个元素，而href用于建立这个标签与外部资源之间的关系。 hrefhref标识超文本引用，用在link和a等元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系若在文档中添加href ，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。 srcsrc表示引用资源，替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分。当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。 使用场景 引用css文件时：href=&quot;cssfile.css&quot; 引用js文件时：src=&quot;myscript.js&quot; 引用图片：src=&quot;mypic.jpg&quot; 网站链接：href=&quot;http://www.webpage.com&quot; 5.浏览器的渲染过程 解析HTML生成DOM树。 解析CSS生成CSSOM规则树。 将DOM树与CSSOM规则树合并在一起生成渲染树。 遍历渲染树开始布局，计算每个节点的位置大小信息。 将渲染树每个节点绘制到屏幕。 6.doctype有什么用DOCTYPE是document type的简写，它并不是 HTML 标签，也没有结束标签，它是一种标记语言的文档类型声明，即告诉浏览器当前 HTML 是用什么版本编写的。 1.告知浏览器文档使用哪种 HTML 或 XHTML 规范。 2.告诉浏览器按照何种规范解析页（如果你的页面没有DOCTYPE的声明，那么浏览器会进入Quirks模式） 7.优化图片加载的方法 图片懒加载。 使用icon和精灵图技术。 使用其他服务器单独存放图片。 如果图片过大，可以使用特殊编码的图片（base64编码） 8.常见的浏览器内核有哪些Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML] Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）] 9.SEO中的TDK网页标题(title)：用于告诉用户和搜索引擎当前页面的核心内容，title是搜索引擎根据用户检索关键词进行排名的核心指标，一般标题中含有搜索的关键词才能获得较好的排名; 页面描述(description)：显示在搜索结果中，以百度为例如下图，用于告知用户网站页面的主要内容，作为引导用户点击的索引; 页面关键词(keywords)：告诉搜索引擎当前页面内容的关键词，用户无论在搜索结果还是浏览页面时都看不到页面关键词。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/总结/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"First-Blog","slug":"First-Blog","date":"2018-11-12T11:32:00.000Z","updated":"2020-01-19T15:27:15.732Z","comments":true,"path":"2018/11/12/First-Blog/","link":"","permalink":"http://yoursite.com/2018/11/12/First-Blog/","excerpt":"","text":"个人的第一篇博客今天开启了个人博客，打算记录和分享一些关于生活，学习，以及技术方面的内容，也算是一个简单的记录吧。 个人还是希望把日语继续学下去，工作中英语也很重要，还有各种前端技术，所以不能停滞不前，需要保持高度的学习状态，好好加油吧！","categories":[{"name":"随想","slug":"随想","permalink":"http://yoursite.com/categories/随想/"}],"tags":[{"name":"第一篇博客","slug":"第一篇博客","permalink":"http://yoursite.com/tags/第一篇博客/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"http://yoursite.com/categories/随想/"}]}]}